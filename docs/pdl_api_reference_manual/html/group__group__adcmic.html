<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: ADCMic       (Delta-Sigma ADC with PDM microphone support)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__adcmic.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">ADCMic (Delta-Sigma ADC with PDM microphone support)</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>ADCMic driver is used to process analog and digital microphone signal and DC signal with the mxs40adcmic IP. </p>
<p>This IP interfaces with Delta-Sigma modulator part of the s40adcmic and implements CIC, decimation (FIR) and biquad filters. The ADC result is read by the CPU or the DMA from the FIFO of mxs40adcmic (and from CIC register for DC measurement). Instead of taking modulator data from s40adcmic, mxs40adcmic can also be configured to take PDM input directly from an external digital microphone.</p>
<div class="image">
<img src="ADCMicBlockDiagram.png" alt="ADCMicBlockDiagram.png"/>
</div>
<p>Consult the datasheet of your device for details of the clocking system.</p>
<p>The high level features of the subsystem are:</p><ul>
<li>Analog (MIC) and digital (PDM) microphones support.</li>
<li>Sample rate 8/16 ksps for audio (MIC and PDM modes).</li>
<li>Configurable biquad filter for custom audio equalization.</li>
<li>Selectable DC measurement range.</li>
<li>Interrupt &amp; trigger generation.</li>
<li>Built-in FIFO buffer (for audio only).</li>
</ul>
<h1><a class="anchor" id="group_adcmic_usage"></a>
Usage</h1>
<p>The high level steps to use this driver are:</p>
<ol type="1">
<li><a class="el" href="group__group__adcmic.html#group_adcmic_initialization">Initialization and Enabling</a></li>
<li><a class="el" href="group__group__adcmic.html#group_adcmic_clock">Clocks</a></li>
<li><a class="el" href="group__group__adcmic.html#group_adcmic_trigger">Triggering</a></li>
<li><a class="el" href="group__group__adcmic.html#group_adcmic_timer">Timer</a></li>
<li><a class="el" href="group__group__adcmic.html#group_adcmic_interrupt">Handling Interrupts</a></li>
<li><a class="el" href="group__group__adcmic.html#group_adcmic_dc_measurement">DC Voltage Measurement Accuracy</a></li>
<li><a class="el" href="group__group__adcmic.html#group_adcmic_fifo">FIFO Usage</a></li>
</ol>
<h1><a class="anchor" id="group_adcmic_initialization"></a>
Initialization and Enabling</h1>
<p>To configure the ADCMic subsystem call <a class="el" href="group__group__adcmic__functions__basic.html#ga3a8b909addc754b68cd7373e63f1fdbc">Cy_ADCMic_Init</a>. Pass in a pointer to the <a class="el" href="struct_m_x_s40_a_d_c_m_i_c___type.html">MXS40ADCMIC_Type</a> structure for the base hardware register address, pass in the configuration structure <a class="el" href="structcy__stc__adcmic__config__t.html">cy_stc_adcmic_config_t</a>, and pass in the operation mode.</p>
<p>After initialization, call <a class="el" href="group__group__adcmic__functions__basic.html#ga722d964ea6930fcd47b8e02b329669ea">Cy_ADCMic_Enable</a> to enable the block.</p>
<p>The configuration can be defined as follows: </p><div class="fragment"><div class="line"><a class="code" href="structcy__stc__adcmic__mic__config__t.html">cy_stc_adcmic_mic_config_t</a> micConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__adcmic__mic__config__t.html#a4ef87a512a7e1511ab1315dc087dcda2">sampleRate</a> = <a class="code" href="group__group__adcmic__enums.html#gga60be2d6103fee3f7a1dbb0f7732ecb16a66ba39acdbc0f0925fb6c67e700448c3">CY_ADCMIC_16KSPS</a>,</div><div class="line">    .micBias = <a class="code" href="group__group__adcmic__enums.html#gga5f12d4f2b8ec927e1f37a308911185b8a9b39de329660a3b988f612084224367e">CY_ADCMIC_BIAS_1_12_REF</a>,</div><div class="line">    .micBiasLz = <span class="keyword">false</span>,</div><div class="line">    .micClamp = <span class="keyword">false</span>,</div><div class="line">    .pgaGain = <a class="code" href="group__group__adcmic__enums.html#ggadeb06cc1ffc25c6cceffeb34f0fa36d8aa69662c9fed6e94346d2ae08b7019e6d">CY_ADCMIC_PGA_GAIN_6</a>, <span class="comment">/* 2X */</span></div><div class="line">    .pgaInCm = <a class="code" href="group__group__adcmic__enums.html#ggaa52a286a28db88c27c12895f59e47540ad220fad8944d658095d510f96c6c7c67">CY_ADCMIC_INCM_0_4</a>,</div><div class="line">    .pgaOutCm = <a class="code" href="group__group__adcmic__enums.html#gga3cff7b2219fa028c9b695681214483cca610c55ab84c5ec06bd933b56db190232">CY_ADCMIC_OUTCM_0_6</a>,</div><div class="line">    .biQuadConfig = NULL,</div><div class="line">    .fifoTrigger = <span class="keyword">true</span>,</div><div class="line">    .fifoFull = 4, <span class="comment">/* (64 - 4) * 2 = 120 samples */</span></div><div class="line">    .fifoEmpty = 4</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* The structure which will not be reconf—ñgured can be declared as const */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcy__stc__adcmic__pdm__config__t.html">cy_stc_adcmic_pdm_config_t</a> pdmConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__adcmic__pdm__config__t.html#ad7713be64717eb52b328a4cfb645935f">sampleRate</a> = <a class="code" href="group__group__adcmic__enums.html#gga60be2d6103fee3f7a1dbb0f7732ecb16a66ba39acdbc0f0925fb6c67e700448c3">CY_ADCMIC_16KSPS</a>,</div><div class="line">    .clockInv = <span class="keyword">false</span>,</div><div class="line">    .latchDelay = 1,</div><div class="line">    .biQuadConfig = NULL,</div><div class="line">    .fifoTrigger = <span class="keyword">true</span>,</div><div class="line">    .fifoFull = 4, <span class="comment">/* (64 - 4) * 2 = 120 samples */</span></div><div class="line">    .fifoEmpty = 4</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="structcy__stc__adcmic__context__t.html">cy_stc_adcmic_context_t</a> context;</div><div class="line"></div><div class="line"><a class="code" href="structcy__stc__adcmic__dc__config__t.html">cy_stc_adcmic_dc_config_t</a> dcConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__adcmic__dc__config__t.html#a359301dff3fe81bbfa0535b735ee2fe1">range</a> = <a class="code" href="group__group__adcmic__enums.html#gga882caa2feca9421138c98fce182ca354ab2b7ec39510be085a42a2e5a36fb87af">CY_ADCMIC_DC_RANGE_3_6V</a>,</div><div class="line">    .channel = <a class="code" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514a9516380d571cadb8f0032c017056f875">CY_ADCMIC_GPIO7</a>,</div><div class="line">    .timerPeriod = 3000, <span class="comment">/* ~ 30 uS @clk_sys = 96MHz */</span></div><div class="line">    .timerInput = <a class="code" href="group__group__adcmic__enums.html#gga8a8f51290d7209070ae205e88d01c32eafc8ecc29ccb75e8f996cdec2662362ac">CY_ADCMIC_TIMER_COUNT_INPUT_CLK_SYS</a>,</div><div class="line">    .context = &amp;context</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcy__stc__adcmic__config__t.html">cy_stc_adcmic_config_t</a> config =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__adcmic__config__t.html#ae12e5b1fa4ed00d00e7dd0af404f501f">micConfig</a> = &amp;micConfig,</div><div class="line">    <span class="comment">/* In case of the mode structure is declared as const - an additional type cast is needed here: */</span></div><div class="line">    .pdmConfig = (<a class="code" href="structcy__stc__adcmic__pdm__config__t.html">cy_stc_adcmic_pdm_config_t</a> *)&amp;pdmConfig,</div><div class="line">    .dcConfig = &amp;dcConfig,</div><div class="line">};</div></div><!-- fragment --> <h2><a class="anchor" id="group_adcmic_mic"></a>
Analog Microphone (MIC) Mode</h2>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Initialize ADCMic for the analog microphone operation: */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__adcmic__enums.html#ggaf46b38a86a6fbdfee98d9b37ae44a154a5372a55427aca75e12013c2bb7844157">CY_ADCMIC_SUCCESS</a> != <a class="code" href="group__group__adcmic__functions__basic.html#ga3a8b909addc754b68cd7373e63f1fdbc">Cy_ADCMic_Init</a>(MXS40ADCMIC0, &amp;config, <a class="code" href="group__group__adcmic__enums.html#gga0c6998d15b030e746482c263d62569c4aa0919e8b8af8bc814cd0c65eae6fd34d">CY_ADCMIC_MIC</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Something went wrong, insert error handling here */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__adcmic__enums.html#ggaf46b38a86a6fbdfee98d9b37ae44a154a5372a55427aca75e12013c2bb7844157">CY_ADCMIC_SUCCESS</a> != <a class="code" href="group__group__adcmic__functions__basic.html#ga76a424f92c974d8373b1c9dd75ee2e77">Cy_ADCMic_SetSampleRate</a>(MXS40ADCMIC0, <a class="code" href="group__group__adcmic__enums.html#gga60be2d6103fee3f7a1dbb0f7732ecb16a66ba39acdbc0f0925fb6c67e700448c3">CY_ADCMIC_16KSPS</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Something went wrong, insert error handling here */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="group__group__adcmic__functions__basic.html#ga722d964ea6930fcd47b8e02b329669ea">Cy_ADCMic_Enable</a>(MXS40ADCMIC0); <span class="comment">/* Enable the block operation */</span></div></div><!-- fragment --><p> Usually the MIC mode is used with FIFO, see <a class="el" href="group__group__adcmic.html#group_adcmic_fifo">FIFO Usage</a></p>
<h2><a class="anchor" id="group_adcmic_pdm"></a>
Digital Microphone (PDM) Mode</h2>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Initialize ADCMic for the digital microphone operation: */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__adcmic__enums.html#ggaf46b38a86a6fbdfee98d9b37ae44a154a5372a55427aca75e12013c2bb7844157">CY_ADCMIC_SUCCESS</a> != <a class="code" href="group__group__adcmic__functions__basic.html#ga3a8b909addc754b68cd7373e63f1fdbc">Cy_ADCMic_Init</a>(MXS40ADCMIC0, &amp;config, <a class="code" href="group__group__adcmic__enums.html#gga0c6998d15b030e746482c263d62569c4af219be692b133cbf3be83c90009b8bd8">CY_ADCMIC_PDM</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Something went wrong, insert error handling here */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="group__group__adcmic__functions__basic.html#ga722d964ea6930fcd47b8e02b329669ea">Cy_ADCMic_Enable</a>(MXS40ADCMIC0); <span class="comment">/* Enable the block operation */</span></div></div><!-- fragment --><p> Usually the MIC mode is used with FIFO, see <a class="el" href="group__group__adcmic.html#group_adcmic_fifo">FIFO Usage</a></p>
<h2><a class="anchor" id="group_adcmic_dc"></a>
DC Measurement (DC) Mode</h2>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Initialize ADCMic for the DC measurement: */</span></div><div class="line">    uint16_t data = 0U;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__adcmic__enums.html#ggaf46b38a86a6fbdfee98d9b37ae44a154a5372a55427aca75e12013c2bb7844157">CY_ADCMIC_SUCCESS</a> != <a class="code" href="group__group__adcmic__functions__basic.html#ga3a8b909addc754b68cd7373e63f1fdbc">Cy_ADCMic_Init</a>(MXS40ADCMIC0, &amp;config, <a class="code" href="group__group__adcmic__enums.html#gga0c6998d15b030e746482c263d62569c4a38fa43ff6cb50910002588af0a70005e">CY_ADCMIC_DC</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Something went wrong, insert error handling here */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="group__group__adcmic__functions__dc.html#gac09ab66d5d8fad6d1f7b24b18fcba8f2">Cy_ADCMic_SelectDcChannel</a>(MXS40ADCMIC0, <a class="code" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514a7882eae286d66378d954d9743ce1146d">CY_ADCMIC_GPIO0</a>); <span class="comment">/* Switch to the GPIO_0 */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__basic.html#ga722d964ea6930fcd47b8e02b329669ea">Cy_ADCMic_Enable</a>(MXS40ADCMIC0); <span class="comment">/* Enable the block operation */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__dc.html#ga0bfff648caad3604684019c82b740e8d">Cy_ADCMic_IsEndConversion</a>(MXS40ADCMIC0, <a class="code" href="group__group__adcmic__enums.html#ggaef8552fb17411ed60788242595742771a4c92d7cf983ec3bfe5e2393059444b21">CY_ADCMIC_WAIT_FOR_RESULT</a>); <span class="comment">/* Wait the conversion is done */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__basic.html#ga70979a0967644dec401b37a2a29b2481">Cy_ADCMic_Disable</a>(MXS40ADCMIC0); <span class="comment">/* Stop the operation */</span></div><div class="line">    data = <a class="code" href="group__group__adcmic__functions__dc.html#gad6e104e180e9e3c8ef195d55eddec82b">Cy_ADCMic_GetDcResult</a>(MXS40ADCMIC0); <span class="comment">/* Get the result */</span></div></div><!-- fragment --> <h2><a class="anchor" id="group_adcmic_biquad"></a>
Biquad filter Initialization</h2>
<p>The biquad filter usually is used to the audio stream equalization (in MIC or PDM modes): </p><div class="fragment"><div class="line"><a class="code" href="structcy__stc__adcmic__biquad__config__t.html">cy_stc_adcmic_biquad_config_t</a> biquadCfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__adcmic__biquad__config__t.html#aa963e3dadd68686606ad8a3c65e07959">bq0_num1_coeff</a> = 0x3F27UL,</div><div class="line">    .bq0_num2_coeff = 0x81B2UL,</div><div class="line">    .bq0_num3_coeff = 0x3F27UL,</div><div class="line">    .bq0_den2_coeff = 0x81B5UL,</div><div class="line">    .bq0_den3_coeff = 0x3E51UL,</div><div class="line">    .bq1_num1_coeff = 0x4CCFUL,</div><div class="line">    .bq1_num2_coeff = 0UL,</div><div class="line">    .bq1_num3_coeff = 0UL,</div><div class="line">    .bq1_den2_coeff = 0UL,</div><div class="line">    .bq1_den3_coeff = 0UL,</div><div class="line">    .bq2_num1_coeff = 0x4000UL,</div><div class="line">    .bq2_num2_coeff = 0UL,</div><div class="line">    .bq2_num3_coeff = 0UL,</div><div class="line">    .bq2_den2_coeff = 0UL,</div><div class="line">    .bq2_den3_coeff = 0UL,</div><div class="line">    .bq3_num1_coeff = 0x4000UL,</div><div class="line">    .bq3_num2_coeff = 0UL,</div><div class="line">    .bq3_num3_coeff = 0UL,</div><div class="line">    .bq3_den2_coeff = 0UL,</div><div class="line">    .bq3_den3_coeff = 0UL,</div><div class="line">    .bq4_num1_coeff = 0x4000UL,</div><div class="line">    .bq4_num2_coeff = 0UL,</div><div class="line">    .bq4_num3_coeff = 0UL,</div><div class="line">    .bq4_den2_coeff = 0UL,</div><div class="line">    .bq4_den3_coeff = 0UL,</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Initialize entire ADCMic with biquad filter */</span></div><div class="line">    config.<a class="code" href="structcy__stc__adcmic__config__t.html#ae12e5b1fa4ed00d00e7dd0af404f501f">micConfig</a>-&gt;<a class="code" href="structcy__stc__adcmic__mic__config__t.html#a36f425829f07d6345b9b1540d3a356c9">biQuadConfig</a> = &amp;biquadCfg;</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__adcmic__enums.html#ggaf46b38a86a6fbdfee98d9b37ae44a154a5372a55427aca75e12013c2bb7844157">CY_ADCMIC_SUCCESS</a> != <a class="code" href="group__group__adcmic__functions__basic.html#ga3a8b909addc754b68cd7373e63f1fdbc">Cy_ADCMic_Init</a>(MXS40ADCMIC0, &amp;config, <a class="code" href="group__group__adcmic__enums.html#gga0c6998d15b030e746482c263d62569c4aa0919e8b8af8bc814cd0c65eae6fd34d">CY_ADCMIC_MIC</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Something went wrong, insert error handling here */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* or initialize the BiQuad filter separately */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__basic.html#ga8a1feaca602d505d6faea844e1450593">Cy_ADCMic_InitBiquad</a>(MXS40ADCMIC0, &amp;biquadCfg);</div><div class="line">    <a class="code" href="group__group__adcmic__functions__basic.html#gadd0e574dab13e1e437c946c399ca9edb">Cy_ADCMic_BiquadBypass</a>(MXS40ADCMIC0, <span class="keyword">false</span>); <span class="comment">/* Unbypass the biquad filter */</span></div></div><!-- fragment --> <h1><a class="anchor" id="group_adcmic_clock"></a>
Clocks</h1>
<p>The ADCMic requires two input clocks:</p><ul>
<li>clk_sys - recommended frequency is 96MHz, input for the <a class="el" href="group__group__adcmic.html#group_adcmic_timer">Timer</a>, usually is routed from one of the <a class="el" href="group__group__sysclk__clk__hf.html">High-Frequency Clocks</a></li>
<li>clk_hf - recommended frequency is 24MHz, the audio (MIC and PDM modes) reference clock, usually is routed from one of the <a class="el" href="group__group__sysclk__clk__hf.html">High-Frequency Clocks</a></li>
</ul>
<p>For more exact information on the ADCMic clock routing, refer to the datasheet for your device.</p>
<h1><a class="anchor" id="group_adcmic_trigger"></a>
Triggering</h1>
<p>The ADCMic subsystem has two output triggers: from the timer and from the FIFO, the timer generates trigger always if enabled, the FIFO trigger could be configured separately for MIC and PDM modes by the <a class="el" href="structcy__stc__adcmic__mic__config__t.html#ac4760faa194b88eacf8d5f003957c75e">cy_stc_adcmic_mic_config_t::fifoTrigger</a> and <a class="el" href="structcy__stc__adcmic__pdm__config__t.html#a8bb466075f7b9923acebf47a6dc044f5">cy_stc_adcmic_pdm_config_t::fifoTrigger</a> respectively.</p>
<p>Also, they could be routed to any periphery using <a class="el" href="group__group__trigmux.html">TrigMux (Trigger Multiplexer)</a> driver, e.g. to DW block: </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: route the ADCMic FIFO trigger to the DW0 block */</span></div><div class="line">    <a class="code" href="group__group__trigmux__functions.html#ga3671fac144b75c3b3eddc5ab46ae96f6">Cy_TrigMux_Connect</a>(TRIG_IN_MUX_4_ADCMIC_DATA_AVAIL, TRIG_OUT_MUX_0_PDMA0_TR_IN0, <span class="keyword">false</span>, TRIGGER_TYPE_LEVEL);</div></div><!-- fragment --> <h1><a class="anchor" id="group_adcmic_timer"></a>
Timer</h1>
<p>The Timer is used for DC measurement for two purposes:</p><ul>
<li>generate periodic events based on ADCMic clk_sys clock.</li>
<li>count the CIC data update events.</li>
</ul>
<p>The timer period and input signal source are configured by the <a class="el" href="structcy__stc__adcmic__dc__config__t.html#a9168c7819159217a06f695fef5548ac8">cy_stc_adcmic_dc_config_t::timerPeriod</a> and <a class="el" href="structcy__stc__adcmic__dc__config__t.html#a00af0a41f1d6b7902385abcba218b3e2">cy_stc_adcmic_dc_config_t::timerInput</a> fields correspondingly.</p>
<h1><a class="anchor" id="group_adcmic_interrupt"></a>
Handling Interrupts</h1>
<p>The ADCMic subsystem has two interrupt sources: the timer and the FIFO. The FIFO interrupt can have several reasons, see <a class="el" href="group__group__adcmic__macros__fifo__status.html">FIFO Status Masks</a></p>
<p>The ADCMic interrupt to the NVIC is raised any time the intersection (logic and) of the interrupt flags and the corresponding interrupt masks are non-zero.</p>
<p>Implement an interrupt routine and assign it to the ADCMic interrupt. Use the pre-defined enumeration, adcmic_interrupt_adcmic_IRQn, as the interrupt source for the ADCMic.</p>
<p>The following code snippet demonstrates how to implement a routine to handle the interrupt. The routine gets called when any one of the ADCMic interrupts are triggered. When servicing an interrupt, the user must clear the interrupt so that subsequent interrupts can be handled.</p>
<p>The following code snippet demonstrates how to configure and enable the interrupt. </p><div class="fragment"><div class="line"><span class="comment">/* ISR function to handle ADCMic interrupts. </span></div><div class="line"><span class="comment"> * This same routine gets called when any of the enabled ADCMic interrupt sources are enabled.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">uint16_t data[64];</div><div class="line">uint8_t  dataCount;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ADCMic_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Read interrupt status register. */</span></div><div class="line">    uint32_t intrStatus = <a class="code" href="group__group__adcmic__functions__interrupt.html#gae9309c0b0b44c696c3de3a79290ec641">Cy_ADCMic_GetInterruptStatusMasked</a>(MXS40ADCMIC0);</div><div class="line"></div><div class="line">    <span class="comment">/* Check what triggered the interrupt. */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (<a class="code" href="group__group__adcmic__macros__interrupt.html#ga1a3748aac7c1fb78f2860c7f36d643d6">CY_ADCMIC_INTR_DATA</a> &amp; intrStatus))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (0U != (<a class="code" href="group__group__adcmic__macros__fifo__status.html#ga6a606709df5107fdd482ccecde1aea94">CY_ADCMIC_FIFO_EMPTY</a> &amp; <a class="code" href="group__group__adcmic__functions__fifo.html#gae4d911c0c8618b2147c6e3deafdbe419">Cy_ADCMic_GetFifoStatus</a>(MXS40ADCMIC0)))</div><div class="line">        {</div><div class="line">            dataCount = <a class="code" href="group__group__adcmic__functions__fifo.html#ga220eefbf87371967992dbbd993c747d6">Cy_ADCMic_ReadFifoAll</a>(MXS40ADCMIC0, data);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Check also the DC interrupt status, if enabled. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Clear the handled interrupt. */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__interrupt.html#ga51c3d5c6bdc5fef18119977ded174a28">Cy_ADCMic_ClearInterrupt</a>(MXS40ADCMIC0, intrStatus);</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Configure and enable the ADCMic interrupt. */</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> ADCMic_IRQ_cfg =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__sysint__t.html#a204a8f07adf056c8d3dd818136da853f">intrSrc</a>      = adcmic_interrupt_adcmic_IRQn, <span class="comment">/* Interrupt source is the ADCMic interrupt */</span></div><div class="line">        .intrPriority = 7UL                           <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">    };</div><div class="line">    </div><div class="line">    <span class="comment">/* Configure the interrupt with vector at ADCMic_Isr(). */</span></div><div class="line">    (void)<a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;ADCMic_IRQ_cfg, ADCMic_Isr);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the interrupt. */</span></div><div class="line">    NVIC_EnableIRQ(ADCMic_IRQ_cfg.<a class="code" href="structcy__stc__sysint__t.html#a204a8f07adf056c8d3dd818136da853f">intrSrc</a>);</div><div class="line">    </div><div class="line">    <span class="comment">/* Clear possible interrupt erroneously raised during block enabling */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__interrupt.html#ga51c3d5c6bdc5fef18119977ded174a28">Cy_ADCMic_ClearInterrupt</a>(MXS40ADCMIC0, <a class="code" href="group__group__adcmic__macros__interrupt.html#gaa22987ec467c499e394cd707c2d69a42">CY_ADCMIC_INTR</a>);</div><div class="line">    <a class="code" href="group__group__adcmic__functions__interrupt.html#ga50aef66098e540a452357c81e0f06687">Cy_ADCMic_EnableInterrupt</a>(MXS40ADCMIC0, <a class="code" href="group__group__adcmic__macros__interrupt.html#ga1a3748aac7c1fb78f2860c7f36d643d6">CY_ADCMIC_INTR_DATA</a>);</div></div><!-- fragment --><p> Alternately, instead of handling the interrupts, the <a class="el" href="group__group__adcmic__functions__dc.html#ga0bfff648caad3604684019c82b740e8d">Cy_ADCMic_IsEndConversion</a> function allows for firmware polling of the end of DC conversion status.</p>
<h1><a class="anchor" id="group_adcmic_fifo"></a>
FIFO Usage</h1>
<p>The ADCMic subsystem in the MIC and PDM modes stores the audio data into the FIFO. It can be configured separately for the MIC and PDM modes using <a class="el" href="structcy__stc__adcmic__mic__config__t.html#a9c346fcb52f36cc0320581ca9d380d2f">cy_stc_adcmic_mic_config_t::fifoFull</a>, <a class="el" href="structcy__stc__adcmic__mic__config__t.html#ade06e1dd8dfd8e6264b2e7d654ae6103">cy_stc_adcmic_mic_config_t::fifoEmpty</a> and <a class="el" href="structcy__stc__adcmic__pdm__config__t.html#ae8b96e9189dd4a0167c4df1c347ad51b">cy_stc_adcmic_pdm_config_t::fifoFull</a>, <a class="el" href="structcy__stc__adcmic__pdm__config__t.html#a77b60203271f82538197dbc4221facfe">cy_stc_adcmic_pdm_config_t::fifoEmpty</a> respectively and served either by ISR: </p><div class="fragment"><div class="line"><span class="comment">/* ISR function to handle ADCMic interrupts. </span></div><div class="line"><span class="comment"> * This same routine gets called when any of the enabled ADCMic interrupt sources are enabled.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">uint16_t data[64];</div><div class="line">uint8_t  dataCount;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ADCMic_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Read interrupt status register. */</span></div><div class="line">    uint32_t intrStatus = <a class="code" href="group__group__adcmic__functions__interrupt.html#gae9309c0b0b44c696c3de3a79290ec641">Cy_ADCMic_GetInterruptStatusMasked</a>(MXS40ADCMIC0);</div><div class="line"></div><div class="line">    <span class="comment">/* Check what triggered the interrupt. */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (<a class="code" href="group__group__adcmic__macros__interrupt.html#ga1a3748aac7c1fb78f2860c7f36d643d6">CY_ADCMIC_INTR_DATA</a> &amp; intrStatus))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (0U != (<a class="code" href="group__group__adcmic__macros__fifo__status.html#ga6a606709df5107fdd482ccecde1aea94">CY_ADCMIC_FIFO_EMPTY</a> &amp; <a class="code" href="group__group__adcmic__functions__fifo.html#gae4d911c0c8618b2147c6e3deafdbe419">Cy_ADCMic_GetFifoStatus</a>(MXS40ADCMIC0)))</div><div class="line">        {</div><div class="line">            dataCount = <a class="code" href="group__group__adcmic__functions__fifo.html#ga220eefbf87371967992dbbd993c747d6">Cy_ADCMic_ReadFifoAll</a>(MXS40ADCMIC0, data);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Check also the DC interrupt status, if enabled. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Clear the handled interrupt. */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__interrupt.html#ga51c3d5c6bdc5fef18119977ded174a28">Cy_ADCMic_ClearInterrupt</a>(MXS40ADCMIC0, intrStatus);</div><div class="line">}</div></div><!-- fragment --><p>Or by DMA: </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: route the ADCMic FIFO trigger to the DW0 block */</span></div><div class="line">    <a class="code" href="group__group__trigmux__functions.html#ga3671fac144b75c3b3eddc5ab46ae96f6">Cy_TrigMux_Connect</a>(TRIG_IN_MUX_4_ADCMIC_DATA_AVAIL, TRIG_OUT_MUX_0_PDMA0_TR_IN0, <span class="keyword">false</span>, TRIGGER_TYPE_LEVEL);</div></div><!-- fragment --> <h1><a class="anchor" id="group_adcmic_dc_measurement"></a>
DC Voltage Measurement Accuracy</h1>
<ul>
<li>The Offset is practically a raw count of the measured Ground voltage.</li>
<li>The Gain is essentially an amount of raw counts per 1 Volt of input voltage. It depends on the DC measurement range <a class="el" href="group__group__adcmic__enums.html#ga882caa2feca9421138c98fce182ca354">cy_en_adcmic_dc_range_t</a>.</li>
</ul>
<p>The default Offset <a class="el" href="group__group__adcmic__macros__dc__measurement.html#ga1d95f58912b8900e16f330d82935ae41">CY_ADCMIC_DC_OFFSET</a> and Gain for both ranges <a class="el" href="group__group__adcmic__macros__dc__measurement.html#ga604321fec149f43908f270191c6aae05">CY_ADCMIC_DC_1_8_GAIN</a> and <a class="el" href="group__group__adcmic__macros__dc__measurement.html#ga0bfa3ef1605f24ab3fa073047d9fea01">CY_ADCMIC_DC_3_6_GAIN</a> are precalculated based on the theory of the ADCMic operation <a class="el" href="group__group__adcmic__macros__dc__measurement.html">DC measurement definitions</a>.</p>
<p>So basically the raw count retrieved using <a class="el" href="group__group__adcmic__functions__dc.html#gad6e104e180e9e3c8ef195d55eddec82b">Cy_ADCMic_GetDcResult</a> for the desired DC input can be directly feed into any of the <a class="el" href="group__group__adcmic__functions__dc.html#gaae64c9203bf528b6f7f6f7edb5d25340">Cy_ADCMic_CountsTo_Volts</a>, <a class="el" href="group__group__adcmic__functions__dc.html#gaa4e4fed5d3528ca54a9ca8d6e67bb597">Cy_ADCMic_CountsTo_mVolts</a>, or <a class="el" href="group__group__adcmic__functions__dc.html#ga0f53cbec4f5114dae34c82dccd38a268">Cy_ADCMic_CountsTo_uVolts</a> functions and have for some extend accurate result.</p>
<p>However, to increase the accuracy the real ADCMic Gain and Offset can be defined by physically measuring the Reference Ground <a class="el" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514a3c094b826b2190670cbccd88af4127c1">CY_ADCMIC_REFGND</a> and the Reference BandGap <a class="el" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514ace32eafc41fe302a92105d665853ac08">CY_ADCMIC_BGREF</a>.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="comment">/* A typical flow for the DC channel measurement using averaging to eliminate a high frequency noise */</span></div><div class="line"><span class="preprocessor">#define AVGCNT 256</span></div><div class="line"></div><div class="line">int16_t <a class="code" href="group__group__ipc__bt__data__structures.html#ga36692bbc61358ebc0e37a6fc6a395d28">result</a>;</div><div class="line">int16_t offset;</div><div class="line">int16_t gain;</div><div class="line"></div><div class="line">int16_t GetResultAvg(<a class="code" href="group__group__adcmic__enums.html#ga152671e552d2117bcc613e7021ce8514">cy_en_adcmic_dc_channel_t</a> channel)</div><div class="line">{</div><div class="line">    uint32_t i;</div><div class="line">    uint32_t avg = 0UL;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__adcmic__functions__dc.html#gac09ab66d5d8fad6d1f7b24b18fcba8f2">Cy_ADCMic_SelectDcChannel</a>(MXS40ADCMIC0, channel);</div><div class="line">    <a class="code" href="group__group__adcmic__functions__basic.html#ga722d964ea6930fcd47b8e02b329669ea">Cy_ADCMic_Enable</a>(MXS40ADCMIC0); <span class="comment">/* Start the conversion */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__timer.html#ga7fa5c179aaa0812650b9c0204e1d1c42">Cy_ADCMic_EnableTimer</a>(MXS40ADCMIC0);</div><div class="line">    <a class="code" href="group__group__adcmic__functions__dc.html#ga0bfff648caad3604684019c82b740e8d">Cy_ADCMic_IsEndConversion</a>(MXS40ADCMIC0, <a class="code" href="group__group__adcmic__enums.html#ggaef8552fb17411ed60788242595742771a4c92d7cf983ec3bfe5e2393059444b21">CY_ADCMIC_WAIT_FOR_RESULT</a>); <span class="comment">/* Skip the first sample */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; AVGCNT; i++)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__adcmic__functions__dc.html#ga0bfff648caad3604684019c82b740e8d">Cy_ADCMic_IsEndConversion</a>(MXS40ADCMIC0, <a class="code" href="group__group__adcmic__enums.html#ggaef8552fb17411ed60788242595742771a4c92d7cf983ec3bfe5e2393059444b21">CY_ADCMIC_WAIT_FOR_RESULT</a>);</div><div class="line">        avg += (uint32_t)(int32_t)<a class="code" href="group__group__adcmic__functions__dc.html#gad6e104e180e9e3c8ef195d55eddec82b">Cy_ADCMic_GetDcResult</a>(MXS40ADCMIC0);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <a class="code" href="group__group__adcmic__functions__timer.html#ga9c997d644dce21fdbf1f002c94b8c7be">Cy_ADCMic_DisableTimer</a>(MXS40ADCMIC0);</div><div class="line">    <a class="code" href="group__group__adcmic__functions__basic.html#ga70979a0967644dec401b37a2a29b2481">Cy_ADCMic_Disable</a>(MXS40ADCMIC0); <span class="comment">/* Stop the conversion */</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> (int16_t)(int32_t)CY_SYSLIB_DIV_ROUND(avg, AVGCNT);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Then a typical flow of the Offset and Gain correction and raw counts into voltage units conversion */</span></div><div class="line">uint32_t microvolts;</div><div class="line">uint16_t millivolts;</div><div class="line"><span class="keywordtype">float</span>    volts;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Measurement(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    offset = GetResultAvg(<a class="code" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514a3c094b826b2190670cbccd88af4127c1">CY_ADCMIC_REFGND</a>); <span class="comment">/* Measure the reference GND - this is Offset value */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__dc.html#ga463bc0f38f4c35860bc6773e04f0afed">Cy_ADCMic_SetDcOffset</a>(offset, &amp;context); <span class="comment">/* Update the Offset */</span></div><div class="line">    <span class="comment">/* Measure the reference BandGap and calculate the Gain using the nominal BandGap voltage 0.85V */</span></div><div class="line">    gain = CY_SYSLIB_DIV_ROUND((GetResultAvg(<a class="code" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514ace32eafc41fe302a92105d665853ac08">CY_ADCMIC_BGREF</a>) - offset) * 1000L, <a class="code" href="group__group__adcmic__macros__dc__measurement.html#gad6721e5be3917c54786cc8cd453c6901">CY_ADCMIC_DC_VBG</a>);</div><div class="line">    <a class="code" href="group__group__adcmic__functions__dc.html#ga914afbd1aa02c7a38b89f3e59dc4851f">Cy_ADCMic_SetDcGain</a>(gain, &amp;context); <span class="comment">/* Update the Gain */</span></div><div class="line">    result = GetResultAvg(<a class="code" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514a9516380d571cadb8f0032c017056f875">CY_ADCMIC_GPIO7</a>); <span class="comment">/* Get the raw count of desired DC channel */</span></div><div class="line">    volts      = <a class="code" href="group__group__adcmic__functions__dc.html#gaae64c9203bf528b6f7f6f7edb5d25340">Cy_ADCMic_CountsTo_Volts</a> (result, &amp;context); <span class="comment">/* Convert the raw count into volts */</span></div><div class="line">    millivolts = <a class="code" href="group__group__adcmic__functions__dc.html#gaa4e4fed5d3528ca54a9ca8d6e67bb597">Cy_ADCMic_CountsTo_mVolts</a>(result, &amp;context); <span class="comment">/* Convert the raw count into  millivolts */</span></div><div class="line">    microvolts = <a class="code" href="group__group__adcmic__functions__dc.html#ga0f53cbec4f5114dae34c82dccd38a268">Cy_ADCMic_CountsTo_uVolts</a>(result, &amp;context); <span class="comment">/* Convert the raw count into  microvolts */</span></div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>this code snippet is not the only valid way to use this driver - it is just one possible example how it can be used.</dd></dl>
<h2><a class="anchor" id="group_adcmic_dc_vbg_calib"></a>
BandGap Calibration</h2>
<p>For further increase the measurement accuracy, the real BandGap voltage can be defined using external precise reference with exact known voltage:</p>
<p>Real BandGap voltage = external reference exact voltage * (BandGap counts - GND counts) / (external reference counts - GND counts).</p>
<p>And then use it in the Gain calculation as shown above instead of the nominal BandGap voltage <a class="el" href="group__group__adcmic__macros__dc__measurement.html#gad6721e5be3917c54786cc8cd453c6901">CY_ADCMIC_DC_VBG</a>.</p>
<h2><a class="anchor" id="group_adcmic_dc_double_sampling"></a>
Correlated Double Sampling</h2>
<p>To further improve the DC measurement accuracy, the low frequency Noise could be dynamically removed by performing two measurements for each input channel sequentially: one measuring the desired DC input and the other one measuring the <a class="el" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514a3c094b826b2190670cbccd88af4127c1">CY_ADCMIC_REFGND</a>. The second measurement of the<a class="el" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514a3c094b826b2190670cbccd88af4127c1">CY_ADCMIC_REFGND</a> contains only the low frequency Noise (Flick Noise) information. It is important to perform these two measurements one after another as close as possible. The final true ADC output value is then obtained by subtracting the ADC output of the second measurement from the ADC output of the first measurement.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="comment">/* The decimator takes decades of microseconds until start to produce accurate data,</span></div><div class="line"><span class="comment"> * so for the &#39;fast&#39; sampling we can use up to 16x averaging - it takes a commensurate time (~32 us)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#define AVGDS 16 </span><span class="comment">/* Averaging rate for the double sampling */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">uint32_t GetResult(<a class="code" href="group__group__adcmic__enums.html#ga152671e552d2117bcc613e7021ce8514">cy_en_adcmic_dc_channel_t</a> channel)</div><div class="line">{</div><div class="line">    uint32_t i;</div><div class="line">    uint32_t avg = 0UL;    </div><div class="line"></div><div class="line">    <a class="code" href="group__group__adcmic__functions__dc.html#gac09ab66d5d8fad6d1f7b24b18fcba8f2">Cy_ADCMic_SelectDcChannel</a>(MXS40ADCMIC0, channel);</div><div class="line">    <a class="code" href="group__group__adcmic__functions__basic.html#ga722d964ea6930fcd47b8e02b329669ea">Cy_ADCMic_Enable</a>(MXS40ADCMIC0); <span class="comment">/* Start the conversion */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__timer.html#ga7fa5c179aaa0812650b9c0204e1d1c42">Cy_ADCMic_EnableTimer</a>(MXS40ADCMIC0);</div><div class="line">    <a class="code" href="group__group__adcmic__functions__dc.html#ga0bfff648caad3604684019c82b740e8d">Cy_ADCMic_IsEndConversion</a>(MXS40ADCMIC0, <a class="code" href="group__group__adcmic__enums.html#ggaef8552fb17411ed60788242595742771a4c92d7cf983ec3bfe5e2393059444b21">CY_ADCMIC_WAIT_FOR_RESULT</a>); <span class="comment">/* Skip the first sample */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; AVGDS; i++)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__adcmic__functions__dc.html#ga0bfff648caad3604684019c82b740e8d">Cy_ADCMic_IsEndConversion</a>(MXS40ADCMIC0, <a class="code" href="group__group__adcmic__enums.html#ggaef8552fb17411ed60788242595742771a4c92d7cf983ec3bfe5e2393059444b21">CY_ADCMIC_WAIT_FOR_RESULT</a>);</div><div class="line">        avg += (uint32_t)(int32_t)<a class="code" href="group__group__adcmic__functions__dc.html#gad6e104e180e9e3c8ef195d55eddec82b">Cy_ADCMic_GetDcResult</a>(MXS40ADCMIC0);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <a class="code" href="group__group__adcmic__functions__timer.html#ga9c997d644dce21fdbf1f002c94b8c7be">Cy_ADCMic_DisableTimer</a>(MXS40ADCMIC0);</div><div class="line">    <a class="code" href="group__group__adcmic__functions__basic.html#ga70979a0967644dec401b37a2a29b2481">Cy_ADCMic_Disable</a>(MXS40ADCMIC0); <span class="comment">/* Stop the conversion */</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> avg; <span class="comment">/* return unsigned 20-bit value */</span></div><div class="line">}</div><div class="line"></div><div class="line">int16_t GetResultDs(<a class="code" href="group__group__adcmic__enums.html#ga152671e552d2117bcc613e7021ce8514">cy_en_adcmic_dc_channel_t</a> channel)</div><div class="line">{</div><div class="line">    uint32_t i;</div><div class="line">    uint32_t avg = 0UL;</div><div class="line">    uint32_t gnd = 0UL;    </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; AVGCNT; i++)</div><div class="line">    {</div><div class="line">        avg += GetResult(channel);</div><div class="line">        gnd += GetResult(<a class="code" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514a3c094b826b2190670cbccd88af4127c1">CY_ADCMIC_REFGND</a>);</div><div class="line">    }</div><div class="line">    </div><div class="line">    offset = (int16_t)CY_SYSLIB_DIV_ROUND(gnd, AVGCNT * AVGDS); <span class="comment">/* Calculate the Offset value */</span></div><div class="line">    <a class="code" href="group__group__adcmic__functions__dc.html#ga463bc0f38f4c35860bc6773e04f0afed">Cy_ADCMic_SetDcOffset</a>(offset, &amp;context); <span class="comment">/* Update the Offset */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514ace32eafc41fe302a92105d665853ac08">CY_ADCMIC_BGREF</a> == channel)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Calculate the Gain using the nominal BandGap voltage 0.85V */</span></div><div class="line">        gain = (int16_t)(int64_t)CY_SYSLIB_DIV_ROUND((uint64_t)(avg - gnd) * 1000L, (uint64_t)<a class="code" href="group__group__adcmic__macros__dc__measurement.html#gad6721e5be3917c54786cc8cd453c6901">CY_ADCMIC_DC_VBG</a> * AVGCNT * AVGDS);</div><div class="line">        <a class="code" href="group__group__adcmic__functions__dc.html#ga914afbd1aa02c7a38b89f3e59dc4851f">Cy_ADCMic_SetDcGain</a>(gain, &amp;context); <span class="comment">/* Update the Gain */</span></div><div class="line">        <span class="keywordflow">return</span> 0; <span class="comment">/* No need to return something meaningful */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> (int16_t)(int32_t)CY_SYSLIB_DIV_ROUND(avg, AVGCNT * AVGDS);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> DoubleSampling(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    (void) GetResultDs(<a class="code" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514ace32eafc41fe302a92105d665853ac08">CY_ADCMIC_BGREF</a>);</div><div class="line">    result = GetResultDs(<a class="code" href="group__group__adcmic__enums.html#gga152671e552d2117bcc613e7021ce8514a9516380d571cadb8f0032c017056f875">CY_ADCMIC_GPIO7</a>);</div><div class="line">    microvolts = <a class="code" href="group__group__adcmic__functions__dc.html#ga0f53cbec4f5114dae34c82dccd38a268">Cy_ADCMic_CountsTo_uVolts</a>(result, &amp;context);</div><div class="line">    millivolts = <a class="code" href="group__group__adcmic__functions__dc.html#gaa4e4fed5d3528ca54a9ca8d6e67bb597">Cy_ADCMic_CountsTo_mVolts</a>(result, &amp;context);</div><div class="line">    volts      = <a class="code" href="group__group__adcmic__functions__dc.html#gaae64c9203bf528b6f7f6f7edb5d25340">Cy_ADCMic_CountsTo_Volts</a> (result, &amp;context);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>this code snippet is not the only valid way to use this driver - it is just one possible example how it can be used.</dd></dl>
<h1><a class="anchor" id="group_adcmic_more_information"></a>
More Information</h1>
<p>For more information on the ADCMic ADC subsystem, refer to the datasheet of your device.</p>
<h1><a class="anchor" id="group_adcmic_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.0 </td><td><p class="starttd">The cy_en_adcmic_source_t is renamed to <a class="el" href="group__group__adcmic__enums.html#ga0c6998d15b030e746482c263d62569c4">cy_en_adcmic_mode_t</a>.<br />
 The CY_ADCMIC_480KSPS item is removed from the <a class="el" href="group__group__adcmic__enums.html#ga60be2d6103fee3f7a1dbb0f7732ecb16">cy_en_adcmic_sample_rate_t</a>.<br />
 The cy_en_adcmic_dc_conv_time_t is removed.<br />
 The cy_stc_adcmic_fifo_config_t is removed.<br />
 The cy_en_adcmic_dc_result_latch_mode_t is removed.<br />
 The cy_stc_adcmic_audio_analog_path_config_t is renamed to <a class="el" href="structcy__stc__adcmic__mic__config__t.html">cy_stc_adcmic_mic_config_t</a>.<br />
 The cy_stc_adcmic_audio_digital_path_config_t is renamed to <a class="el" href="structcy__stc__adcmic__pdm__config__t.html">cy_stc_adcmic_pdm_config_t</a>.<br />
 The cy_stc_adcmic_dc_path_config_t is renamed to <a class="el" href="structcy__stc__adcmic__dc__config__t.html">cy_stc_adcmic_dc_config_t</a>.<br />
</p>
<p>The micPd parameter is removed from the <a class="el" href="structcy__stc__adcmic__mic__config__t.html">cy_stc_adcmic_mic_config_t<br />
</a></p>
<p>The next parameters are added into <a class="el" href="structcy__stc__adcmic__mic__config__t.html">cy_stc_adcmic_mic_config_t</a> :<br />
</p><ul>
<li><a class="el" href="structcy__stc__adcmic__mic__config__t.html#a4ef87a512a7e1511ab1315dc087dcda2">cy_stc_adcmic_mic_config_t::sampleRate</a>,<br />
</li>
<li><a class="el" href="structcy__stc__adcmic__mic__config__t.html#a36f425829f07d6345b9b1540d3a356c9">cy_stc_adcmic_mic_config_t::biQuadConfig</a>,<br />
</li>
<li><a class="el" href="structcy__stc__adcmic__mic__config__t.html#ac4760faa194b88eacf8d5f003957c75e">cy_stc_adcmic_mic_config_t::fifoTrigger</a>,<br />
</li>
<li><a class="el" href="structcy__stc__adcmic__mic__config__t.html#a9c346fcb52f36cc0320581ca9d380d2f">cy_stc_adcmic_mic_config_t::fifoFull</a>,<br />
</li>
<li><a class="el" href="structcy__stc__adcmic__mic__config__t.html#ade06e1dd8dfd8e6264b2e7d654ae6103">cy_stc_adcmic_mic_config_t::fifoEmpty</a>.<br />
</li>
</ul>
<p>The clockDiv parameter is removed from the <a class="el" href="structcy__stc__adcmic__pdm__config__t.html">cy_stc_adcmic_pdm_config_t<br />
</a></p>
<p>The next parameters are added into <a class="el" href="structcy__stc__adcmic__pdm__config__t.html">cy_stc_adcmic_pdm_config_t</a> :<br />
</p><ul>
<li><a class="el" href="structcy__stc__adcmic__pdm__config__t.html#ad7713be64717eb52b328a4cfb645935f">cy_stc_adcmic_pdm_config_t::sampleRate</a>,<br />
</li>
<li><a class="el" href="structcy__stc__adcmic__pdm__config__t.html#aa640a2a2bd04e195b5b53737e3772a67">cy_stc_adcmic_pdm_config_t::biQuadConfig</a>,<br />
</li>
<li><a class="el" href="structcy__stc__adcmic__pdm__config__t.html#a8bb466075f7b9923acebf47a6dc044f5">cy_stc_adcmic_pdm_config_t::fifoTrigger</a>,<br />
</li>
<li><a class="el" href="structcy__stc__adcmic__pdm__config__t.html#ae8b96e9189dd4a0167c4df1c347ad51b">cy_stc_adcmic_pdm_config_t::fifoFull</a>,<br />
</li>
<li><a class="el" href="structcy__stc__adcmic__pdm__config__t.html#a77b60203271f82538197dbc4221facfe">cy_stc_adcmic_pdm_config_t::fifoEmpty</a>.<br />
</li>
</ul>
<p>The next parameters are removed from the <a class="el" href="structcy__stc__adcmic__dc__config__t.html">cy_stc_adcmic_dc_config_t</a> :<br />
</p><ul>
<li>tmrLatch,<br />
</li>
<li>time.<br />
</li>
</ul>
<p>The next parameter is renamed in the <a class="el" href="structcy__stc__adcmic__dc__config__t.html">cy_stc_adcmic_dc_config_t</a> :<br />
</p><ul>
<li>input -&gt; <a class="el" href="structcy__stc__adcmic__dc__config__t.html#a9db6b11e08ec3c86dede214203714390">cy_stc_adcmic_dc_config_t::channel</a>.<br />
</li>
</ul>
<p>The next parameters are added into <a class="el" href="structcy__stc__adcmic__dc__config__t.html">cy_stc_adcmic_dc_config_t</a> :<br />
</p><ul>
<li><a class="el" href="structcy__stc__adcmic__dc__config__t.html#a9168c7819159217a06f695fef5548ac8">cy_stc_adcmic_dc_config_t::timerPeriod</a>,<br />
</li>
<li><a class="el" href="structcy__stc__adcmic__dc__config__t.html#a00af0a41f1d6b7902385abcba218b3e2">cy_stc_adcmic_dc_config_t::timerInput</a>,<br />
</li>
<li><a class="el" href="structcy__stc__adcmic__dc__config__t.html#a00fcfd23a38fee917cc9492725a67fd2">cy_stc_adcmic_dc_config_t::context</a>.<br />
</li>
</ul>
<p>The next parameters are removed from the <a class="el" href="structcy__stc__adcmic__config__t.html" title="The ADCMic driver configuration structure. ">cy_stc_adcmic_config_t</a> :<br />
</p><ul>
<li>clockDiv,<br />
</li>
<li>source,<br />
</li>
<li>sampleRate,<br />
</li>
<li>biQuadConfig,<br />
</li>
<li>fifoConfig,<br />
</li>
<li>tmrTrgConfig.<br />
</li>
</ul>
<p>The next parameters are renamed in the <a class="el" href="structcy__stc__adcmic__config__t.html" title="The ADCMic driver configuration structure. ">cy_stc_adcmic_config_t</a> :<br />
</p><ul>
<li>anaConfig -&gt; <a class="el" href="structcy__stc__adcmic__config__t.html#ae12e5b1fa4ed00d00e7dd0af404f501f">cy_stc_adcmic_config_t::micConfig</a>,<br />
</li>
<li>digConfig -&gt; <a class="el" href="structcy__stc__adcmic__config__t.html#a7545f7d484a8b23b80cff58ea64dd284">cy_stc_adcmic_config_t::pdmConfig</a>.<br />
</li>
</ul>
<p class="endtd">The new parameter 'mode' is added to the <a class="el" href="group__group__adcmic__functions__basic.html#ga3a8b909addc754b68cd7373e63f1fdbc">Cy_ADCMic_Init</a>.<br />
 The <a class="el" href="group__group__adcmic__functions__basic.html#ga3a8b909addc754b68cd7373e63f1fdbc">Cy_ADCMic_Init</a> functions if fixed to proper process the <a class="el" href="structcy__stc__adcmic__mic__config__t.html#af5d989a86dc01a75ff3a62a238ace0ce">cy_stc_adcmic_mic_config_t::micClamp</a> setting.<br />
 The Cy_ADCMic_StartConvert and Cy_ADCMic_StopConvert API functions are removed.<br />
 The <a class="el" href="group__group__adcmic__functions__basic.html#ga722d964ea6930fcd47b8e02b329669ea">Cy_ADCMic_Enable</a> and <a class="el" href="group__group__adcmic__functions__basic.html#ga70979a0967644dec401b37a2a29b2481">Cy_ADCMic_Disable</a> are updated to inherit the Start/StopConvert functionality.<br />
 The Cy_ADCMic_SleepMic and Cy_ADCMic_WakeUpMic API functions are removed.<br />
 The <a class="el" href="group__group__adcmic__functions__basic.html#ga722d964ea6930fcd47b8e02b329669ea">Cy_ADCMic_Enable</a> and <a class="el" href="group__group__adcmic__functions__basic.html#ga70979a0967644dec401b37a2a29b2481">Cy_ADCMic_Disable</a> are updated to power down all the analog subsystems at disabling and power up them at enabling.<br />
 The parameter dcChannel of the <a class="el" href="group__group__adcmic__functions__dc.html#gac09ab66d5d8fad6d1f7b24b18fcba8f2">Cy_ADCMic_SelectDcChannel</a> is renamed to channel.<br />
 The function Cy_ADCMic_SetDcConvTime is removed.<br />
 The interface of <a class="el" href="group__group__adcmic__functions__dc.html#ga463bc0f38f4c35860bc6773e04f0afed">Cy_ADCMic_SetDcOffset</a>, <a class="el" href="group__group__adcmic__functions__dc.html#ga914afbd1aa02c7a38b89f3e59dc4851f">Cy_ADCMic_SetDcGain</a>, <a class="el" href="group__group__adcmic__functions__dc.html#gaa4e4fed5d3528ca54a9ca8d6e67bb597">Cy_ADCMic_CountsTo_mVolts</a>, <a class="el" href="group__group__adcmic__functions__dc.html#ga0f53cbec4f5114dae34c82dccd38a268">Cy_ADCMic_CountsTo_uVolts</a>,<br />
 and <a class="el" href="group__group__adcmic__functions__dc.html#gaae64c9203bf528b6f7f6f7edb5d25340">Cy_ADCMic_CountsTo_Volts</a> functions is changed: the 'base' parameters are removed, and the 'context' parameters are added.<br />
 The documentation is enhanced with code snippets: <a class="el" href="group__group__adcmic.html#group_adcmic_dc_measurement">DC Voltage Measurement Accuracy</a>, <a class="el" href="group__group__adcmic.html#group_adcmic_dc_double_sampling">Correlated Double Sampling</a>.  </p>
</td><td>Usability review  </td></tr>
<tr>
<td>0.1 </td><td>This is a pre-production driver release. The driver is not recommended for production use, unless the functionality is delivered in Cypress-provided applications. </td><td>Pre-production support of the CAT1B Devices  </td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__adcmic__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adcmic__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__adcmic__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adcmic__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__adcmic__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adcmic__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__adcmic__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adcmic__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
