<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: Low-Level</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__uart__low__level__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Low-Level<div class="ingroups"><a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a> &raquo; <a class="el" href="group__group__scb__uart.html">UART (SCB)</a> &raquo; <a class="el" href="group__group__scb__uart__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae8eba8924ed4b8add6e7cabdf25a18fe"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gae8eba8924ed4b8add6e7cabdf25a18fe">Cy_SCB_UART_Put</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t data)</td></tr>
<tr class="memdesc:gae8eba8924ed4b8add6e7cabdf25a18fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a single data element in the UART TX FIFO.  <a href="#gae8eba8924ed4b8add6e7cabdf25a18fe">More...</a><br /></td></tr>
<tr class="separator:gae8eba8924ed4b8add6e7cabdf25a18fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242ad51b987fa6ccfc23f3471182ce36"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga242ad51b987fa6ccfc23f3471182ce36">Cy_SCB_UART_PutArray</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga242ad51b987fa6ccfc23f3471182ce36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places an array of data in the UART TX FIFO.  <a href="#ga242ad51b987fa6ccfc23f3471182ce36">More...</a><br /></td></tr>
<tr class="separator:ga242ad51b987fa6ccfc23f3471182ce36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac709dbaa61ae25a05086124f1ffaa0d7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gac709dbaa61ae25a05086124f1ffaa0d7">Cy_SCB_UART_PutArrayBlocking</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:gac709dbaa61ae25a05086124f1ffaa0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places an array of data in the UART TX FIFO.  <a href="#gac709dbaa61ae25a05086124f1ffaa0d7">More...</a><br /></td></tr>
<tr class="separator:gac709dbaa61ae25a05086124f1ffaa0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4092c34575a47087e08a58529451914b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga4092c34575a47087e08a58529451914b">Cy_SCB_UART_PutString</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, <a class="el" href="group__group__syslib__macros.html#ga40bb5262bf908c328fbcfbe5d29d0201">char_t</a> const string[])</td></tr>
<tr class="memdesc:ga4092c34575a47087e08a58529451914b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a NULL terminated string in the UART TX FIFO.  <a href="#ga4092c34575a47087e08a58529451914b">More...</a><br /></td></tr>
<tr class="separator:ga4092c34575a47087e08a58529451914b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26a75a58d128e402f3bba6ff2bdad82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gab26a75a58d128e402f3bba6ff2bdad82">Cy_SCB_UART_SendBreakBlocking</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t breakWidth)</td></tr>
<tr class="memdesc:gab26a75a58d128e402f3bba6ff2bdad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a break condition (logic low) of specified width on UART TX line.  <a href="#gab26a75a58d128e402f3bba6ff2bdad82">More...</a><br /></td></tr>
<tr class="separator:gab26a75a58d128e402f3bba6ff2bdad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ab3686a98a0e215c1f2eeed3ce254f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga86ab3686a98a0e215c1f2eeed3ce254f">Cy_SCB_UART_Get</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga86ab3686a98a0e215c1f2eeed3ce254f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single data element from the UART RX FIFO.  <a href="#ga86ab3686a98a0e215c1f2eeed3ce254f">More...</a><br /></td></tr>
<tr class="separator:ga86ab3686a98a0e215c1f2eeed3ce254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga509c3f8c4acd406d4253019d28a0eb3a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga509c3f8c4acd406d4253019d28a0eb3a">Cy_SCB_UART_GetArray</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga509c3f8c4acd406d4253019d28a0eb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of data out of the UART RX FIFO.  <a href="#ga509c3f8c4acd406d4253019d28a0eb3a">More...</a><br /></td></tr>
<tr class="separator:ga509c3f8c4acd406d4253019d28a0eb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d45f3f8f625e2f16341a03a4078698e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga7d45f3f8f625e2f16341a03a4078698e">Cy_SCB_UART_GetArrayBlocking</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga7d45f3f8f625e2f16341a03a4078698e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of data out of the UART RX FIFO.  <a href="#ga7d45f3f8f625e2f16341a03a4078698e">More...</a><br /></td></tr>
<tr class="separator:ga7d45f3f8f625e2f16341a03a4078698e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76218bc016256d8525c9d779a4c2e9aa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga76218bc016256d8525c9d779a4c2e9aa">Cy_SCB_UART_GetTxFifoStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga76218bc016256d8525c9d779a4c2e9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current status of the TX FIFO.  <a href="#ga76218bc016256d8525c9d779a4c2e9aa">More...</a><br /></td></tr>
<tr class="separator:ga76218bc016256d8525c9d779a4c2e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd4607b147b35fbd9c47e89f77aa1f89"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gabd4607b147b35fbd9c47e89f77aa1f89">Cy_SCB_UART_ClearTxFifoStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t clearMask)</td></tr>
<tr class="memdesc:gabd4607b147b35fbd9c47e89f77aa1f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the selected statuses of the TX FIFO.  <a href="#gabd4607b147b35fbd9c47e89f77aa1f89">More...</a><br /></td></tr>
<tr class="separator:gabd4607b147b35fbd9c47e89f77aa1f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d783e45d8b8a9803bb5b667d71f3b9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gaa2d783e45d8b8a9803bb5b667d71f3b9">Cy_SCB_UART_GetRxFifoStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gaa2d783e45d8b8a9803bb5b667d71f3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current status of the RX FIFO.  <a href="#gaa2d783e45d8b8a9803bb5b667d71f3b9">More...</a><br /></td></tr>
<tr class="separator:gaa2d783e45d8b8a9803bb5b667d71f3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f1e6aa6e686a215ab03b5d264510b3f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga3f1e6aa6e686a215ab03b5d264510b3f">Cy_SCB_UART_ClearRxFifoStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t clearMask)</td></tr>
<tr class="memdesc:ga3f1e6aa6e686a215ab03b5d264510b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the selected statuses of the RX FIFO.  <a href="#ga3f1e6aa6e686a215ab03b5d264510b3f">More...</a><br /></td></tr>
<tr class="separator:ga3f1e6aa6e686a215ab03b5d264510b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f264dad00ca5fcdf668f20e35e4fcab"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga0f264dad00ca5fcdf668f20e35e4fcab">Cy_SCB_UART_GetNumInTxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga0f264dad00ca5fcdf668f20e35e4fcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data elements in the UART TX FIFO.  <a href="#ga0f264dad00ca5fcdf668f20e35e4fcab">More...</a><br /></td></tr>
<tr class="separator:ga0f264dad00ca5fcdf668f20e35e4fcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81aff78dcdc266d6cac81e714afef6c3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga81aff78dcdc266d6cac81e714afef6c3">Cy_SCB_UART_IsTxComplete</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga81aff78dcdc266d6cac81e714afef6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the TX FIFO and Shifter are empty and there is no more data to send.  <a href="#ga81aff78dcdc266d6cac81e714afef6c3">More...</a><br /></td></tr>
<tr class="separator:ga81aff78dcdc266d6cac81e714afef6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4b66b875dbc70d52adf19170d3a530"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gabc4b66b875dbc70d52adf19170d3a530">Cy_SCB_UART_GetNumInRxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gabc4b66b875dbc70d52adf19170d3a530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data elements in the UART RX FIFO.  <a href="#gabc4b66b875dbc70d52adf19170d3a530">More...</a><br /></td></tr>
<tr class="separator:gabc4b66b875dbc70d52adf19170d3a530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d8e77bc0b4932906b9769ccfaff4de"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga87d8e77bc0b4932906b9769ccfaff4de">Cy_SCB_UART_ClearRxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base)</td></tr>
<tr class="memdesc:ga87d8e77bc0b4932906b9769ccfaff4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all data out of the UART RX FIFO.  <a href="#ga87d8e77bc0b4932906b9769ccfaff4de">More...</a><br /></td></tr>
<tr class="separator:ga87d8e77bc0b4932906b9769ccfaff4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe05205dc0a6035395c7738b0de0dcc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gadbe05205dc0a6035395c7738b0de0dcc">Cy_SCB_UART_ClearTxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base)</td></tr>
<tr class="memdesc:gadbe05205dc0a6035395c7738b0de0dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all data out of the UART TX FIFO.  <a href="#gadbe05205dc0a6035395c7738b0de0dcc">More...</a><br /></td></tr>
<tr class="separator:gadbe05205dc0a6035395c7738b0de0dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6198ae1a865423d022a52b60f0589640"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga6198ae1a865423d022a52b60f0589640">Cy_SCB_UART_GetOverSample</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga6198ae1a865423d022a52b60f0589640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of oversample.  <a href="#ga6198ae1a865423d022a52b60f0589640">More...</a><br /></td></tr>
<tr class="separator:ga6198ae1a865423d022a52b60f0589640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953a2e5de2843bec5149214fbbf8d866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__scb__uart__enums.html#gac72413306ca26b7b8174526e3fc539df">cy_en_scb_uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga953a2e5de2843bec5149214fbbf8d866">Cy_SCB_UART_SetOverSample</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t overSample, <a class="el" href="structcy__stc__scb__uart__context__t.html">cy_stc_scb_uart_context_t</a> *context)</td></tr>
<tr class="memdesc:ga953a2e5de2843bec5149214fbbf8d866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets oversample bits of UART.  <a href="#ga953a2e5de2843bec5149214fbbf8d866">More...</a><br /></td></tr>
<tr class="separator:ga953a2e5de2843bec5149214fbbf8d866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e78bbf1f988c83e4b854913165c522a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga0e78bbf1f988c83e4b854913165c522a">Cy_SCB_UART_GetDataWidth</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga0e78bbf1f988c83e4b854913165c522a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of datawidth.  <a href="#ga0e78bbf1f988c83e4b854913165c522a">More...</a><br /></td></tr>
<tr class="separator:ga0e78bbf1f988c83e4b854913165c522a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0168b95a1eef359b3bd9d656dc58eada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga0168b95a1eef359b3bd9d656dc58eada">Cy_SCB_UART_SetDataWidth</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t dataWidth)</td></tr>
<tr class="memdesc:ga0168b95a1eef359b3bd9d656dc58eada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets datawidth for UART transaction.  <a href="#ga0168b95a1eef359b3bd9d656dc58eada">More...</a><br /></td></tr>
<tr class="separator:ga0168b95a1eef359b3bd9d656dc58eada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefd348e5429248635e3513d38b093ca2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gaefd348e5429248635e3513d38b093ca2">Cy_SCB_UART_GetParity</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gaefd348e5429248635e3513d38b093ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of parity.  <a href="#gaefd348e5429248635e3513d38b093ca2">More...</a><br /></td></tr>
<tr class="separator:gaefd348e5429248635e3513d38b093ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba2318f8135a722f861c61e299cf955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gadba2318f8135a722f861c61e299cf955">Cy_SCB_UART_SetParity</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, <a class="el" href="group__group__scb__uart__enums.html#ga5ee6d587ef3399954d609f17775a3f42">cy_en_scb_uart_parity_t</a> parity)</td></tr>
<tr class="memdesc:gadba2318f8135a722f861c61e299cf955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets parity for UART transaction.  <a href="#gadba2318f8135a722f861c61e299cf955">More...</a><br /></td></tr>
<tr class="separator:gadba2318f8135a722f861c61e299cf955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafd878e3e54925cf1d10ca38f2a89e11"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gaafd878e3e54925cf1d10ca38f2a89e11">Cy_SCB_UART_GetStopBits</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gaafd878e3e54925cf1d10ca38f2a89e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of stop bits.  <a href="#gaafd878e3e54925cf1d10ca38f2a89e11">More...</a><br /></td></tr>
<tr class="separator:gaafd878e3e54925cf1d10ca38f2a89e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a74d57246b3f64b61514d352479fbe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga1a74d57246b3f64b61514d352479fbe4">Cy_SCB_UART_SetStopBits</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, <a class="el" href="group__group__scb__uart__enums.html#ga980f6c273a50db8f6b6fa7f703b1a7f9">cy_en_scb_uart_stop_bits_t</a> stopBits)</td></tr>
<tr class="memdesc:ga1a74d57246b3f64b61514d352479fbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets stop bits for UART transaction.  <a href="#ga1a74d57246b3f64b61514d352479fbe4">More...</a><br /></td></tr>
<tr class="separator:ga1a74d57246b3f64b61514d352479fbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga479378d045a9d97d279ff24667661995"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga479378d045a9d97d279ff24667661995">Cy_SCB_UART_GetDropOnParityError</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga479378d045a9d97d279ff24667661995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of SetDropOnParityError.  <a href="#ga479378d045a9d97d279ff24667661995">More...</a><br /></td></tr>
<tr class="separator:ga479378d045a9d97d279ff24667661995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6796283644936b5501085bdb5981b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#ga7c6796283644936b5501085bdb5981b9">Cy_SCB_UART_SetDropOnParityError</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, bool dropOnParityError)</td></tr>
<tr class="memdesc:ga7c6796283644936b5501085bdb5981b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets SetDropOnParityError for UART transaction.  <a href="#ga7c6796283644936b5501085bdb5981b9">More...</a><br /></td></tr>
<tr class="separator:ga7c6796283644936b5501085bdb5981b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf655f8c8143c4f0f98c3dadf34091ff"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gaaf655f8c8143c4f0f98c3dadf34091ff">Cy_SCB_UART_GetEnableMsbFirst</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gaaf655f8c8143c4f0f98c3dadf34091ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of enableMsbFirst.  <a href="#gaaf655f8c8143c4f0f98c3dadf34091ff">More...</a><br /></td></tr>
<tr class="separator:gaaf655f8c8143c4f0f98c3dadf34091ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5f34c160e5ddccb9bde86b6400e6ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__low__level__functions.html#gaeb5f34c160e5ddccb9bde86b6400e6ca">Cy_SCB_UART_SetEnableMsbFirst</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, bool enableMsbFirst)</td></tr>
<tr class="memdesc:gaeb5f34c160e5ddccb9bde86b6400e6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets enableMsbFirst for UART transaction.  <a href="#gaeb5f34c160e5ddccb9bde86b6400e6ca">More...</a><br /></td></tr>
<tr class="separator:gaeb5f34c160e5ddccb9bde86b6400e6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae8eba8924ed4b8add6e7cabdf25a18fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8eba8924ed4b8add6e7cabdf25a18fe">&#9670;&nbsp;</a></span>Cy_SCB_UART_Put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_Put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a single data element in the UART TX FIFO. </p>
<p>This function does not block and returns how many data elements were placed in the TX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">data</td><td>Data to put in the TX FIFO. The element size is defined by the data type, which depends on the configured data width.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data elements placed in the TX FIFO: 0 or 1. </dd></dl>

</div>
</div>
<a id="ga242ad51b987fa6ccfc23f3471182ce36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242ad51b987fa6ccfc23f3471182ce36">&#9670;&nbsp;</a></span>Cy_SCB_UART_PutArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_PutArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places an array of data in the UART TX FIFO. </p>
<p>This function does not block. It returns how many data elements were placed in the TX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to data to place in the TX FIFO. The element size is defined by the data type, which depends on the configured TX data width.</td></tr>
    <tr><td class="paramname">size</td><td>The number of data elements to TX.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data elements placed in the TX FIFO. </dd></dl>

</div>
</div>
<a id="gac709dbaa61ae25a05086124f1ffaa0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac709dbaa61ae25a05086124f1ffaa0d7">&#9670;&nbsp;</a></span>Cy_SCB_UART_PutArrayBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_UART_PutArrayBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places an array of data in the UART TX FIFO. </p>
<p>This function blocks until the number of data elements specified by the size is placed in the TX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to data to place in the TX FIFO. The element size is defined by the data type, which depends on the configured data width.</td></tr>
    <tr><td class="paramname">size</td><td>The number of data elements to write into the TX FIFO. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4092c34575a47087e08a58529451914b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4092c34575a47087e08a58529451914b">&#9670;&nbsp;</a></span>Cy_SCB_UART_PutString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_UART_PutString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__syslib__macros.html#ga40bb5262bf908c328fbcfbe5d29d0201">char_t</a> const&#160;</td>
          <td class="paramname"><em>string</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a NULL terminated string in the UART TX FIFO. </p>
<p>This function blocks until the entire string is placed in the TX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">string</td><td>The pointer to the null terminated string array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab26a75a58d128e402f3bba6ff2bdad82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab26a75a58d128e402f3bba6ff2bdad82">&#9670;&nbsp;</a></span>Cy_SCB_UART_SendBreakBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_UART_SendBreakBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>breakWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a break condition (logic low) of specified width on UART TX line. </p>
<p>Blocks until break is completed. Only call this function when UART TX FIFO and shifter are empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">breakWidth</td><td>Width of break condition. Valid range is the TX data width (4 to 16 bits)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Before sending break all UART TX interrupt sources are disabled. The state of UART TX interrupt sources is restored before function returns.</dd></dl>
<dl class="section user"><dt>Side Effects</dt><dd>If this function is called while there is data in the TX FIFO or shifter that data will be shifted out in packets the size of breakWidth. </dd></dl>

</div>
</div>
<a id="ga86ab3686a98a0e215c1f2eeed3ce254f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86ab3686a98a0e215c1f2eeed3ce254f">&#9670;&nbsp;</a></span>Cy_SCB_UART_Get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a single data element from the UART RX FIFO. </p>
<p>This function does not check whether the RX FIFO has data before reading it. If the RX FIFO is empty, the function returns <a class="el" href="group__group__scb__uart__macros.html#ga0a069371072be8673bc18bdb3523146e">CY_SCB_UART_RX_NO_DATA</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data from the RX FIFO. The data element size is defined by the configured data width. </dd></dl>

</div>
</div>
<a id="ga509c3f8c4acd406d4253019d28a0eb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga509c3f8c4acd406d4253019d28a0eb3a">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_GetArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of data out of the UART RX FIFO. </p>
<p>This function does not block. It returns how many data elements were read from the RX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to the location to place the data read from the RX FIFO. The element size is defined by the data type, which depends on the configured data width.</td></tr>
    <tr><td class="paramname">size</td><td>The number of data elements to read from the RX FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data elements read from the RX FIFO. </dd></dl>

</div>
</div>
<a id="ga7d45f3f8f625e2f16341a03a4078698e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d45f3f8f625e2f16341a03a4078698e">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetArrayBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_UART_GetArrayBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of data out of the UART RX FIFO. </p>
<p>This function blocks until the number of data elements specified by the size has been read from the RX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to the location to place the data read from the RX FIFO. The element size is defined by the data type, which depends on the configured data width.</td></tr>
    <tr><td class="paramname">size</td><td>The number of data elements to read from the RX FIFO. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76218bc016256d8525c9d779a4c2e9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76218bc016256d8525c9d779a4c2e9aa">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetTxFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_GetTxFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current status of the TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__uart__macros__tx__fifo__status.html">UART TX FIFO Statuses</a> </dd></dl>

</div>
</div>
<a id="gabd4607b147b35fbd9c47e89f77aa1f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd4607b147b35fbd9c47e89f77aa1f89">&#9670;&nbsp;</a></span>Cy_SCB_UART_ClearTxFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_UART_ClearTxFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the selected statuses of the TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">clearMask</td><td>The mask whose statuses to clear. See <a class="el" href="group__group__scb__uart__macros__tx__fifo__status.html">UART TX FIFO Statuses</a> for the set of constants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The status is also used for interrupt generation, so clearing it also clears the interrupt sources.</li>
<li>Level-sensitive statuses such as <a class="el" href="group__group__scb__uart__macros__tx__fifo__status.html#ga084f44adc0f1fba7bc8cc63f46c8a3e6">CY_SCB_UART_TX_TRIGGER</a>, <a class="el" href="group__group__scb__uart__macros__tx__fifo__status.html#gafb9a349f995e46583edd9cdc16efc0af">CY_SCB_UART_TX_EMPTY</a> and <a class="el" href="group__group__scb__uart__macros__tx__fifo__status.html#ga41c603d23a12693b3b83ece75da39b54">CY_SCB_UART_TX_NOT_FULL</a> are set high again after being cleared if the condition remains true. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa2d783e45d8b8a9803bb5b667d71f3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2d783e45d8b8a9803bb5b667d71f3b9">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetRxFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_GetRxFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current status of the RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__uart__macros__rx__fifo__status.html">UART RX FIFO status.</a> </dd></dl>

</div>
</div>
<a id="ga3f1e6aa6e686a215ab03b5d264510b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f1e6aa6e686a215ab03b5d264510b3f">&#9670;&nbsp;</a></span>Cy_SCB_UART_ClearRxFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_UART_ClearRxFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the selected statuses of the RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">clearMask</td><td>The mask whose statuses to clear. See <a class="el" href="group__group__scb__uart__macros__rx__fifo__status.html">UART RX FIFO status.</a> for the set of constants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This status is also used for interrupt generation, so clearing it also clears the interrupt sources.</li>
<li>Level-sensitive statuses such as <a class="el" href="group__group__scb__uart__macros__rx__fifo__status.html#ga2c2ad72882685c29a4755ead9e5bcda9">CY_SCB_UART_RX_TRIGGER</a>, <a class="el" href="group__group__scb__uart__macros__rx__fifo__status.html#gae22bfd5f13fbb141ec2f139c178a6cfd">CY_SCB_UART_RX_NOT_EMPTY</a> and <a class="el" href="group__group__scb__uart__macros__rx__fifo__status.html#gaabd8566f82db4ca907b902c33d8610b0">CY_SCB_UART_RX_FULL</a> are set high again after being cleared if the condition remains true. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0f264dad00ca5fcdf668f20e35e4fcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f264dad00ca5fcdf668f20e35e4fcab">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetNumInTxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_GetNumInTxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of data elements in the UART TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data elements in the TX FIFO. The size of date element defined by the configured data width.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This number does not include any data currently in the TX shifter. </dd></dl>

</div>
</div>
<a id="ga81aff78dcdc266d6cac81e714afef6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81aff78dcdc266d6cac81e714afef6c3">&#9670;&nbsp;</a></span>Cy_SCB_UART_IsTxComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_SCB_UART_IsTxComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the TX FIFO and Shifter are empty and there is no more data to send. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If true, transmission complete. If false, transmission is not complete. </dd></dl>

</div>
</div>
<a id="gabc4b66b875dbc70d52adf19170d3a530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc4b66b875dbc70d52adf19170d3a530">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetNumInRxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_GetNumInRxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of data elements in the UART RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data elements in the RX FIFO. The size of date element defined by the configured data width. </dd></dl>

</div>
</div>
<a id="ga87d8e77bc0b4932906b9769ccfaff4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87d8e77bc0b4932906b9769ccfaff4de">&#9670;&nbsp;</a></span>Cy_SCB_UART_ClearRxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_UART_ClearRxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all data out of the UART RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Side Effects</dt><dd>Any data currently in the shifter is cleared and lost. </dd></dl>

</div>
</div>
<a id="gadbe05205dc0a6035395c7738b0de0dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbe05205dc0a6035395c7738b0de0dcc">&#9670;&nbsp;</a></span>Cy_SCB_UART_ClearTxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_UART_ClearTxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all data out of the UART TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Side Effects</dt><dd>The TX FIFO clear operation also clears the shift register, so that the shifter could be cleared in the middle of a data element transfer, corrupting it. The data element corruption means that all bits that have not been transmitted are transmitted as 1s on the bus. </dd></dl>

</div>
</div>
<a id="ga6198ae1a865423d022a52b60f0589640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6198ae1a865423d022a52b60f0589640">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetOverSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_GetOverSample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of oversample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of oversample.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Get current oversample value for provided SCB */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#ga6198ae1a865423d022a52b60f0589640">Cy_SCB_UART_GetOverSample</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="ga953a2e5de2843bec5149214fbbf8d866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga953a2e5de2843bec5149214fbbf8d866">&#9670;&nbsp;</a></span>Cy_SCB_UART_SetOverSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__scb__uart__enums.html#gac72413306ca26b7b8174526e3fc539df">cy_en_scb_uart_status_t</a> Cy_SCB_UART_SetOverSample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>overSample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__uart__context__t.html">cy_stc_scb_uart_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets oversample bits of UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">overSample</td><td>Value of oversample to be set.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__uart__context__t.html">cy_stc_scb_uart_context_t</a> allocated by the user. The structure is used during the UART operation for internal configuration and data retention. The user must not modify anything in this structure. User should not pass NULL as pointer to context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__uart__enums.html#gac72413306ca26b7b8174526e3fc539df">cy_en_scb_uart_status_t</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Ensure that the SCB block is disabled before calling this function.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Assign appropriate oversample value for UART */</span></div><div class="line">    uint32_t OverSample = 8UL;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Set oversample value for UART */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#ga953a2e5de2843bec5149214fbbf8d866">Cy_SCB_UART_SetOverSample</a>(SCB5, OverSample, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable UART to operate */</span></div><div class="line">    <a class="code" href="group__group__scb__uart__general__functions.html#ga503d0737dadf35620306ef3571d84905">Cy_SCB_UART_Enable</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="ga0e78bbf1f988c83e4b854913165c522a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e78bbf1f988c83e4b854913165c522a">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetDataWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_GetDataWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of datawidth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of datawidth.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Values of Tx and Rx datawidth are same.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Get current datawidth value for provided SCB */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#ga0e78bbf1f988c83e4b854913165c522a">Cy_SCB_UART_GetDataWidth</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="ga0168b95a1eef359b3bd9d656dc58eada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0168b95a1eef359b3bd9d656dc58eada">&#9670;&nbsp;</a></span>Cy_SCB_UART_SetDataWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_UART_SetDataWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets datawidth for UART transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">dataWidth</td><td>The width of UART data in the UART transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Ensure that the SCB block is disabled before calling this function.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Assign appropriate datawidth value for UART */</span></div><div class="line">    uint32_t dataWidth = 8UL;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Set datawidth value for UART */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#ga0168b95a1eef359b3bd9d656dc58eada">Cy_SCB_UART_SetDataWidth</a>(SCB5, dataWidth);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable UART to operate */</span></div><div class="line">    <a class="code" href="group__group__scb__uart__general__functions.html#ga503d0737dadf35620306ef3571d84905">Cy_SCB_UART_Enable</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="gaefd348e5429248635e3513d38b093ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefd348e5429248635e3513d38b093ca2">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetParity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_GetParity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of parity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of parity.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Values of Tx and Rx parity are same.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Get current parity value for provided SCB */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#gaefd348e5429248635e3513d38b093ca2">Cy_SCB_UART_GetParity</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="gadba2318f8135a722f861c61e299cf955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadba2318f8135a722f861c61e299cf955">&#9670;&nbsp;</a></span>Cy_SCB_UART_SetParity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_UART_SetParity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__scb__uart__enums.html#ga5ee6d587ef3399954d609f17775a3f42">cy_en_scb_uart_parity_t</a>&#160;</td>
          <td class="paramname"><em>parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets parity for UART transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">parity</td><td>The UART parity bit in the UART transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Ensure that the SCB block is disabled before calling this function.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Assign appropriate parity value for UART */</span></div><div class="line">    <a class="code" href="group__group__scb__uart__enums.html#ga5ee6d587ef3399954d609f17775a3f42">cy_en_scb_uart_parity_t</a> parity = <a class="code" href="group__group__scb__uart__enums.html#gga5ee6d587ef3399954d609f17775a3f42a4684fcd6cd3d48bf9372f5947af95f0d">CY_SCB_UART_PARITY_NONE</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Set parity value for UART */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#gadba2318f8135a722f861c61e299cf955">Cy_SCB_UART_SetParity</a>(SCB5, parity);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable UART to operate */</span></div><div class="line">    <a class="code" href="group__group__scb__uart__general__functions.html#ga503d0737dadf35620306ef3571d84905">Cy_SCB_UART_Enable</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="gaafd878e3e54925cf1d10ca38f2a89e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafd878e3e54925cf1d10ca38f2a89e11">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetStopBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_UART_GetStopBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of stop bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of stop bits.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Values of Tx and Rx stop bits are same.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Get current stop bits value for provided SCB */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#gaafd878e3e54925cf1d10ca38f2a89e11">Cy_SCB_UART_GetStopBits</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="ga1a74d57246b3f64b61514d352479fbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a74d57246b3f64b61514d352479fbe4">&#9670;&nbsp;</a></span>Cy_SCB_UART_SetStopBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_UART_SetStopBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__scb__uart__enums.html#ga980f6c273a50db8f6b6fa7f703b1a7f9">cy_en_scb_uart_stop_bits_t</a>&#160;</td>
          <td class="paramname"><em>stopBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets stop bits for UART transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">stopBits</td><td>The number of stop bits in the UART transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Ensure that the SCB block is disabled before calling this function.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Assign appropriate stop bits value for UART */</span></div><div class="line">    <a class="code" href="group__group__scb__uart__enums.html#ga980f6c273a50db8f6b6fa7f703b1a7f9">cy_en_scb_uart_stop_bits_t</a> stopBits = <a class="code" href="group__group__scb__uart__enums.html#gga980f6c273a50db8f6b6fa7f703b1a7f9ac35384addc6b2590f3ec209ae4541394">CY_SCB_UART_STOP_BITS_1</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Set stop bits value for UART */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#ga1a74d57246b3f64b61514d352479fbe4">Cy_SCB_UART_SetStopBits</a>(SCB5, stopBits);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable UART to operate */</span></div><div class="line">    <a class="code" href="group__group__scb__uart__general__functions.html#ga503d0737dadf35620306ef3571d84905">Cy_SCB_UART_Enable</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="ga479378d045a9d97d279ff24667661995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga479378d045a9d97d279ff24667661995">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetDropOnParityError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_SCB_UART_GetDropOnParityError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of SetDropOnParityError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of SetDropOnParityError.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Get current SetDropOnParityError value for provided SCB */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#ga479378d045a9d97d279ff24667661995">Cy_SCB_UART_GetDropOnParityError</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="ga7c6796283644936b5501085bdb5981b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c6796283644936b5501085bdb5981b9">&#9670;&nbsp;</a></span>Cy_SCB_UART_SetDropOnParityError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_UART_SetDropOnParityError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dropOnParityError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets SetDropOnParityError for UART transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">dropOnParityError</td><td>To enable the hardware to drop data in the RX FIFO when a parity error is detected in the UART transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Ensure that the SCB block is disabled before calling this function.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Assign appropriate SetDropOnParityError value for UART */</span></div><div class="line">    <span class="keywordtype">bool</span> setDropOnParityError = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Set SetDropOnParityError value for UART */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#ga7c6796283644936b5501085bdb5981b9">Cy_SCB_UART_SetDropOnParityError</a>(SCB5, setDropOnParityError);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable UART to operate */</span></div><div class="line">    <a class="code" href="group__group__scb__uart__general__functions.html#ga503d0737dadf35620306ef3571d84905">Cy_SCB_UART_Enable</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="gaaf655f8c8143c4f0f98c3dadf34091ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf655f8c8143c4f0f98c3dadf34091ff">&#9670;&nbsp;</a></span>Cy_SCB_UART_GetEnableMsbFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_SCB_UART_GetEnableMsbFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of enableMsbFirst. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of enableMsbFirst.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Values of Tx and Rx enableMsbFirst are same.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Get current enableMsbFirst value for provided SCB */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#gaaf655f8c8143c4f0f98c3dadf34091ff">Cy_SCB_UART_GetEnableMsbFirst</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
<a id="gaeb5f34c160e5ddccb9bde86b6400e6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb5f34c160e5ddccb9bde86b6400e6ca">&#9670;&nbsp;</a></span>Cy_SCB_UART_SetEnableMsbFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_UART_SetEnableMsbFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableMsbFirst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets enableMsbFirst for UART transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the UART SCB instance.</td></tr>
    <tr><td class="paramname">enableMsbFirst</td><td>Enables the hardware to shift out data element MSB first; otherwise, LSB first in the UART transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Ensure that the SCB block is disabled before calling this function.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Assign appropriate enableMsbFirst value for UART */</span></div><div class="line">    <span class="keywordtype">bool</span> enableMsbFirst = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize SCB for UART operation */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;UART_1_config, &amp;UART_1_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Set enableMsbFirst value for UART */</span></div><div class="line">    (void) <a class="code" href="group__group__scb__uart__low__level__functions.html#gaeb5f34c160e5ddccb9bde86b6400e6ca">Cy_SCB_UART_SetEnableMsbFirst</a>(SCB5, enableMsbFirst);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable UART to operate */</span></div><div class="line">    <a class="code" href="group__group__scb__uart__general__functions.html#ga503d0737dadf35620306ef3571d84905">Cy_SCB_UART_Enable</a>(SCB5);</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
