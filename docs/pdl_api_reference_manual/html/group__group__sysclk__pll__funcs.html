<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__sysclk__pll__funcs.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__sysclk.html">SysClk       (System Clock)</a> &raquo; <a class="el" href="group__group__sysclk__pll.html">Phase Locked Loop (PLL)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac5c498137bf7012e8e0f8b8e0dfba1f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gac5c498137bf7012e8e0f8b8e0dfba1f0">Cy_SysClk_PllConfigure</a> (uint32_t clkPath, const <a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> *config)</td></tr>
<tr class="memdesc:gac5c498137bf7012e8e0f8b8e0dfba1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures a given PLL.  <a href="#gac5c498137bf7012e8e0f8b8e0dfba1f0">More...</a><br /></td></tr>
<tr class="separator:gac5c498137bf7012e8e0f8b8e0dfba1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21ad8110bfc4506947fbd0fb163d055"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gad21ad8110bfc4506947fbd0fb163d055">Cy_SysClk_PllManualConfigure</a> (uint32_t clkPath, const <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *config)</td></tr>
<tr class="memdesc:gad21ad8110bfc4506947fbd0fb163d055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually configures a PLL based on user inputs.  <a href="#gad21ad8110bfc4506947fbd0fb163d055">More...</a><br /></td></tr>
<tr class="separator:gad21ad8110bfc4506947fbd0fb163d055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fc66dcae940c37c26bc7d8b840f83b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga1fc66dcae940c37c26bc7d8b840f83b0">Cy_SysClk_PllGetConfiguration</a> (uint32_t clkPath, <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *config)</td></tr>
<tr class="memdesc:ga1fc66dcae940c37c26bc7d8b840f83b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports configuration settings for a PLL.  <a href="#ga1fc66dcae940c37c26bc7d8b840f83b0">More...</a><br /></td></tr>
<tr class="separator:ga1fc66dcae940c37c26bc7d8b840f83b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5396ed00cc7ddeeb924bf00ee08311e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> (uint32_t clkPath, uint32_t timeoutus)</td></tr>
<tr class="memdesc:ga5396ed00cc7ddeeb924bf00ee08311e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the PLL.  <a href="#ga5396ed00cc7ddeeb924bf00ee08311e5">More...</a><br /></td></tr>
<tr class="separator:ga5396ed00cc7ddeeb924bf00ee08311e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ee5e192525df92ea07b32a3eb3d295"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gae3ee5e192525df92ea07b32a3eb3d295">Cy_SysClk_PllIsEnabled</a> (uint32_t clkPath)</td></tr>
<tr class="memdesc:gae3ee5e192525df92ea07b32a3eb3d295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected PLL is enabled.  <a href="#gae3ee5e192525df92ea07b32a3eb3d295">More...</a><br /></td></tr>
<tr class="separator:gae3ee5e192525df92ea07b32a3eb3d295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be60f83c0ecbcaa5dcb6f41c93d6958"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga4be60f83c0ecbcaa5dcb6f41c93d6958">Cy_SysClk_PllLocked</a> (uint32_t clkPath)</td></tr>
<tr class="memdesc:ga4be60f83c0ecbcaa5dcb6f41c93d6958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected PLL is locked.  <a href="#ga4be60f83c0ecbcaa5dcb6f41c93d6958">More...</a><br /></td></tr>
<tr class="separator:ga4be60f83c0ecbcaa5dcb6f41c93d6958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab852ca09112d6bd07259c795c23f9efb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gab852ca09112d6bd07259c795c23f9efb">Cy_SysClk_PllLostLock</a> (uint32_t clkPath)</td></tr>
<tr class="memdesc:gab852ca09112d6bd07259c795c23f9efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected PLL lost its lock since the last time this function was called.  <a href="#gab852ca09112d6bd07259c795c23f9efb">More...</a><br /></td></tr>
<tr class="separator:gab852ca09112d6bd07259c795c23f9efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dab90271e8887833424c8fc280a1f30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga0dab90271e8887833424c8fc280a1f30">Cy_SysClk_PllDisable</a> (uint32_t clkPath)</td></tr>
<tr class="memdesc:ga0dab90271e8887833424c8fc280a1f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the selected PLL.  <a href="#ga0dab90271e8887833424c8fc280a1f30">More...</a><br /></td></tr>
<tr class="separator:ga0dab90271e8887833424c8fc280a1f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219fd6d8d1d18090fe6d7002610ac021"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga219fd6d8d1d18090fe6d7002610ac021">Cy_SysClk_PllGetFrequency</a> (uint32_t clkPath)</td></tr>
<tr class="memdesc:ga219fd6d8d1d18090fe6d7002610ac021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output frequency of the PLL.  <a href="#ga219fd6d8d1d18090fe6d7002610ac021">More...</a><br /></td></tr>
<tr class="separator:ga219fd6d8d1d18090fe6d7002610ac021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e748343551cd15bfca189250e0af1c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga9e748343551cd15bfca189250e0af1c4">Cy_SysClk_Pll200MConfigure</a> (uint32_t pllNum, const <a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> *config)</td></tr>
<tr class="memdesc:ga9e748343551cd15bfca189250e0af1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures 200M PLL.  <a href="#ga9e748343551cd15bfca189250e0af1c4">More...</a><br /></td></tr>
<tr class="separator:ga9e748343551cd15bfca189250e0af1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa6456259e31b786c7e161435b7dd450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gaaa6456259e31b786c7e161435b7dd450">Cy_SysClk_Pll200MManualConfigure</a> (uint32_t pllNum, const <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *config)</td></tr>
<tr class="memdesc:gaaa6456259e31b786c7e161435b7dd450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually configures a 200M PLL based on user inputs.  <a href="#gaaa6456259e31b786c7e161435b7dd450">More...</a><br /></td></tr>
<tr class="separator:gaaa6456259e31b786c7e161435b7dd450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga030e569b07a163e58e84928773b9ad25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga030e569b07a163e58e84928773b9ad25">Cy_SysClk_Pll200MGetConfiguration</a> (uint32_t pllNum, <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *config)</td></tr>
<tr class="memdesc:ga030e569b07a163e58e84928773b9ad25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports configuration settings for 200M PLL.  <a href="#ga030e569b07a163e58e84928773b9ad25">More...</a><br /></td></tr>
<tr class="separator:ga030e569b07a163e58e84928773b9ad25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa755ea5198f4eebc6b7e7991bfe30c6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gaa755ea5198f4eebc6b7e7991bfe30c6e">Cy_SysClk_Pll200MEnable</a> (uint32_t pllNum, uint32_t timeoutus)</td></tr>
<tr class="memdesc:gaa755ea5198f4eebc6b7e7991bfe30c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the 200M PLL.  <a href="#gaa755ea5198f4eebc6b7e7991bfe30c6e">More...</a><br /></td></tr>
<tr class="separator:gaa755ea5198f4eebc6b7e7991bfe30c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga850229a9ff0d4af9d0f298f377ce5ba0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga850229a9ff0d4af9d0f298f377ce5ba0">Cy_SysClk_Pll200MIsEnabled</a> (uint32_t pllNum)</td></tr>
<tr class="memdesc:ga850229a9ff0d4af9d0f298f377ce5ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected 200M PLL is enabled.  <a href="#ga850229a9ff0d4af9d0f298f377ce5ba0">More...</a><br /></td></tr>
<tr class="separator:ga850229a9ff0d4af9d0f298f377ce5ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae48c98d74bbb34e049d2e8c17100685"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gaae48c98d74bbb34e049d2e8c17100685">Cy_SysClk_Pll200MLocked</a> (uint32_t pllNum)</td></tr>
<tr class="memdesc:gaae48c98d74bbb34e049d2e8c17100685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected 200M PLL is locked.  <a href="#gaae48c98d74bbb34e049d2e8c17100685">More...</a><br /></td></tr>
<tr class="separator:gaae48c98d74bbb34e049d2e8c17100685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40696a5667ca242332fb3de42b1b2994"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga40696a5667ca242332fb3de42b1b2994">Cy_SysClk_Pll200MLostLock</a> (uint32_t pllNum)</td></tr>
<tr class="memdesc:ga40696a5667ca242332fb3de42b1b2994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected 200M PLL lost its lock since the last time this function was called.  <a href="#ga40696a5667ca242332fb3de42b1b2994">More...</a><br /></td></tr>
<tr class="separator:ga40696a5667ca242332fb3de42b1b2994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b42389042d11aaa84bd2e769f6b7b27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga8b42389042d11aaa84bd2e769f6b7b27">Cy_SysClk_Pll200MDisable</a> (uint32_t pllNum)</td></tr>
<tr class="memdesc:ga8b42389042d11aaa84bd2e769f6b7b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the selected 200M PLL.  <a href="#ga8b42389042d11aaa84bd2e769f6b7b27">More...</a><br /></td></tr>
<tr class="separator:ga8b42389042d11aaa84bd2e769f6b7b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf2396edece2bf47abd72603fc791e5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gabdf2396edece2bf47abd72603fc791e5">Cy_SysClk_Pll200MGetFrequency</a> (uint32_t pllNum)</td></tr>
<tr class="memdesc:gabdf2396edece2bf47abd72603fc791e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the frequency of PLL200M.  <a href="#gabdf2396edece2bf47abd72603fc791e5">More...</a><br /></td></tr>
<tr class="separator:gabdf2396edece2bf47abd72603fc791e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad498857f6d3c3b8df8dd176391d07f6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gad498857f6d3c3b8df8dd176391d07f6f">Cy_SysClk_Pll400MConfigure</a> (uint32_t pllNum, const <a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> *config)</td></tr>
<tr class="memdesc:gad498857f6d3c3b8df8dd176391d07f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures 400M PLL.  <a href="#gad498857f6d3c3b8df8dd176391d07f6f">More...</a><br /></td></tr>
<tr class="separator:gad498857f6d3c3b8df8dd176391d07f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga940fd6400c3ea9f37a0b26893ae8b42b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga940fd6400c3ea9f37a0b26893ae8b42b">Cy_SysClk_Pll400MManualConfigure</a> (uint32_t pllNum, const <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *config)</td></tr>
<tr class="memdesc:ga940fd6400c3ea9f37a0b26893ae8b42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually configures a 400M PLL based on user inputs.  <a href="#ga940fd6400c3ea9f37a0b26893ae8b42b">More...</a><br /></td></tr>
<tr class="separator:ga940fd6400c3ea9f37a0b26893ae8b42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d8b724b371f76ba51ed3378691d9df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gad0d8b724b371f76ba51ed3378691d9df">Cy_SysClk_Pll400MGetConfiguration</a> (uint32_t pllNum, <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *config)</td></tr>
<tr class="memdesc:gad0d8b724b371f76ba51ed3378691d9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports configuration settings for 400M PLL.  <a href="#gad0d8b724b371f76ba51ed3378691d9df">More...</a><br /></td></tr>
<tr class="separator:gad0d8b724b371f76ba51ed3378691d9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa92e2b0dd3f211143fd66edf70fcd2ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gaa92e2b0dd3f211143fd66edf70fcd2ae">Cy_SysClk_Pll400MEnable</a> (uint32_t pllNum, uint32_t timeoutus)</td></tr>
<tr class="memdesc:gaa92e2b0dd3f211143fd66edf70fcd2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the 400M PLL.  <a href="#gaa92e2b0dd3f211143fd66edf70fcd2ae">More...</a><br /></td></tr>
<tr class="separator:gaa92e2b0dd3f211143fd66edf70fcd2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156fecfbaecb9d502c74529f910fe24b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga156fecfbaecb9d502c74529f910fe24b">Cy_SysClk_Pll400MIsEnabled</a> (uint32_t pllNum)</td></tr>
<tr class="memdesc:ga156fecfbaecb9d502c74529f910fe24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected 400M PLL is enabled.  <a href="#ga156fecfbaecb9d502c74529f910fe24b">More...</a><br /></td></tr>
<tr class="separator:ga156fecfbaecb9d502c74529f910fe24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5455c05316aa399ef5afacf7648a3cf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga5455c05316aa399ef5afacf7648a3cf1">Cy_SysClk_Pll400MLocked</a> (uint32_t pllNum)</td></tr>
<tr class="memdesc:ga5455c05316aa399ef5afacf7648a3cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected 400M PLL is locked.  <a href="#ga5455c05316aa399ef5afacf7648a3cf1">More...</a><br /></td></tr>
<tr class="separator:ga5455c05316aa399ef5afacf7648a3cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e300a347373de8ab2c7d2ca89b05dee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga8e300a347373de8ab2c7d2ca89b05dee">Cy_SysClk_Pll400MLostLock</a> (uint32_t pllNum)</td></tr>
<tr class="memdesc:ga8e300a347373de8ab2c7d2ca89b05dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected 200M PLL lost its lock since the last time this function was called.  <a href="#ga8e300a347373de8ab2c7d2ca89b05dee">More...</a><br /></td></tr>
<tr class="separator:ga8e300a347373de8ab2c7d2ca89b05dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51760beb96b211722ffa88483b9d3af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga51760beb96b211722ffa88483b9d3af2">Cy_SysClk_Pll400MDisable</a> (uint32_t pllNum)</td></tr>
<tr class="memdesc:ga51760beb96b211722ffa88483b9d3af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the selected 400M PLL.  <a href="#ga51760beb96b211722ffa88483b9d3af2">More...</a><br /></td></tr>
<tr class="separator:ga51760beb96b211722ffa88483b9d3af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e83e55b944bb47222d309ede5569d38"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga1e83e55b944bb47222d309ede5569d38">Cy_SysClk_Pll400MGetFrequency</a> (uint32_t pllNum)</td></tr>
<tr class="memdesc:ga1e83e55b944bb47222d309ede5569d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the frequency of PLL400M.  <a href="#ga1e83e55b944bb47222d309ede5569d38">More...</a><br /></td></tr>
<tr class="separator:ga1e83e55b944bb47222d309ede5569d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac5c498137bf7012e8e0f8b8e0dfba1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5c498137bf7012e8e0f8b8e0dfba1f0">&#9670;&nbsp;</a></span>Cy_SysClk_PllConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_PllConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures a given PLL. </p>
<p>The configuration formula used is: Fout = pll_clk * (P / Q / div_out), where: Fout is the desired output frequency pll_clk is the frequency of the input source P is the feedback divider. Its value is in bitfield FEEDBACK_DIV. Q is the reference divider. Its value is in bitfield REFERENCE_DIV. div_out is the reference divider. Its value is in bitfield OUTPUT_DIV.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to configure. 1 is the first PLL; 0 is invalid.</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully configured <br />
CY_SYSCLK_INVALID_STATE - PLL not configured because it is enabled <br />
CY_SYSCLK_BAD_PARAM - Invalid clock path number, or input or desired output frequency is out of valid range <br />
CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call this function after changing the PLL input frequency, for example if <a class="el" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource()</a> is called.</dd>
<dd>
Do not call this function when the PLL is enabled. If it is called, then this function returns immediately with an error return value and no register updates.</dd>
<dd>
Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is decreasing.</dd>
<dd>
On PSoC 64 devices the configuration on the PRA driver will be reflected after <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> call. Any call to <a class="el" href="group__group__sysclk__pll__funcs.html#ga1fc66dcae940c37c26bc7d8b840f83b0">Cy_SysClk_PllGetConfiguration</a> before calling <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> returns old configuration values.</dd>
<dd>
This API is available for CAT1A, CAT1C and CAT1D devices.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: PLL needs to source HFCLK0, which must operate at 100 MHz.</span></div><div class="line"><span class="comment">                 The IMO sources the PLL at 8MHz. Startup time is not an issue</span></div><div class="line"><span class="comment">                 and manual configuration of the PLL is not needed. */</span></div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> pllConfig =</div><div class="line">    {</div><div class="line">        <span class="comment">/*.inputFreq  =*/</span> 8000000UL,                    <span class="comment">/* PLL input: 8 MHz IMO */</span></div><div class="line">        <span class="comment">/*.outputFreq =*/</span> 100000000UL,                  <span class="comment">/* PLL output: 100 MHz */</span></div><div class="line">        <span class="comment">/*.lfMode     =*/</span> <span class="keyword">true</span>,                         <span class="comment">/* Enable low frequency mode (VCO = 170~200 MHz) */</span></div><div class="line">        <span class="comment">/*.outputMode =*/</span> <a class="code" href="group__group__sysclk__fll__enums.html#gga777e08424e26c9cd8c2602b2114e716bacd71b0d705fcb6d646c7f439e6de3cf0">CY_SYSCLK_FLLPLL_OUTPUT_AUTO</a>  <span class="comment">/* Output 100 MHz when locked. Otherwise 8 MHz */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Set the PLL source (path 1 mux) to be the IMO.</span></div><div class="line"><span class="comment">       Note: Path 0 is not valid for PLL. */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource</a>(1UL, <a class="code" href="group__group__sysclk__path__src__enums.html#gga8ddaf9023a02dee0d1f9a5629d6ccfe6a01c7cbab413a99daa41d2fb7a0340955">CY_SYSCLK_CLKPATH_IN_IMO</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure Path 1 PLL with the settings in pllConfig struct */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#gac5c498137bf7012e8e0f8b8e0dfba1f0">Cy_SysClk_PllConfigure</a>(1UL, &amp;pllConfig))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the Path 1 PLL with 2000 microsecond timeout */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>(1UL, 2000UL))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Set the HFCLK0 source to clock path 1 */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__clk__hf__funcs.html#ga2d39c7e5111f9ba0738f032a98b4593e">Cy_SysClk_ClkHfSetSource</a>(0UL, <a class="code" href="group__group__sysclk__clk__hf__enums.html#ggabac2d6b9124a00860dcd781a922788d6a69197ee41c916c6e61d81dbe9be1825f">CY_SYSCLK_CLKHF_IN_CLKPATH1</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gad21ad8110bfc4506947fbd0fb163d055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad21ad8110bfc4506947fbd0fb163d055">&#9670;&nbsp;</a></span>Cy_SysClk_PllManualConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_PllManualConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually configures a PLL based on user inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to configure. 1 is the first PLL; 0 is invalid.</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully configured <br />
CY_SYSCLK_INVALID_STATE - PLL not configured because it is enabled <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present CY_PRA_STATUS_* - For the PSoC 64 devices there are possible situations when function returns the PRA error status code <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> instead of <a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call this function after changing the PLL input frequency; for example if <a class="el" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource()</a> is called.</dd>
<dd>
Do not call this function when the PLL is enabled. If it is called, then this function returns immediately with an error return value and no register updates.</dd>
<dd>
Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is decreasing.</dd>
<dd>
On PSoC 64 devices the configuration on the PRA driver will be reflected after <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> call. Any call to <a class="el" href="group__group__sysclk__pll__funcs.html#ga1fc66dcae940c37c26bc7d8b840f83b0">Cy_SysClk_PllGetConfiguration</a> before calling <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> returns old configuration values.</dd>
<dd>
This API is available for CAT1A, CAT1C and CAT1D devices.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: PLL needs to source HFCLK0, which must operate at 100 MHz.</span></div><div class="line"><span class="comment">                 The IMO sources the PLL at 8MHz. The characteristics of the</span></div><div class="line"><span class="comment">                 PLL lock parameters are already known and the startup time</span></div><div class="line"><span class="comment">                 for the PLL configuration must be minimized. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Refer to the TRM for the full set of equations used to calculate the parameters */</span></div><div class="line">    <a class="code" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> pllConfig =</div><div class="line">    {</div><div class="line">        <span class="comment">/*.feedbackDiv  =*/</span> 25u,                            <span class="comment">/* Feedback divider */</span></div><div class="line">        <span class="comment">/*.referenceDiv =*/</span> 1u,                             <span class="comment">/* Reference divider */</span></div><div class="line">        <span class="comment">/*.outputDiv    =*/</span> 2u,                             <span class="comment">/* Output divider */</span></div><div class="line">        <span class="comment">/*.lfMode       =*/</span> <span class="keyword">true</span>,                           <span class="comment">/* Enable low frequency mode (VCO = 170~200 MHz) */</span></div><div class="line">        <span class="comment">/*.outputMode   =*/</span> CY_SYSCLK_FLLPLL_OUTPUT_AUTO    <span class="comment">/* Output 100 MHz when locked. Otherwise 8 MHz */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Set the PLL source (path 1 mux) to be the IMO.</span></div><div class="line"><span class="comment">       Note: Path 0 is not valid for PLL. */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource</a>(1UL, <a class="code" href="group__group__sysclk__path__src__enums.html#gga8ddaf9023a02dee0d1f9a5629d6ccfe6a01c7cbab413a99daa41d2fb7a0340955">CY_SYSCLK_CLKPATH_IN_IMO</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure Path 1 PLL with the settings in pllConfig struct */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#gad21ad8110bfc4506947fbd0fb163d055">Cy_SysClk_PllManualConfigure</a>(1UL, &amp;pllConfig))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the path 1 PLL with 2000 microsecond timeout */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>(1UL, 2000UL))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Set the HFCLK0 source to clock path 1 */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__clk__hf__funcs.html#ga2d39c7e5111f9ba0738f032a98b4593e">Cy_SysClk_ClkHfSetSource</a>(0UL, <a class="code" href="group__group__sysclk__clk__hf__enums.html#ggabac2d6b9124a00860dcd781a922788d6a69197ee41c916c6e61d81dbe9be1825f">CY_SYSCLK_CLKHF_IN_CLKPATH1</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga1fc66dcae940c37c26bc7d8b840f83b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fc66dcae940c37c26bc7d8b840f83b0">&#9670;&nbsp;</a></span>Cy_SysClk_PllGetConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_PllGetConfiguration </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports configuration settings for a PLL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to report. 1 is the first PLL; 0 is invalid.</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL data successfully reported <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present CY_PRA_STATUS_* - For the PSoC 64 devices there are possible situations when function returns the PRA error status code <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> instead of <a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On PSoC 64 devices the configuration on the PRA driver will be reflected after <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> call. Any call to <a class="el" href="group__group__sysclk__pll__funcs.html#ga1fc66dcae940c37c26bc7d8b840f83b0">Cy_SysClk_PllGetConfiguration</a> before calling <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> returns old configuration values.</dd>
<dd>
This API is available for CAT1A, CAT1C and CAT1D devices.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: The calculated PLL parameters need to be checked. */</span></div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> autoPllConfig =</div><div class="line">    {</div><div class="line">        <span class="comment">/*.inputFreq  =*/</span> 8000000UL,                    <span class="comment">/* PLL input: 8 MHz IMO */</span></div><div class="line">        <span class="comment">/*.outputFreq =*/</span> 100000000UL,                  <span class="comment">/* PLL output: 100 MHz */</span></div><div class="line">        <span class="comment">/*.lfMode     =*/</span> <span class="keyword">true</span>,                         <span class="comment">/* Enable low frequency mode (VCO = 170~200 MHz) */</span></div><div class="line">        <span class="comment">/*.outputMode =*/</span> CY_SYSCLK_FLLPLL_OUTPUT_AUTO  <span class="comment">/* Output 100 MHz when locked. Otherwise 8 MHz */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> getPllParams;</div><div class="line"></div><div class="line">    <span class="comment">/* Configure Path 1 PLL with the settings in pllConfig struct */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#gac5c498137bf7012e8e0f8b8e0dfba1f0">Cy_SysClk_PllConfigure</a>(1UL, &amp;autoPllConfig))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Retrieve the calculated parameters of Path 1 PLL */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__pll__funcs.html#ga1fc66dcae940c37c26bc7d8b840f83b0">Cy_SysClk_PllGetConfiguration</a>(1UL, &amp;getPllParams);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga5396ed00cc7ddeeb924bf00ee08311e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5396ed00cc7ddeeb924bf00ee08311e5">&#9670;&nbsp;</a></span>Cy_SysClk_PllEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_PllEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeoutus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the PLL. </p>
<p>The PLL should be configured before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to enable. 1 is the first PLL; 0 is invalid.</td></tr>
    <tr><td class="paramname">timeoutus</td><td>amount of time in microseconds to wait for the PLL to lock. If the lock doesn't occur, PLL is stopped. To avoid waiting for lock, set this to 0 and manually check for lock using <a class="el" href="group__group__sysclk__pll__funcs.html#ga4be60f83c0ecbcaa5dcb6f41c93d6958">Cy_SysClk_PllLocked</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully enabled <br />
CY_SYSCLK_TIMEOUT - Timeout waiting for PLL lock <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present CY_PRA_STATUS_* - For the PSoC 64 devices there are possible situations when function returns the PRA error status code <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> instead of <a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is decreasing.</dd>
<dd>
This API is available for CAT1A, CAT1C and CAT1D devices.</dd>
<dd>
Take into account the possible platform specific clkHf (and further clocking chain links) frequency limitations while using this API.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: PLL is configured and needs to be enabled within 2 ms */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enable the Path 1 PLL with a timeout of 2000 microsecond */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>(1UL, 2000UL))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gae3ee5e192525df92ea07b32a3eb3d295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ee5e192525df92ea07b32a3eb3d295">&#9670;&nbsp;</a></span>Cy_SysClk_PllIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_SysClk_PllIsEnabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected PLL is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to check. 1 is the first PLL; 0 is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = disabled <br />
true = enabled</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1A, CAT1C and CAT1D devices.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Path 1 PLL failed to enable and must be reconfigured. Or the</span></div><div class="line"><span class="comment">                 PLL is no longer used and hence needs to be disabled. */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__pll__funcs.html#gae3ee5e192525df92ea07b32a3eb3d295">Cy_SysClk_PllIsEnabled</a>(1UL))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#ga0dab90271e8887833424c8fc280a1f30">Cy_SysClk_PllDisable</a>(1UL))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Insert error handling */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* The clocks that relied on the PLL will now run off of the clock that</span></div><div class="line"><span class="comment">       was used to source the FLL (e.g. IMO or ECO). */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga4be60f83c0ecbcaa5dcb6f41c93d6958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4be60f83c0ecbcaa5dcb6f41c93d6958">&#9670;&nbsp;</a></span>Cy_SysClk_PllLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_SysClk_PllLocked </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected PLL is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to check. 1 is the first PLL; 0 is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = not locked <br />
true = locked</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1A, CAT1C and CAT1D devices.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: PLL is configured and needs to be enabled in a non-blocking way */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enable the Path 1 PLL without timeout */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>(1UL, 0UL);</div><div class="line"></div><div class="line">    <span class="comment">/* Check the status of the lock */</span></div><div class="line">    <span class="keywordflow">while</span>(<a class="code" href="group__group__sysclk__pll__funcs.html#ga4be60f83c0ecbcaa5dcb6f41c93d6958">Cy_SysClk_PllLocked</a>(1UL))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Perform other actions while the PLL is locking */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* PLL Locked. Proceed with further configuration */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gab852ca09112d6bd07259c795c23f9efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab852ca09112d6bd07259c795c23f9efb">&#9670;&nbsp;</a></span>Cy_SysClk_PllLostLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_SysClk_PllLostLock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected PLL lost its lock since the last time this function was called. </p>
<p>Clears the lost lock indicator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to check. 1 is the first PLL; 0 is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = did not lose lock <br />
true = lost lock</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1A, CAT1C and CAT1D devices.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Suspicious change in Path 1 clock frequency was encountered</span></div><div class="line"><span class="comment">                 in the application. Check if the Path 1 PLL lost the lock. */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__sysclk__pll__funcs.html#gab852ca09112d6bd07259c795c23f9efb">Cy_SysClk_PllLostLock</a>(1UL))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga0dab90271e8887833424c8fc280a1f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dab90271e8887833424c8fc280a1f30">&#9670;&nbsp;</a></span>Cy_SysClk_PllDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_PllDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the selected PLL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to disable. 1 is the first PLL; 0 is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully disabled <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present CY_PRA_STATUS_* - For the PSoC 64 devices there are possible situations when function returns the PRA error status code <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> instead of <a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is decreasing.</dd></dl>
<dl class="section user"><dt>Side Effects</dt><dd>This function sets PLL bypass mode to CY_SYSCLK_FLLPLL_OUTPUT_INPUT. If AUTO mode should be used, call <a class="el" href="group__group__sysclk__pll__funcs.html#gac5c498137bf7012e8e0f8b8e0dfba1f0">Cy_SysClk_PllConfigure</a> or <a class="el" href="group__group__sysclk__pll__funcs.html#gad21ad8110bfc4506947fbd0fb163d055">Cy_SysClk_PllManualConfigure</a> before calling <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1A, CAT1C and CAT1D devices.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Path 1 PLL failed to enable and must be reconfigured. Or the</span></div><div class="line"><span class="comment">                 PLL is no longer used and hence needs to be disabled. */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__pll__funcs.html#gae3ee5e192525df92ea07b32a3eb3d295">Cy_SysClk_PllIsEnabled</a>(1UL))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#ga0dab90271e8887833424c8fc280a1f30">Cy_SysClk_PllDisable</a>(1UL))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Insert error handling */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* The clocks that relied on the PLL will now run off of the clock that</span></div><div class="line"><span class="comment">       was used to source the FLL (e.g. IMO or ECO). */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga219fd6d8d1d18090fe6d7002610ac021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga219fd6d8d1d18090fe6d7002610ac021">&#9670;&nbsp;</a></span>Cy_SysClk_PllGetFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SysClk_PllGetFrequency </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output frequency of the PLL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to check. 1 is the first PLL; 0 is invalid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output frequency of the path PLL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the return value equals zero, that means PLL is disabled.</dd>
<dd>
This API is available for CAT1A, CAT1C and CAT1D devices.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    uint32_t freq = <a class="code" href="group__group__sysclk__pll__funcs.html#ga219fd6d8d1d18090fe6d7002610ac021">Cy_SysClk_PllGetFrequency</a>(1UL);</div><div class="line">    (void) freq; <span class="comment">/* Suppress &#39;unused variable&#39; warning */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga9e748343551cd15bfca189250e0af1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e748343551cd15bfca189250e0af1c4">&#9670;&nbsp;</a></span>Cy_SysClk_Pll200MConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_Pll200MConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures 200M PLL. </p>
<p>The configuration formula used is: Fout = pll_clk * (P / Q / div_out), where: Fout is the desired output frequency pll_clk is the frequency of the input source P is the feedback divider. Its value is in bitfield FEEDBACK_DIV. Q is the reference divider. Its value is in bitfield REFERENCE_DIV. div_out is the reference divider. Its value is in bitfield OUTPUT_DIV.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to configure</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully configured <br />
CY_SYSCLK_INVALID_STATE - PLL not configured because it is enabled <br />
CY_SYSCLK_BAD_PARAM - Invalid clock path number, or input or desired output frequency is out of valid range <br />
CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call this function after changing the PLL input frequency, for example if <a class="el" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource()</a> is called.</dd>
<dd>
Do not call this function when the PLL is enabled. If it is called, then this function returns immediately with an error return value and no register updates.</dd>
<dd>
Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is decreasing.</dd>
<dd>
This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gaaa6456259e31b786c7e161435b7dd450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa6456259e31b786c7e161435b7dd450">&#9670;&nbsp;</a></span>Cy_SysClk_Pll200MManualConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_Pll200MManualConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually configures a 200M PLL based on user inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to configure.</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully configured <br />
CY_SYSCLK_INVALID_STATE - PLL not configured because it is enabled <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call this function after changing the PLL input frequency; for example if <a class="el" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource()</a> is called.</dd>
<dd>
Do not call this function when the PLL is enabled. If it is called, then this function returns immediately with an error return value and no register updates.</dd>
<dd>
Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is decreasing.</dd>
<dd>
This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga030e569b07a163e58e84928773b9ad25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga030e569b07a163e58e84928773b9ad25">&#9670;&nbsp;</a></span>Cy_SysClk_Pll200MGetConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_Pll200MGetConfiguration </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports configuration settings for 200M PLL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to report.</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL data successfully reported <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gaa755ea5198f4eebc6b7e7991bfe30c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa755ea5198f4eebc6b7e7991bfe30c6e">&#9670;&nbsp;</a></span>Cy_SysClk_Pll200MEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_Pll200MEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeoutus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the 200M PLL. </p>
<p>The PLL should be configured before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to enable.</td></tr>
    <tr><td class="paramname">timeoutus</td><td>amount of time in microseconds to wait for the PLL to lock. If the lock doesn't occur, PLL is stopped. To avoid waiting for lock, set this to 0 and manually check for lock using <a class="el" href="group__group__sysclk__pll__funcs.html#ga4be60f83c0ecbcaa5dcb6f41c93d6958">Cy_SysClk_PllLocked</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully enabled <br />
CY_SYSCLK_TIMEOUT - Timeout waiting for PLL lock <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is decreasing.</dd>
<dd>
This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga850229a9ff0d4af9d0f298f377ce5ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga850229a9ff0d4af9d0f298f377ce5ba0">&#9670;&nbsp;</a></span>Cy_SysClk_Pll200MIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_SysClk_Pll200MIsEnabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected 200M PLL is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = disabled <br />
true = enabled</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gaae48c98d74bbb34e049d2e8c17100685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae48c98d74bbb34e049d2e8c17100685">&#9670;&nbsp;</a></span>Cy_SysClk_Pll200MLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_SysClk_Pll200MLocked </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected 200M PLL is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = not locked <br />
true = locked</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga40696a5667ca242332fb3de42b1b2994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40696a5667ca242332fb3de42b1b2994">&#9670;&nbsp;</a></span>Cy_SysClk_Pll200MLostLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_SysClk_Pll200MLostLock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected 200M PLL lost its lock since the last time this function was called. </p>
<p>Clears the lost lock indicator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = did not lose lock <br />
true = lost lock</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga8b42389042d11aaa84bd2e769f6b7b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b42389042d11aaa84bd2e769f6b7b27">&#9670;&nbsp;</a></span>Cy_SysClk_Pll200MDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_Pll200MDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the selected 200M PLL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully disabled <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is decreasing.</dd></dl>
<dl class="section user"><dt>Side Effects</dt><dd>This function sets PLL bypass mode to CY_SYSCLK_FLLPLL_OUTPUT_INPUT. If AUTO mode should be used, call <a class="el" href="group__group__sysclk__pll__funcs.html#gac5c498137bf7012e8e0f8b8e0dfba1f0">Cy_SysClk_PllConfigure</a> or <a class="el" href="group__group__sysclk__pll__funcs.html#gad21ad8110bfc4506947fbd0fb163d055">Cy_SysClk_PllManualConfigure</a> before calling <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gabdf2396edece2bf47abd72603fc791e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdf2396edece2bf47abd72603fc791e5">&#9670;&nbsp;</a></span>Cy_SysClk_Pll200MGetFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SysClk_Pll200MGetFrequency </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the frequency of PLL200M. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PLL200M Frequency</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gad498857f6d3c3b8df8dd176391d07f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad498857f6d3c3b8df8dd176391d07f6f">&#9670;&nbsp;</a></span>Cy_SysClk_Pll400MConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_Pll400MConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures 400M PLL. </p>
<p>The configuration formula used is: Fout = pll_clk * (P / Q / div_out), where: Fout is the desired output frequency pll_clk is the frequency of the input source P is the feedback divider. Its value is in bitfield FEEDBACK_DIV. Q is the reference divider. Its value is in bitfield REFERENCE_DIV. div_out is the reference divider. Its value is in bitfield OUTPUT_DIV.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to configure</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully configured <br />
CY_SYSCLK_INVALID_STATE - PLL not configured because it is enabled <br />
CY_SYSCLK_BAD_PARAM - Invalid clock path number, or input or desired output frequency is out of valid range <br />
CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call this function after changing the PLL input frequency, for example if <a class="el" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource()</a> is called.</dd>
<dd>
Do not call this function when the PLL is enabled. If it is called, then this function returns immediately with an error return value and no register updates.</dd>
<dd>
Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is decreasing.</dd>
<dd>
This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga940fd6400c3ea9f37a0b26893ae8b42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga940fd6400c3ea9f37a0b26893ae8b42b">&#9670;&nbsp;</a></span>Cy_SysClk_Pll400MManualConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_Pll400MManualConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually configures a 400M PLL based on user inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to configure.</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully configured <br />
CY_SYSCLK_INVALID_STATE - PLL not configured because it is enabled <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call this function after changing the PLL input frequency; for example if <a class="el" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource()</a> is called.</dd>
<dd>
Do not call this function when the PLL is enabled. If it is called, then this function returns immediately with an error return value and no register updates.</dd>
<dd>
Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is decreasing.</dd>
<dd>
This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gad0d8b724b371f76ba51ed3378691d9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0d8b724b371f76ba51ed3378691d9df">&#9670;&nbsp;</a></span>Cy_SysClk_Pll400MGetConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_Pll400MGetConfiguration </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports configuration settings for 400M PLL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to report.</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL data successfully reported <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gaa92e2b0dd3f211143fd66edf70fcd2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa92e2b0dd3f211143fd66edf70fcd2ae">&#9670;&nbsp;</a></span>Cy_SysClk_Pll400MEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_Pll400MEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeoutus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the 400M PLL. </p>
<p>The PLL should be configured before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to enable.</td></tr>
    <tr><td class="paramname">timeoutus</td><td>amount of time in microseconds to wait for the PLL to lock. If the lock doesn't occur, PLL is stopped. To avoid waiting for lock, set this to 0 and manually check for lock using <a class="el" href="group__group__sysclk__pll__funcs.html#ga4be60f83c0ecbcaa5dcb6f41c93d6958">Cy_SysClk_PllLocked</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully enabled <br />
CY_SYSCLK_TIMEOUT - Timeout waiting for PLL lock <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is decreasing.</dd>
<dd>
This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga156fecfbaecb9d502c74529f910fe24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156fecfbaecb9d502c74529f910fe24b">&#9670;&nbsp;</a></span>Cy_SysClk_Pll400MIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_SysClk_Pll400MIsEnabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected 400M PLL is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = disabled <br />
true = enabled</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga5455c05316aa399ef5afacf7648a3cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5455c05316aa399ef5afacf7648a3cf1">&#9670;&nbsp;</a></span>Cy_SysClk_Pll400MLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_SysClk_Pll400MLocked </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected 400M PLL is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = not locked <br />
true = locked</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga8e300a347373de8ab2c7d2ca89b05dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e300a347373de8ab2c7d2ca89b05dee">&#9670;&nbsp;</a></span>Cy_SysClk_Pll400MLostLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_SysClk_Pll400MLostLock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected 200M PLL lost its lock since the last time this function was called. </p>
<p>Clears the lost lock indicator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = did not lose lock <br />
true = lost lock</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga51760beb96b211722ffa88483b9d3af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51760beb96b211722ffa88483b9d3af2">&#9670;&nbsp;</a></span>Cy_SysClk_Pll400MDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_Pll400MDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the selected 400M PLL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully disabled <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled CY_SYSCLK_UNSUPPORTED_STATE - PLL is not present</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call <a class="el" href="group__group__startup__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is decreasing.</dd></dl>
<dl class="section user"><dt>Side Effects</dt><dd>This function sets PLL bypass mode to CY_SYSCLK_FLLPLL_OUTPUT_INPUT. If AUTO mode should be used, call <a class="el" href="group__group__sysclk__pll__funcs.html#gac5c498137bf7012e8e0f8b8e0dfba1f0">Cy_SysClk_PllConfigure</a> or <a class="el" href="group__group__sysclk__pll__funcs.html#gad21ad8110bfc4506947fbd0fb163d055">Cy_SysClk_PllManualConfigure</a> before calling <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga1e83e55b944bb47222d309ede5569d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e83e55b944bb47222d309ede5569d38">&#9670;&nbsp;</a></span>Cy_SysClk_Pll400MGetFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SysClk_Pll400MGetFrequency </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pllNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the frequency of PLL400M. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pllNum</td><td>Selects which PLL to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PLL400M Frequency</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available only for CAT1C devices. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
