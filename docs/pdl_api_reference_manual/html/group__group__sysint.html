<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: SysInt       (System Interrupt)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__sysint.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">SysInt (System Interrupt)</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>The SysInt driver provides an API to configure the device peripheral interrupts. </p>
<p>It provides a lightweight interface to complement the <a href="https://www.keil.com/pack/doc/CMSIS/Core/html/group__NVIC__gr.html">CMSIS core NVIC API</a>. The provided functions are applicable for all cores in a device and they can be used to configure and connect device peripheral interrupts to one or more cores.</p>
<p>The functions and other declarations used in this driver are in cy_sysint.h. You can include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<h1><a class="anchor" id="group_sysint_vector_table"></a>
Vector Table</h1>
<h2><a class="anchor" id="group_sysint_CM0_CM4"></a>
CM0+/CM4</h2>
<p>The vector table defines the entry addresses of the processor exceptions and the device specific interrupts. It is located at the start address of the flash and is copied by the startup code to RAM. The symbol code __Vectors is the address of the vector table in the startup code and the register SCB-&gt;VTOR holds the start address of the vector table. See <a class="el" href="group__group__system__config__cm4.html#group_system_config_device_vector_table">Vectors Table Copy from Flash to RAM</a> section for the implementation details. The default interrupt handler functions are defined as weak functions to a dummy handler in the startup file. The naming convention is &lt;interrupt_name&gt;_IRQHandler.</p>
<p>Defining these in the user application allows the linker to place them in the vector table in flash/ROM. For example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ioss_interrupts_gpio_0_IRQHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p> And can be used like this: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is not relocated anywhere from _Vectors[] in flash */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if (CY_CPU_CORTEX_M0P)</span></div><div class="line">    <span class="comment">/* Prototype of ISR function for NvicMux7, defined as a weak function in startup_psoc0x_cm0plus.s */</span></div><div class="line">    <span class="keywordtype">void</span> NvicMux7_IRQHandler(<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <span class="comment">/* Prototype of ISR function for gpio interrupt 0, defined as a weak function in startup_psoc0x_cm4.s */</span></div><div class="line">    <span class="keywordtype">void</span> ioss_interrupts_gpio_0_IRQHandler(<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the interrupt with vector at Interrupt_Handler_Port0() */</span></div><div class="line">    <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;intrCfg, (<a class="code" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>)NULL);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the interrupt */</span></div><div class="line">    NVIC_EnableIRQ(intrCfg.intrSrc);</div><div class="line"></div></div><!-- fragment --><p>Using this method avoids the need for a RAM vector table. However in this scenario, interrupt handler re-location at run-time is not possible, unless the vector table is relocated to RAM.</p>
<h2><a class="anchor" id="group_sysint_CM33"></a>
CM33</h2>
<p>CM33 with Security extension supports two vector tables, one for secure world and another for non-secure world. Secure interrupt vector table is placed in the secure ROM/FLASH, where as non-secure interrupt vector table is placed in the non-secure ROM/FLASH. In both scenarios, vector tables are copied by the startup code to secure and non-secure RAM respectively. The symbol code __s_vector_table is the address of the secure vector table and __ns_vector_table is for the non-secure world in the startup code. The register SCB-&gt;VTOR holds the start address of the vector table. See <a class="el" href="group__group__system__config__cm4.html#group_system_config_device_vector_table">Vectors Table Copy from Flash to RAM</a> section for the implementation details.</p>
<p>CM33 without Security extension will support only non-secure interrupts.</p>
<p>The default interrupt handler functions are defined to a dummy handler in the startup file. The naming convention is &lt;interrupt_name&gt;_IRQHandler.</p>
<h2><a class="anchor" id="group_sysint_CM55"></a>
CM55</h2>
<p>CM55 is without Security extension and will support only non-secure interrupts. It is similar to CM33 non-secure part. Additionally CM55 core has support to block EWIC (External Wakeup Interrupt Controller). EWIC is a peripheral to the processor and it can be a source of wakeup in the system. EWIC block is disabled by default and needs to be enabled in order for the DS wakeup source to work.</p>
<h2><a class="anchor" id="group_sysint_CM0_CM7"></a>
CAT1C CM0+/CM7</h2>
<p>The vector table defines the entry addresses of the processor exceptions and the device specific interrupts. Interrupt vector table is placed in the ROM/FLASH. The vector table is copied by the startup code to RAM. The symbol code __ramVectors is the address of the vector table. The register SCB-&gt;VTOR holds the start address of the vector table. See <a class="el" href="group__group__system__config__cm4.html#group_system_config_device_vector_table">Vectors Table Copy from Flash to RAM</a> section for the implementation details. Each system interrupt has to be mapped onto one out of eight external CPU interrupts. When a system interrupt is triggered, corresponding mapped CPU IRQ gets triggered which results in the execution of the default CPU IRQ handler. In this handler the system interrupt mapped to this CPU interrupt will be fetched and executed.</p>
<p>The default CPU IRQ handler functions are defined as weak functions in the startup file. The naming convention followed is &lt;core&gt;_CpuIntr&lt;interrupt_number&gt;_Handler. Below is the code snippet. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Interrupt_Handler_Port0(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    ... <span class="comment">//User interrupt handler</span></div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is relocated to RAM in __ramVectors[] */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Prototype of ISR function for port interrupt 0. For CY_IP_M7CPUSS port 21 is configured */</span></div><div class="line">    <span class="keywordtype">void</span> Interrupt_Handler_Port0 (<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the interrupt with vector at Interrupt_Handler_Port0() */</span></div><div class="line">    <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;intrCfg, &amp;Interrupt_Handler_Port0);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the interrupt */</span></div><div class="line"><span class="preprocessor">#if (CY_IP_M7CPUSS)</span></div><div class="line">    NVIC_EnableIRQ((<a class="code" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>) NvicMux3_IRQn);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    NVIC_EnableIRQ(intrCfg.intrSrc);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="group_sysint_driver_usage"></a>
Driver Usage</h1>
<h2><a class="anchor" id="group_sysint_initialization"></a>
Initialization</h2>
<p>Interrupt numbers are defined in a device-specific header file, such as cy8c68237bz_ble.h, and are consistent with interrupt handlers defined in the vector table.</p>
<p>To configure an interrupt, call <a class="el" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d" title="Initializes the referenced interrupt by setting the priority and the interrupt vector. ">Cy_SysInt_Init()</a>. Populate the configuration structure (<a class="el" href="structcy__stc__sysint__t.html" title="Initialization configuration structure for a single interrupt channel. ">cy_stc_sysint_t</a>) and pass it as a parameter along with the ISR address. This initializes the interrupt and instructs the CPU to jump to the specified ISR vector upon a valid trigger. For CM0+ core, the configuration structure (<a class="el" href="structcy__stc__sysint__t.html" title="Initialization configuration structure for a single interrupt channel. ">cy_stc_sysint_t</a>) must specify the device interrupt source (cm0pSrc) that feeds into the CM0+ NVIC mux (intrSrc).</p>
<p>For CM4/CM33/CM55 core, system interrupt source 'n' is connected to the corresponding IRQn. Deep-sleep capable interrupts are allocated to Deep Sleep capable IRQn channels.</p>
<p>For CAT1C CM7/CM0+ core, the configuration structure (<a class="el" href="structcy__stc__sysint__t.html" title="Initialization configuration structure for a single interrupt channel. ">cy_stc_sysint_t</a>) must specify system interrupt source, CPU IRQ and the CPU IRQ priority. The system interrupt source is mapped to bit 0-15 of intrSrc parameter and CPU IRQ is mapped to bit 16-31 of intrSrc parameter.</p>
<p>For CM0+ core, deep Sleep wakeup-capability is determined by the CPUSS_CM0_DPSLP_IRQ_NR parameter, where the first N number of muxes (NvicMux0 ... NvicMuxN-1) have the capability to trigger Deep Sleep interrupts. A Deep Sleep capable interrupt source must be connected to one of these muxes to be able to trigger in Deep Sleep. Refer to the IRQn_Type definition in the device header.</p>
<ol type="1">
<li>For CPUSS_ver1 the CM0+ core supports up to 32 interrupt channels (IRQn 0-31). To allow all device interrupts to be routable to the NVIC of this core, there is a 240:1 multiplexer at each of the 32 NVIC channels.</li>
<li>For CPUSS_ver2 the CM0+ core supports up to 8 hardware interrupt channels (IRQn 0-7) and software-only interrupt channels (IRQn 8-15). The device has up to 1023 interrupts that can be connected to any of the hardware interrupt channels. In this structure, multiple interrupt sources can be connected simultaneously to one NVIC channel. The application must then query the interrupt source on the channel and service the active interrupt(s). The priority of these interrupts is determined by the interrupt number as defined in the cy_en_intr_t enum, where the lower number denotes higher priority over the higher number.</li>
</ol>
<h2><a class="anchor" id="group_sysint_enable"></a>
Enable</h2>
<p>After initializing an interrupt, use the CMSIS Core <a href="https://www.keil.com/pack/doc/CMSIS/Core/html/group__NVIC__gr.html#ga530ad9fda2ed1c8b70e439ecfe80591f">NVIC_EnableIRQ()</a> function to enable it. Given an initialization structure named config, the function should be called as follows: </p><div class="fragment"><div class="line">NVIC_EnableIRQ(config.intrSrc)</div></div><!-- fragment --><h2><a class="anchor" id="group_sysint_service"></a>
Writing an interrupt service routine</h2>
<p>Servicing interrupts in the Peripheral Drivers should follow a prescribed recipe to ensure all interrupts are serviced and duplicate interrupts are not received. Any peripheral-specific register that must be written to clear the source of the interrupt should be written as soon as possible in the interrupt service routine. However, note that due to buffering on the output bus to the peripherals, the write clearing of the interrupt may be delayed. After performing the normal interrupt service that should respond to the interrupting condition, the interrupt register that was initially written to clear the register should be read before returning from the interrupt service routine. This read ensures that the initial write has been flushed out to the hardware. Note, no additional processing should be performed based on the result of this read, as this read is intended only to ensure the write operation is flushed.</p>
<p>This final read may indicate a pending interrupt. What this means is that in the interval between when the write actually happened at the peripheral and when the read actually happened at the peripheral, an interrupting condition occurred. This is ok and a return from the interrupt is still the correct action. As soon as conditions warrant, meaning interrupts are enabled and there are no higher priority interrupts pending, the interrupt will be triggered again to service the additional condition.</p>
<h1><a class="anchor" id="group_sysint_section_configuration_considerations"></a>
Configuration Considerations</h1>
<p>Certain CM0+ <a href="https://www.keil.com/pack/doc/CMSIS/Core/html/group__NVIC__gr.html#ga7e1129cd8a196f4284d41db3e82ad5c8">NVIC IRQn</a> channels are reserved for system use: </p><table class="doxtable">
<tr>
<th>NVIC channel (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>)</th><th>Interrupt source (<a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>)</th><th>Purpose </th></tr>
<tr>
<td>#0 (NvicMux0_IRQn)</td><td>IPC Interrupt #0 (cpuss_interrupts_ipc_0_IRQn)</td><td>System Calls to ROM </td></tr>
<tr>
<td>#1 (NvicMux1_IRQn)</td><td>IPC Interrupt #3 (cpuss_interrupts_ipc_3_IRQn)</td><td>System IPC pipe in the default startup </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>For CPUSS_ver2, each NVIC channel can be shared between multiple interrupt sources. However it is not recommended to share the application NVIC channel with the reserved channels.</dd>
<dd>
In CAT1C, NvicMux0_IRQn and NvicMux1_IRQn are used by ROM and not meant for user.</dd></dl>
<h1><a class="anchor" id="group_sysint_more_information"></a>
More Information</h1>
<p>Refer to the technical reference manual (TRM) and the device datasheet.</p>
<h1><a class="anchor" id="group_sysint_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.110 </td><td>Updated API <a class="el" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>. </td><td>CM0P interrupt priority bug fix.  </td></tr>
<tr>
<td>1.100 </td><td>Added support for TRAVEO&trade; II Body Entry devices.<br />
 Pre-processor check for MXS40SRSS version now groups ver. 2 with ver. 3. Previously ver. 2 was grouped with ver. 1. Added support for CM0+/CM4 dual core devices. Previously only supported CM0+/CM7 devices. </td><td>Code enhancement and support for new devices.  </td></tr>
<tr>
<td>1.90.1 </td><td>Fixed MISRA 2012 8.5 and 8.6 violations. </td><td>MISRA 2012 compliance..  </td></tr>
<tr>
<td>1.90 </td><td>Updated <a class="el" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>, <a class="el" href="group__group__sysint__functions.html#ga6628d90db5d0e0e8801535e2f1519266">Cy_SysInt_SetVector</a> and <a class="el" href="group__group__sysint__functions.html#gac3feeb7969667eebe109ecab98dbfbb2">Cy_SysInt_GetVector</a> APIs. </td><td>Code Clean up.  </td></tr>
<tr>
<td>1.80 </td><td>API's <a class="el" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3" title="Configures the interrupt selection for the specified NVIC channel. ">Cy_SysInt_SetInterruptSource()</a>, <a class="el" href="group__group__sysint__functions.html#gacc962aa9f81be5df394ccf2ff746270b" title="Gets the interrupt source of the NVIC channel. ">Cy_SysInt_GetInterruptSource()</a>, <a class="el" href="group__group__sysint__functions.html#ga7be24fe4952cebbba78e612463981287" title="Disconnect the interrupt source from the specified NVIC channel. ">Cy_SysInt_DisconnectInterruptSource()</a>, <a class="el" href="group__group__sysint__functions.html#ga3163ed7de473929acded134fc67ab997" title="Sets the interrupt source of the CPU core NMI. ">Cy_SysInt_SetNmiSource()</a>, <a class="el" href="group__group__sysint__functions.html#ga460d1703cced3ba31091a77355434649" title="Gets the interrupt source of the CPU core NMI for the given NMI source number. ">Cy_SysInt_GetNmiSource()</a>, Cy_SysInt_SoftwareTrig(), <a class="el" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932" title="Gets the NVIC channel to which the interrupt source is connected. ">Cy_SysInt_GetNvicConnection()</a>, <a class="el" href="group__group__sysint__functions.html#ga9e42b44b1946290e12f25ff5042f1fc0" title="Gets the highest priority active interrupt for the selected NVIC channel. ">Cy_SysInt_GetInterruptActive()</a>, <a class="el" href="group__group__sysint__functions.html#ga28cee26f53a27552e4cb434f5b16bde3" title="Initializes the referenced external interrupt by setting the CPU IRQ priority and the interrupt vecto...">Cy_SysInt_InitExtIRQ()</a>, <a class="el" href="group__group__sysint__functions.html#ga7dc474639ecee7d1014e94464ca72520" title="Initializes the referenced internal interrupt by setting the priority and the interrupt vector...">Cy_SysInt_InitIntIRQ()</a>, <a class="el" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d" title="Initializes the referenced interrupt by setting the priority and the interrupt vector. ">Cy_SysInt_Init()</a>, <a class="el" href="group__group__sysint__functions.html#ga6628d90db5d0e0e8801535e2f1519266" title="Changes the ISR vector for the interrupt. ">Cy_SysInt_SetVector()</a>, <a class="el" href="group__group__sysint__functions.html#gac3feeb7969667eebe109ecab98dbfbb2" title="Gets the address of the current ISR vector for the interrupt. ">Cy_SysInt_GetVector()</a>, <a class="el" href="group__group__sysint__functions.html#gac9dbdadbfad60830b215cc9ca4a14cdc" title="Sets the User ISR vector for the System Interrupt. ">Cy_SysInt_SetSystemIrqVector()</a>, <a class="el" href="group__group__sysint__functions.html#ga3b4be2b36944476c434f4bd20545d8a3" title="Enable system interrupt. ">Cy_SysInt_EnableSystemInt()</a>, <a class="el" href="group__group__sysint__functions.html#ga4a85186c69bb5375f1009fba7ea4ca0f" title="Disable system interrupt. ">Cy_SysInt_DisableSystemInt()</a> modified. </td><td>New device support, Fix Coverity issues, Documentation enhancement.  </td></tr>
<tr>
<td>1.70 </td><td>Support for CAT1C, CAT1D.<br />
Newly added API's <a class="el" href="group__group__sysint__functions.html#gac9dbdadbfad60830b215cc9ca4a14cdc" title="Sets the User ISR vector for the System Interrupt. ">Cy_SysInt_SetSystemIrqVector()</a> to set the user ISR vector for the System Interrupt, <a class="el" href="group__group__sysint__functions.html#ga65e7577e0339a89a74bf09596a2c874b" title="Gets the address of the current user ISR vector for the System Interrupt. ">Cy_SysInt_GetSystemIrqVector()</a> to get the address of the current user ISR vector for the System Interrupt, <a class="el" href="group__group__sysint__functions.html#ga3b4be2b36944476c434f4bd20545d8a3" title="Enable system interrupt. ">Cy_SysInt_EnableSystemInt()</a> to enable system interrupt, <a class="el" href="group__group__sysint__functions.html#ga4a85186c69bb5375f1009fba7ea4ca0f" title="Disable system interrupt. ">Cy_SysInt_DisableSystemInt()</a> to disable system interrupt, <a class="el" href="group__group__sysint__functions.html#ga28cee26f53a27552e4cb434f5b16bde3" title="Initializes the referenced external interrupt by setting the CPU IRQ priority and the interrupt vecto...">Cy_SysInt_InitExtIRQ()</a> to initialize the referenced external interrupt by setting the CPU IRQ priority and the interrupt vector, <a class="el" href="group__group__sysint__functions.html#ga7dc474639ecee7d1014e94464ca72520" title="Initializes the referenced internal interrupt by setting the priority and the interrupt vector...">Cy_SysInt_InitIntIRQ()</a> to initialize the referenced internal interrupt by setting the priority and the interrupt vector. </td><td><p class="starttd">New devices support. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>1.60 </td><td>Support for CM33. </td><td>New devices support.  </td></tr>
<tr>
<td>1.50 </td><td>Fixed MISRA 2012 violations. </td><td>MISRA 2012 compliance.  </td></tr>
<tr>
<td>1.40 </td><td>Updated the CY_SYSINT_IS_PC_0 macro to access the protected register for the secure CYB06xx7 devices via <a class="el" href="group__group__pra.html">PRA (Protected Register Access)</a> driver.  </td><td>Added PSoC 64 devices support.  </td></tr>
<tr>
<td>1.30.1 </td><td>Minor documentation updates. </td><td>Documentation enhancement.  </td></tr>
<tr>
<td>1.30 </td><td>The Cy_SysInt_SetNmiSource is updated with Protection Context check for CM0+. </td><td>User experience enhancement.  </td></tr>
<tr>
<td>1.20.1 </td><td>The Vector Table section is extended with a code snippet. </td><td>Documentation enhancement.  </td></tr>
<tr>
<td rowspan="3">1.20 </td><td>Flattened the organization of the driver source code into the single source directory and the single include directory. </td><td>Driver library directory-structure simplification.  </td></tr>
<tr>
<td><p class="starttd">Added CPUSS_ver2 support to the following API functions:</p><ul>
<li><a class="el" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a></li>
<li><a class="el" href="group__group__sysint__functions.html#ga3163ed7de473929acded134fc67ab997">Cy_SysInt_SetNmiSource</a></li>
<li><a class="el" href="group__group__sysint__functions.html#ga460d1703cced3ba31091a77355434649">Cy_SysInt_GetNmiSource</a></li>
</ul>
<p>Added new API functions:</p><ul>
<li><a class="el" href="group__group__sysint__functions.html#ga7be24fe4952cebbba78e612463981287">Cy_SysInt_DisconnectInterruptSource</a></li>
<li><a class="el" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a></li>
<li><a class="el" href="group__group__sysint__functions.html#ga9e42b44b1946290e12f25ff5042f1fc0">Cy_SysInt_GetInterruptActive</a></li>
</ul>
<p class="endtd">Deprecated following functions:</p><ul>
<li>Cy_SysInt_SetIntSource</li>
<li>Cy_SysInt_GetIntSource</li>
<li>Cy_SysInt_SetIntSourceNMI</li>
<li>Cy_SysInt_GetIntSourceNMI  </li>
</ul>
</td><td>New devices support.  </td></tr>
<tr>
<td>Added register access layer. Use register access macros instead of direct register access using dereferenced pointers. </td><td>Makes register access device-independent, so that the PDL does not need to be recompiled for each supported part number.  </td></tr>
<tr>
<td>1.10 </td><td>Cy_SysInt_GetState() function is redefined to call NVIC_GetEnableIRQ() </td><td></td></tr>
<tr>
<td>1.0 </td><td>Initial version </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__sysint__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__sysint__globals"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__globals.html">Global variables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__sysint__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__sysint__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__sysint__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga06c8142ccb50c175443ac78951ea4d21"><td class="memItemLeft" align="right" valign="top"><a id="ga06c8142ccb50c175443ac78951ea4d21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint.html#ga06c8142ccb50c175443ac78951ea4d21">CY_SYSINT_INTRSRC_MASK</a>&#160;&#160;&#160;(0xFFFFUL)</td></tr>
<tr class="memdesc:ga06c8142ccb50c175443ac78951ea4d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 0-15 indicate system interrupt and bit 16-31 will indicate the CPU IRQ. <br /></td></tr>
<tr class="separator:ga06c8142ccb50c175443ac78951ea4d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b9f1b9de4f122495a8b6580ce500d9a"><td class="memItemLeft" align="right" valign="top"><a id="ga3b9f1b9de4f122495a8b6580ce500d9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint.html#ga3b9f1b9de4f122495a8b6580ce500d9a">CY_SYSINT_INTRSRC_MUXIRQ_SHIFT</a>&#160;&#160;&#160;(16UL)</td></tr>
<tr class="memdesc:ga3b9f1b9de4f122495a8b6580ce500d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 0-15 indicate system interrupt and bit 16-31 will indicate the CPU IRQ. <br /></td></tr>
<tr class="separator:ga3b9f1b9de4f122495a8b6580ce500d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
