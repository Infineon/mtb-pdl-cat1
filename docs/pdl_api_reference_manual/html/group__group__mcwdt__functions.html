<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__mcwdt__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__mcwdt.html">MCWDT        (Multi-Counter Watchdog)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab8bd6fb7ec48ef294287c01e179c41df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__mcwdt__enums.html#gac983f45895a641f98b9b887e453a8a5d">cy_en_mcwdt_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gab8bd6fb7ec48ef294287c01e179c41df">Cy_MCWDT_Init</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, <a class="el" href="structcy__stc__mcwdt__config__t.html">cy_stc_mcwdt_config_t</a> const *config)</td></tr>
<tr class="memdesc:gab8bd6fb7ec48ef294287c01e179c41df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the MCWDT block.  <a href="#gab8bd6fb7ec48ef294287c01e179c41df">More...</a><br /></td></tr>
<tr class="separator:gab8bd6fb7ec48ef294287c01e179c41df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa316d17f65aea2cf6ae6f078453549"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gacfa316d17f65aea2cf6ae6f078453549">Cy_MCWDT_DeInit</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base)</td></tr>
<tr class="memdesc:gacfa316d17f65aea2cf6ae6f078453549"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the MCWDT block, returns register values to their default state.  <a href="#gacfa316d17f65aea2cf6ae6f078453549">More...</a><br /></td></tr>
<tr class="separator:gacfa316d17f65aea2cf6ae6f078453549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f8d4636fc67fc8abe3bfd87ab521ac"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga90f8d4636fc67fc8abe3bfd87ab521ac">Cy_MCWDT_Enable</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, uint32_t counters, uint16_t waitUs)</td></tr>
<tr class="memdesc:ga90f8d4636fc67fc8abe3bfd87ab521ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables all specified counters.  <a href="#ga90f8d4636fc67fc8abe3bfd87ab521ac">More...</a><br /></td></tr>
<tr class="separator:ga90f8d4636fc67fc8abe3bfd87ab521ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecaccda05008638b249cacd1cf9ea9c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga9ecaccda05008638b249cacd1cf9ea9c">Cy_MCWDT_Disable</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, uint32_t counters, uint16_t waitUs)</td></tr>
<tr class="memdesc:ga9ecaccda05008638b249cacd1cf9ea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables all specified counters.  <a href="#ga9ecaccda05008638b249cacd1cf9ea9c">More...</a><br /></td></tr>
<tr class="separator:ga9ecaccda05008638b249cacd1cf9ea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a0ff9cf9f6389150122f2e4e0af9b3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gaf0a0ff9cf9f6389150122f2e4e0af9b3">Cy_MCWDT_GetEnabledStatus</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:gaf0a0ff9cf9f6389150122f2e4e0af9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the enabled status of the specified counter.  <a href="#gaf0a0ff9cf9f6389150122f2e4e0af9b3">More...</a><br /></td></tr>
<tr class="separator:gaf0a0ff9cf9f6389150122f2e4e0af9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b6d812cb7c3984fd63f087415b24279"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga4b6d812cb7c3984fd63f087415b24279">Cy_MCWDT_Lock</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base)</td></tr>
<tr class="memdesc:ga4b6d812cb7c3984fd63f087415b24279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks out configuration changes to all MCWDT registers.  <a href="#ga4b6d812cb7c3984fd63f087415b24279">More...</a><br /></td></tr>
<tr class="separator:ga4b6d812cb7c3984fd63f087415b24279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1433c7f1fc62caf1c7697b0e2f20fef0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga1433c7f1fc62caf1c7697b0e2f20fef0">Cy_MCWDT_Unlock</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base)</td></tr>
<tr class="memdesc:ga1433c7f1fc62caf1c7697b0e2f20fef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the MCWDT configuration registers.  <a href="#ga1433c7f1fc62caf1c7697b0e2f20fef0">More...</a><br /></td></tr>
<tr class="separator:ga1433c7f1fc62caf1c7697b0e2f20fef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7178ccb7c11988aa5597d128bacd9bb3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga7178ccb7c11988aa5597d128bacd9bb3">Cy_MCWDT_GetLockedStatus</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:ga7178ccb7c11988aa5597d128bacd9bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the locked/unlocked state of the MCWDT.  <a href="#ga7178ccb7c11988aa5597d128bacd9bb3">More...</a><br /></td></tr>
<tr class="separator:ga7178ccb7c11988aa5597d128bacd9bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5ff22771e9c3a5203d154842f4e339"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga6f5ff22771e9c3a5203d154842f4e339">Cy_MCWDT_SetMode</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, <a class="el" href="group__group__mcwdt__enums.html#gaa3ab9dd24dfec93a9982f06b5d7f0221">cy_en_mcwdtmode_t</a> <a class="el" href="group__group__ipc__bt__data__structures.html#ga37e90f5e3bd99fac2021fb3a326607d4">mode</a>)</td></tr>
<tr class="memdesc:ga6f5ff22771e9c3a5203d154842f4e339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mode of the specified counter.  <a href="#ga6f5ff22771e9c3a5203d154842f4e339">More...</a><br /></td></tr>
<tr class="separator:ga6f5ff22771e9c3a5203d154842f4e339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70dfa889ac1ea76ed7dd84149182f634"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__mcwdt__enums.html#gaa3ab9dd24dfec93a9982f06b5d7f0221">cy_en_mcwdtmode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga70dfa889ac1ea76ed7dd84149182f634">Cy_MCWDT_GetMode</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga70dfa889ac1ea76ed7dd84149182f634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the mode of the specified counter.  <a href="#ga70dfa889ac1ea76ed7dd84149182f634">More...</a><br /></td></tr>
<tr class="separator:ga70dfa889ac1ea76ed7dd84149182f634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77bb788adb7fac2042772b00a61f95cb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga77bb788adb7fac2042772b00a61f95cb">Cy_MCWDT_SetClearOnMatch</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, uint32_t enable)</td></tr>
<tr class="memdesc:ga77bb788adb7fac2042772b00a61f95cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Clear on match option for the specified counter.  <a href="#ga77bb788adb7fac2042772b00a61f95cb">More...</a><br /></td></tr>
<tr class="separator:ga77bb788adb7fac2042772b00a61f95cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab443fb0e7d74e1a038ad24b90fedb22e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gab443fb0e7d74e1a038ad24b90fedb22e">Cy_MCWDT_GetClearOnMatch</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:gab443fb0e7d74e1a038ad24b90fedb22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the Clear on match setting for the specified counter.  <a href="#gab443fb0e7d74e1a038ad24b90fedb22e">More...</a><br /></td></tr>
<tr class="separator:gab443fb0e7d74e1a038ad24b90fedb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca650f48c11727f9e5a7f31a5fcb11b2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gaca650f48c11727f9e5a7f31a5fcb11b2">Cy_MCWDT_SetCascade</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, <a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a> cascade)</td></tr>
<tr class="memdesc:gaca650f48c11727f9e5a7f31a5fcb11b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the counter cascade options.  <a href="#gaca650f48c11727f9e5a7f31a5fcb11b2">More...</a><br /></td></tr>
<tr class="separator:gaca650f48c11727f9e5a7f31a5fcb11b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga800189be8d7308f4227fb1e4d43d6dc4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga800189be8d7308f4227fb1e4d43d6dc4">Cy_MCWDT_GetCascade</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:ga800189be8d7308f4227fb1e4d43d6dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports all the counter cascade option settings.  <a href="#ga800189be8d7308f4227fb1e4d43d6dc4">More...</a><br /></td></tr>
<tr class="separator:ga800189be8d7308f4227fb1e4d43d6dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a50c23172825fb65c2f2bb4fea61eb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gaf0a50c23172825fb65c2f2bb4fea61eb">Cy_MCWDT_SetMatch</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, uint32_t match, uint16_t waitUs)</td></tr>
<tr class="memdesc:gaf0a50c23172825fb65c2f2bb4fea61eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the match comparison value for the specified counter (0 or 1).  <a href="#gaf0a50c23172825fb65c2f2bb4fea61eb">More...</a><br /></td></tr>
<tr class="separator:gaf0a50c23172825fb65c2f2bb4fea61eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga478fe2fb91d122511d5805eabe7cbb97"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga478fe2fb91d122511d5805eabe7cbb97">Cy_MCWDT_GetMatch</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga478fe2fb91d122511d5805eabe7cbb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the match comparison value for the specified counter (0 or 1).  <a href="#ga478fe2fb91d122511d5805eabe7cbb97">More...</a><br /></td></tr>
<tr class="separator:ga478fe2fb91d122511d5805eabe7cbb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c7f8cc4f0897618bb6c4b3389357086"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga2c7f8cc4f0897618bb6c4b3389357086">Cy_MCWDT_GetCountCascaded</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:ga2c7f8cc4f0897618bb6c4b3389357086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the current value of combined C1-C0 cascaded counters.  <a href="#ga2c7f8cc4f0897618bb6c4b3389357086">More...</a><br /></td></tr>
<tr class="separator:ga2c7f8cc4f0897618bb6c4b3389357086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038dc9c62219cdd225d194e93b26678d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga038dc9c62219cdd225d194e93b26678d">Cy_MCWDT_SetToggleBit</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, uint32_t bit)</td></tr>
<tr class="memdesc:ga038dc9c62219cdd225d194e93b26678d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a bit in Counter 2 to monitor for a toggle.  <a href="#ga038dc9c62219cdd225d194e93b26678d">More...</a><br /></td></tr>
<tr class="separator:ga038dc9c62219cdd225d194e93b26678d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f889d8699b065ea682537959d2a59d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gab0f889d8699b065ea682537959d2a59d">Cy_MCWDT_GetToggleBit</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:gab0f889d8699b065ea682537959d2a59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports which bit in Counter 2 is monitored for a toggle.  <a href="#gab0f889d8699b065ea682537959d2a59d">More...</a><br /></td></tr>
<tr class="separator:gab0f889d8699b065ea682537959d2a59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82cd9aad79c9faf18b7a5ada22c3f7d3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga82cd9aad79c9faf18b7a5ada22c3f7d3">Cy_MCWDT_GetCount</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga82cd9aad79c9faf18b7a5ada22c3f7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the current counter value of the specified counter.  <a href="#ga82cd9aad79c9faf18b7a5ada22c3f7d3">More...</a><br /></td></tr>
<tr class="separator:ga82cd9aad79c9faf18b7a5ada22c3f7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33b66c4254ceb468ecc48098b00e8c1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gac33b66c4254ceb468ecc48098b00e8c1">Cy_MCWDT_ResetCounters</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, uint32_t counters, uint16_t waitUs)</td></tr>
<tr class="memdesc:gac33b66c4254ceb468ecc48098b00e8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all specified counters.  <a href="#gac33b66c4254ceb468ecc48098b00e8c1">More...</a><br /></td></tr>
<tr class="separator:gac33b66c4254ceb468ecc48098b00e8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b294ace730b2fcbbf2d53d3685180a6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga6b294ace730b2fcbbf2d53d3685180a6">Cy_MCWDT_GetInterruptStatus</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:ga6b294ace730b2fcbbf2d53d3685180a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the state of all MCWDT interrupts.  <a href="#ga6b294ace730b2fcbbf2d53d3685180a6">More...</a><br /></td></tr>
<tr class="separator:ga6b294ace730b2fcbbf2d53d3685180a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67a5413817743fcd829028da227ad4b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gab67a5413817743fcd829028da227ad4b">Cy_MCWDT_ClearInterrupt</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, uint32_t counters)</td></tr>
<tr class="memdesc:gab67a5413817743fcd829028da227ad4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all specified MCWDT interrupts.  <a href="#gab67a5413817743fcd829028da227ad4b">More...</a><br /></td></tr>
<tr class="separator:gab67a5413817743fcd829028da227ad4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9cc0d06889d45876cac4876b865e114"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gab9cc0d06889d45876cac4876b865e114">Cy_MCWDT_SetInterrupt</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, uint32_t counters)</td></tr>
<tr class="memdesc:gab9cc0d06889d45876cac4876b865e114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets MCWDT interrupt sources in the interrupt request register.  <a href="#gab9cc0d06889d45876cac4876b865e114">More...</a><br /></td></tr>
<tr class="separator:gab9cc0d06889d45876cac4876b865e114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86bedf42a58f28a08bb8368d155a5563"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga86bedf42a58f28a08bb8368d155a5563">Cy_MCWDT_GetInterruptMask</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:ga86bedf42a58f28a08bb8368d155a5563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CWDT interrupt mask register.  <a href="#ga86bedf42a58f28a08bb8368d155a5563">More...</a><br /></td></tr>
<tr class="separator:ga86bedf42a58f28a08bb8368d155a5563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa26b488af90a877760cffc61ad08e3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gaeaa26b488af90a877760cffc61ad08e3">Cy_MCWDT_SetInterruptMask</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, uint32_t counters)</td></tr>
<tr class="memdesc:gaeaa26b488af90a877760cffc61ad08e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes MCWDT interrupt mask register.  <a href="#gaeaa26b488af90a877760cffc61ad08e3">More...</a><br /></td></tr>
<tr class="separator:gaeaa26b488af90a877760cffc61ad08e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa998a0ecd6a11e77d25abaf0cb5af37"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gaaa998a0ecd6a11e77d25abaf0cb5af37">Cy_MCWDT_GetInterruptStatusMasked</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:gaaa998a0ecd6a11e77d25abaf0cb5af37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MCWDT interrupt masked request register.  <a href="#gaaa998a0ecd6a11e77d25abaf0cb5af37">More...</a><br /></td></tr>
<tr class="separator:gaaa998a0ecd6a11e77d25abaf0cb5af37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a74c8b0934307d550ed201bb1b9fed8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga3a74c8b0934307d550ed201bb1b9fed8">Cy_MCWDT_GetLowerLimit</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base, <a class="el" href="group__group__mcwdt__enums.html#ga82c7d6c9b1da23690ddf4cb76e69d7c4">cy_en_mcwdtlowerlimit_t</a> counter)</td></tr>
<tr class="memdesc:ga3a74c8b0934307d550ed201bb1b9fed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the Lower Limit value of the specified counter.  <a href="#ga3a74c8b0934307d550ed201bb1b9fed8">More...</a><br /></td></tr>
<tr class="separator:ga3a74c8b0934307d550ed201bb1b9fed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae6c32b6cccf0dcbee4bd04c94898864"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gaae6c32b6cccf0dcbee4bd04c94898864">Cy_MCWDT_SetLowerLimit</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, <a class="el" href="group__group__mcwdt__enums.html#ga82c7d6c9b1da23690ddf4cb76e69d7c4">cy_en_mcwdtlowerlimit_t</a> counter, uint32_t lowerLimit, uint16_t waitUs)</td></tr>
<tr class="memdesc:gaae6c32b6cccf0dcbee4bd04c94898864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lower limit value for the specified counter (0 or 1).  <a href="#gaae6c32b6cccf0dcbee4bd04c94898864">More...</a><br /></td></tr>
<tr class="separator:gaae6c32b6cccf0dcbee4bd04c94898864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga325b3bb0d2404854c78908c5118c2ce4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__mcwdt__enums.html#ga480796bb60575de9a724058f2ae31e7c">cy_en_mcwdtlowerlimitmode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga325b3bb0d2404854c78908c5118c2ce4">Cy_MCWDT_GetLowerLimitMode</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base, <a class="el" href="group__group__mcwdt__enums.html#ga82c7d6c9b1da23690ddf4cb76e69d7c4">cy_en_mcwdtlowerlimit_t</a> counter)</td></tr>
<tr class="memdesc:ga325b3bb0d2404854c78908c5118c2ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the lower limit mode of the specified counter.  <a href="#ga325b3bb0d2404854c78908c5118c2ce4">More...</a><br /></td></tr>
<tr class="separator:ga325b3bb0d2404854c78908c5118c2ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbe6c4d34f78ba955484a1524ef585ea"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gafbe6c4d34f78ba955484a1524ef585ea">Cy_MCWDT_SetLowerLimitMode</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, <a class="el" href="group__group__mcwdt__enums.html#ga82c7d6c9b1da23690ddf4cb76e69d7c4">cy_en_mcwdtlowerlimit_t</a> counter, <a class="el" href="group__group__mcwdt__enums.html#ga480796bb60575de9a724058f2ae31e7c">cy_en_mcwdtlowerlimitmode_t</a> <a class="el" href="group__group__ipc__bt__data__structures.html#ga37e90f5e3bd99fac2021fb3a326607d4">mode</a>)</td></tr>
<tr class="memdesc:gafbe6c4d34f78ba955484a1524ef585ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lower limit mode option for the specified counter.  <a href="#gafbe6c4d34f78ba955484a1524ef585ea">More...</a><br /></td></tr>
<tr class="separator:gafbe6c4d34f78ba955484a1524ef585ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7049df180477872251c6bf5f979df30c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga7049df180477872251c6bf5f979df30c">Cy_MCWDT_GetLowerLimitCascaded</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:ga7049df180477872251c6bf5f979df30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets lower limit registers cascaded value.  <a href="#ga7049df180477872251c6bf5f979df30c">More...</a><br /></td></tr>
<tr class="separator:ga7049df180477872251c6bf5f979df30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93172fa1b72d328964f90325421f2f5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gaa93172fa1b72d328964f90325421f2f5">Cy_MCWDT_SetCascadeCarryOutRollOver</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, <a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a> counter, bool carryoutconfig)</td></tr>
<tr class="memdesc:gaa93172fa1b72d328964f90325421f2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Rollover mode for carryout.  <a href="#gaa93172fa1b72d328964f90325421f2f5">More...</a><br /></td></tr>
<tr class="separator:gaa93172fa1b72d328964f90325421f2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga556f4e8c658c4f4e669d186938db36f1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga556f4e8c658c4f4e669d186938db36f1">Cy_MCWDT_GetCascadeCarryOutRollOver</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base, <a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a> counter)</td></tr>
<tr class="memdesc:ga556f4e8c658c4f4e669d186938db36f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if Rollover mode enabled for carryout or not.  <a href="#ga556f4e8c658c4f4e669d186938db36f1">More...</a><br /></td></tr>
<tr class="separator:ga556f4e8c658c4f4e669d186938db36f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bd47a8cc5217f1077a92f57bac19100"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga1bd47a8cc5217f1077a92f57bac19100">Cy_MCWDT_SetCascadeMatchCombined</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *base, <a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a> counter, bool matchconfig)</td></tr>
<tr class="memdesc:ga1bd47a8cc5217f1077a92f57bac19100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the match to combined cascade counters.  <a href="#ga1bd47a8cc5217f1077a92f57bac19100">More...</a><br /></td></tr>
<tr class="separator:ga1bd47a8cc5217f1077a92f57bac19100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d105e8b26101615b50496b3c584e364"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga9d105e8b26101615b50496b3c584e364">Cy_MCWDT_GetCascadeMatchCombined</a> (<a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *base, <a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a> counter)</td></tr>
<tr class="memdesc:ga9d105e8b26101615b50496b3c584e364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports if match is enabled with combined cascade counters or not.  <a href="#ga9d105e8b26101615b50496b3c584e364">More...</a><br /></td></tr>
<tr class="separator:ga9d105e8b26101615b50496b3c584e364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1ea9a634f2e76b856d38a0c649a0c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga1b1ea9a634f2e76b856d38a0c649a0c4">Cy_MCWDT_CpuSelectForDpSlpPauseAction</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#ga56cabdb0b4e42968be47b13bbe6bebad">cy_en_mcwdt_select_core_t</a> core)</td></tr>
<tr class="memdesc:ga1b1ea9a634f2e76b856d38a0c649a0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select deep sleep of which core for pausing this counter.  <a href="#ga1b1ea9a634f2e76b856d38a0c649a0c4">More...</a><br /></td></tr>
<tr class="separator:ga1b1ea9a634f2e76b856d38a0c649a0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366d471122c4324a20bfb49b88b611f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga366d471122c4324a20bfb49b88b611f5">Cy_MCWDT_SetLowerAction</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, <a class="el" href="group__group__mcwdt__enums.html#ga57fd8960981e53e849e7c7bcf2b85797">cy_en_mcwdt_lower_upper_action_t</a> action)</td></tr>
<tr class="memdesc:ga366d471122c4324a20bfb49b88b611f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lower limit action of the specified counter.  <a href="#ga366d471122c4324a20bfb49b88b611f5">More...</a><br /></td></tr>
<tr class="separator:ga366d471122c4324a20bfb49b88b611f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad043073e808d60849d106283d3955377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gad043073e808d60849d106283d3955377">Cy_MCWDT_SetUpperAction</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, <a class="el" href="group__group__mcwdt__enums.html#ga57fd8960981e53e849e7c7bcf2b85797">cy_en_mcwdt_lower_upper_action_t</a> action)</td></tr>
<tr class="memdesc:gad043073e808d60849d106283d3955377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the upper limit action of the specified counter.  <a href="#gad043073e808d60849d106283d3955377">More...</a><br /></td></tr>
<tr class="separator:gad043073e808d60849d106283d3955377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d4361ed633c0302a39d077cfdc8d7b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga7d4361ed633c0302a39d077cfdc8d7b4">Cy_MCWDT_SetWarnAction</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, <a class="el" href="group__group__mcwdt__enums.html#ga58533cd6bd007e9a966e0c22ec228c67">cy_en_mcwdt_warn_action_t</a> action)</td></tr>
<tr class="memdesc:ga7d4361ed633c0302a39d077cfdc8d7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the warn limit action of the specified counter.  <a href="#ga7d4361ed633c0302a39d077cfdc8d7b4">More...</a><br /></td></tr>
<tr class="separator:ga7d4361ed633c0302a39d077cfdc8d7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cca2590256f5f0b6509bd45dce71941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga3cca2590256f5f0b6509bd45dce71941">Cy_MCWDT_SetSubCounter2Action</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gad2667a60c671e6f199cdbf47cf2fbeaf">cy_en_mcwdt_cnt2_action_t</a> action)</td></tr>
<tr class="memdesc:ga3cca2590256f5f0b6509bd45dce71941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the counter 2 action of the specified counter.  <a href="#ga3cca2590256f5f0b6509bd45dce71941">More...</a><br /></td></tr>
<tr class="separator:ga3cca2590256f5f0b6509bd45dce71941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e5cc99601e7590a206211c24381db8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__mcwdt__enums.html#ga57fd8960981e53e849e7c7bcf2b85797">cy_en_mcwdt_lower_upper_action_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga19e5cc99601e7590a206211c24381db8">Cy_MCWDT_GetLowerAction</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga19e5cc99601e7590a206211c24381db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the lower limit action type of the specified counter.  <a href="#ga19e5cc99601e7590a206211c24381db8">More...</a><br /></td></tr>
<tr class="separator:ga19e5cc99601e7590a206211c24381db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71678baab1ad3f68a2a11bfb0a4a6f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__mcwdt__enums.html#ga57fd8960981e53e849e7c7bcf2b85797">cy_en_mcwdt_lower_upper_action_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga71678baab1ad3f68a2a11bfb0a4a6f40">Cy_MCWDT_GetUpperAction</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga71678baab1ad3f68a2a11bfb0a4a6f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the upper limit action type of the specified counter.  <a href="#ga71678baab1ad3f68a2a11bfb0a4a6f40">More...</a><br /></td></tr>
<tr class="separator:ga71678baab1ad3f68a2a11bfb0a4a6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cd37cd4d24b8668a19f17f49b7c9631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__mcwdt__enums.html#ga58533cd6bd007e9a966e0c22ec228c67">cy_en_mcwdt_warn_action_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga6cd37cd4d24b8668a19f17f49b7c9631">Cy_MCWDT_GetWarnAction</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga6cd37cd4d24b8668a19f17f49b7c9631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the warn limit action type of the specified counter.  <a href="#ga6cd37cd4d24b8668a19f17f49b7c9631">More...</a><br /></td></tr>
<tr class="separator:ga6cd37cd4d24b8668a19f17f49b7c9631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea81605e48bf608162140af9ea258d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__mcwdt__enums.html#gad2667a60c671e6f199cdbf47cf2fbeaf">cy_en_mcwdt_cnt2_action_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga6ea81605e48bf608162140af9ea258d7">Cy_MCWDT_GetSubCounter2Action</a> (MCWDT_Type *base)</td></tr>
<tr class="memdesc:ga6ea81605e48bf608162140af9ea258d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the counter 2 action type of the specified counter.  <a href="#ga6ea81605e48bf608162140af9ea258d7">More...</a><br /></td></tr>
<tr class="separator:ga6ea81605e48bf608162140af9ea258d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04d9c4538fc41df99f95c86545fa9f60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga04d9c4538fc41df99f95c86545fa9f60">Cy_MCWDT_SetAutoService</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, uint32_t enable)</td></tr>
<tr class="memdesc:ga04d9c4538fc41df99f95c86545fa9f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Auto service option for the specified counter.  <a href="#ga04d9c4538fc41df99f95c86545fa9f60">More...</a><br /></td></tr>
<tr class="separator:ga04d9c4538fc41df99f95c86545fa9f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe194dcc78fc8bd3c06f97464fef632"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga5fe194dcc78fc8bd3c06f97464fef632">Cy_MCWDT_GetAutoService</a> (MCWDT_Type const *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga5fe194dcc78fc8bd3c06f97464fef632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the Auto service setting for the specified counter.  <a href="#ga5fe194dcc78fc8bd3c06f97464fef632">More...</a><br /></td></tr>
<tr class="separator:ga5fe194dcc78fc8bd3c06f97464fef632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034fcbb8cca5d6de3a451f622e5717d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga034fcbb8cca5d6de3a451f622e5717d0">Cy_MCWDT_GetSleepDeepPause</a> (MCWDT_Type const *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga034fcbb8cca5d6de3a451f622e5717d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the Sleep deep pause setting for the specified counter.  <a href="#ga034fcbb8cca5d6de3a451f622e5717d0">More...</a><br /></td></tr>
<tr class="separator:ga034fcbb8cca5d6de3a451f622e5717d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabba3ba56c68c48950212dc6d20956bd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gabba3ba56c68c48950212dc6d20956bd2">Cy_MCWDT_SetSleepDeepPause</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, uint32_t enable)</td></tr>
<tr class="memdesc:gabba3ba56c68c48950212dc6d20956bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Sleep deep pause option for the specified counter.  <a href="#gabba3ba56c68c48950212dc6d20956bd2">More...</a><br /></td></tr>
<tr class="separator:gabba3ba56c68c48950212dc6d20956bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36e5f597079178fa716e8610507d888c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga36e5f597079178fa716e8610507d888c">Cy_MCWDT_SetDebugRun</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, uint32_t enable)</td></tr>
<tr class="memdesc:ga36e5f597079178fa716e8610507d888c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Debug run option for the specified counter.  <a href="#ga36e5f597079178fa716e8610507d888c">More...</a><br /></td></tr>
<tr class="separator:ga36e5f597079178fa716e8610507d888c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30fc627ed06db95b32b6c7f7d74ac7e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gaf30fc627ed06db95b32b6c7f7d74ac7e">Cy_MCWDT_GetDebugRun</a> (MCWDT_Type const *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:gaf30fc627ed06db95b32b6c7f7d74ac7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the Debug run setting for the specified counter.  <a href="#gaf30fc627ed06db95b32b6c7f7d74ac7e">More...</a><br /></td></tr>
<tr class="separator:gaf30fc627ed06db95b32b6c7f7d74ac7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f78aaf66e50a71ff8832f9e1546edeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga2f78aaf66e50a71ff8832f9e1546edeb">Cy_MCWDT_SetLowerLimit</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, uint16_t limit, uint16_t waitUs)</td></tr>
<tr class="memdesc:ga2f78aaf66e50a71ff8832f9e1546edeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lower limit value for the specified counter (0 or 1).  <a href="#ga2f78aaf66e50a71ff8832f9e1546edeb">More...</a><br /></td></tr>
<tr class="separator:ga2f78aaf66e50a71ff8832f9e1546edeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189e0fc8639485938c9bec90ab7d2ea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga189e0fc8639485938c9bec90ab7d2ea6">Cy_MCWDT_SetUpperLimit</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, uint16_t limit, uint16_t waitUs)</td></tr>
<tr class="memdesc:ga189e0fc8639485938c9bec90ab7d2ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the upper limit value for the specified counter (0 or 1).  <a href="#ga189e0fc8639485938c9bec90ab7d2ea6">More...</a><br /></td></tr>
<tr class="separator:ga189e0fc8639485938c9bec90ab7d2ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7010d2642420171c8c53f9165cbb3be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga7010d2642420171c8c53f9165cbb3be0">Cy_MCWDT_SetWarnLimit</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter, uint16_t limit, uint16_t waitUs)</td></tr>
<tr class="memdesc:ga7010d2642420171c8c53f9165cbb3be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the warn limit value for the specified counter (0 or 1).  <a href="#ga7010d2642420171c8c53f9165cbb3be0">More...</a><br /></td></tr>
<tr class="separator:ga7010d2642420171c8c53f9165cbb3be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad05cf6c4a4b7c1bef71b9f1a84f53b3f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gad05cf6c4a4b7c1bef71b9f1a84f53b3f">Cy_MCWDT_GetUpperLimit</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:gad05cf6c4a4b7c1bef71b9f1a84f53b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the upper limit comparison value for the specified counter (0 or 1).  <a href="#gad05cf6c4a4b7c1bef71b9f1a84f53b3f">More...</a><br /></td></tr>
<tr class="separator:gad05cf6c4a4b7c1bef71b9f1a84f53b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e08c92f6ce86bd1089c4c5eecf7635b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga4e08c92f6ce86bd1089c4c5eecf7635b">Cy_MCWDT_GetWarnLimit</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga4e08c92f6ce86bd1089c4c5eecf7635b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the warn limit comparison value for the specified counter (0 or 1).  <a href="#ga4e08c92f6ce86bd1089c4c5eecf7635b">More...</a><br /></td></tr>
<tr class="separator:ga4e08c92f6ce86bd1089c4c5eecf7635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070d6f92c33d9be8774711e690dffc0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga070d6f92c33d9be8774711e690dffc0b">Cy_MCWDT_WaitForCounterReset</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga070d6f92c33d9be8774711e690dffc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait completion of counter reset.  <a href="#ga070d6f92c33d9be8774711e690dffc0b">More...</a><br /></td></tr>
<tr class="separator:ga070d6f92c33d9be8774711e690dffc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4cf6e7d3f3ceb9c729d04e07320d2c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#gac4cf6e7d3f3ceb9c729d04e07320d2c5">Cy_MCWDT_ClearWatchdog</a> (MCWDT_Type *base, uint32_t counters)</td></tr>
<tr class="memdesc:gac4cf6e7d3f3ceb9c729d04e07320d2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the MC watchdog counter, to prevent a XRES device reset or fault.  <a href="#gac4cf6e7d3f3ceb9c729d04e07320d2c5">More...</a><br /></td></tr>
<tr class="separator:gac4cf6e7d3f3ceb9c729d04e07320d2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga544d034462bd37c41e841570448a310f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mcwdt__functions.html#ga544d034462bd37c41e841570448a310f">Cy_MCWDT_GetLowerLimit</a> (MCWDT_Type *base, <a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a> counter)</td></tr>
<tr class="memdesc:ga544d034462bd37c41e841570448a310f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the lower limit comparison value for the specified counter (0 or 1).  <a href="#ga544d034462bd37c41e841570448a310f">More...</a><br /></td></tr>
<tr class="separator:ga544d034462bd37c41e841570448a310f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab8bd6fb7ec48ef294287c01e179c41df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8bd6fb7ec48ef294287c01e179c41df">&#9670;&nbsp;</a></span>Cy_MCWDT_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mcwdt__enums.html#gac983f45895a641f98b9b887e453a8a5d">cy_en_mcwdt_status_t</a> Cy_MCWDT_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__mcwdt__config__t.html">cy_stc_mcwdt_config_t</a> const *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the MCWDT block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes the registers.</td></tr>
    <tr><td class="paramname">config</td><td>The pointer to a structure that contains component configuration data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_mcwdt_status_t *base checking result. If the pointer is NULL, returns error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API should not be called when the counters are running. Prior to calling this API the counter should be disabled. </dd></dl>

</div>
</div>
<a id="gacfa316d17f65aea2cf6ae6f078453549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfa316d17f65aea2cf6ae6f078453549">&#9670;&nbsp;</a></span>Cy_MCWDT_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initializes the MCWDT block, returns register values to their default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes the registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API should not be called when the counters are running. Prior to calling this API the counter should be disabled. </dd></dl>

</div>
</div>
<a id="ga90f8d4636fc67fc8abe3bfd87ab521ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90f8d4636fc67fc8abe3bfd87ab521ac">&#9670;&nbsp;</a></span>Cy_MCWDT_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables all specified counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all counters to enable. See the <a class="el" href="group__group__mcwdt__macros.html#gadb87c7b323120f1297143824fd7cded7">CY_MCWDT_CTR0</a>, CY_MCWDT_CTR1, and CY_MCWDT_CTR2 macros.</td></tr>
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because the counter begins counting after two lf_clk cycles pass. The recommended value is 93 us. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. In this case, it is the user's responsibility to check whether the selected counters were enabled immediately after the function call. This can be done by the <a class="el" href="group__group__mcwdt__functions.html#gaf0a0ff9cf9f6389150122f2e4e0af9b3" title="Reports the enabled status of the specified counter. ">Cy_MCWDT_GetEnabledStatus()</a> API. </dd></dl>

</div>
</div>
<a id="ga9ecaccda05008638b249cacd1cf9ea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ecaccda05008638b249cacd1cf9ea9c">&#9670;&nbsp;</a></span>Cy_MCWDT_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables all specified counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure describing registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all counters to disable. See the <a class="el" href="group__group__mcwdt__macros.html#gadb87c7b323120f1297143824fd7cded7">CY_MCWDT_CTR0</a>, CY_MCWDT_CTR1, and CY_MCWDT_CTR2 macros.</td></tr>
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because the counter stops counting after two lf_clk cycles pass. The recommended value is 93 us. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. In this case, it is the user's responsibility to check whether the selected counters were disabled immediately after the function call. This can be done by the <a class="el" href="group__group__mcwdt__functions.html#gaf0a0ff9cf9f6389150122f2e4e0af9b3" title="Reports the enabled status of the specified counter. ">Cy_MCWDT_GetEnabledStatus()</a> API. </dd></dl>

</div>
</div>
<a id="gaf0a0ff9cf9f6389150122f2e4e0af9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0a0ff9cf9f6389150122f2e4e0af9b3">&#9670;&nbsp;</a></span>Cy_MCWDT_GetEnabledStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetEnabledStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the enabled status of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the MCWDT counter. The valid range is [0-2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the MCWDT counter: 0 = disabled, 1 = enabled. </dd></dl>

</div>
</div>
<a id="ga4b6d812cb7c3984fd63f087415b24279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b6d812cb7c3984fd63f087415b24279">&#9670;&nbsp;</a></span>Cy_MCWDT_Lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_Lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks out configuration changes to all MCWDT registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1433c7f1fc62caf1c7697b0e2f20fef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1433c7f1fc62caf1c7697b0e2f20fef0">&#9670;&nbsp;</a></span>Cy_MCWDT_Unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_Unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks the MCWDT configuration registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7178ccb7c11988aa5597d128bacd9bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7178ccb7c11988aa5597d128bacd9bb3">&#9670;&nbsp;</a></span>Cy_MCWDT_GetLockedStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetLockedStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the locked/unlocked state of the MCWDT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state of the MCWDT counter: 0 = unlocked, 1 = locked. </dd></dl>

</div>
</div>
<a id="ga6f5ff22771e9c3a5203d154842f4e339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f5ff22771e9c3a5203d154842f4e339">&#9670;&nbsp;</a></span>Cy_MCWDT_SetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaa3ab9dd24dfec93a9982f06b5d7f0221">cy_en_mcwdtmode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the mode of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-2].</td></tr>
    <tr><td class="paramname">mode</td><td>The mode of operation for the counter. See enum typedef cy_en_mcwdtmode_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The mode for Counter 2 can be set only to CY_MCWDT_MODE_NONE or CY_MCWDT_MODE_INT.</dd>
<dd>
This API must not be called while the counters are running. Prior to calling this API, the counter must be disabled.</dd>
<dd>
This API is available for CAT1A, CAT1B and CAT1D devices. </dd></dl>

</div>
</div>
<a id="ga70dfa889ac1ea76ed7dd84149182f634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70dfa889ac1ea76ed7dd84149182f634">&#9670;&nbsp;</a></span>Cy_MCWDT_GetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__mcwdt__enums.html#gaa3ab9dd24dfec93a9982f06b5d7f0221">cy_en_mcwdtmode_t</a> Cy_MCWDT_GetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the mode of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current mode of the counter. See enum typedef cy_en_mcwdtmode_t.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1A, CAT1B and CAT1D devices. </dd></dl>

</div>
</div>
<a id="ga77bb788adb7fac2042772b00a61f95cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77bb788adb7fac2042772b00a61f95cb">&#9670;&nbsp;</a></span>Cy_MCWDT_SetClearOnMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetClearOnMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Clear on match option for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The match values are not supported by Counter 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Set 0 to disable; 1 to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called while the counters are running. Prior to calling this API, the counter must be disabled.</dd>
<dd>
This API is available for CAT1A, CAT1B and CAT1D devices. </dd></dl>

</div>
</div>
<a id="gab443fb0e7d74e1a038ad24b90fedb22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab443fb0e7d74e1a038ad24b90fedb22e">&#9670;&nbsp;</a></span>Cy_MCWDT_GetClearOnMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetClearOnMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the Clear on match setting for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Clear on match status: 1 = enabled, 0 = disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The match value is not supported by Counter 2.</dd>
<dd>
This API is available for CAT1A, CAT1B and CAT1D devices. </dd></dl>

</div>
</div>
<a id="gaca650f48c11727f9e5a7f31a5fcb11b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca650f48c11727f9e5a7f31a5fcb11b2">&#9670;&nbsp;</a></span>Cy_MCWDT_SetCascade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetCascade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a>&#160;</td>
          <td class="paramname"><em>cascade</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all the counter cascade options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">cascade</td><td>Sets or clears each of the cascade options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called when the counters are running. Prior to calling this API, the counter must be disabled.</dd>
<dd>
This API is available for CAT1A, CAT1B and CAT1D devices. </dd></dl>

</div>
</div>
<a id="ga800189be8d7308f4227fb1e4d43d6dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga800189be8d7308f4227fb1e4d43d6dc4">&#9670;&nbsp;</a></span>Cy_MCWDT_GetCascade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a> Cy_MCWDT_GetCascade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports all the counter cascade option settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current cascade option values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1A, CAT1B and CAT1D devices. </dd></dl>

</div>
</div>
<a id="gaf0a50c23172825fb65c2f2bb4fea61eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0a50c23172825fb65c2f2bb4fea61eb">&#9670;&nbsp;</a></span>Cy_MCWDT_SetMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the match comparison value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
    <tr><td class="paramname">match</td><td>The value to match against the counter. The valid range is [0-65535] for c0ClearOnMatch (or c1ClearOnMatch) = 0 and [1-65535] for c0ClearOnMatch (or c1ClearOnMatch) = 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The match value is not supported by Counter 2.</dd>
<dd>
Action on match is taken on the next increment after the counter value equal to match value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because the match affects after two lf_clk cycles pass. The recommended value is 93 us. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. This must be taken into account when changing the match values on the running counters.</dd>
<dd>
This API is available for CAT1A, CAT1B and CAT1D devices. </dd></dl>

</div>
</div>
<a id="ga478fe2fb91d122511d5805eabe7cbb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga478fe2fb91d122511d5805eabe7cbb97">&#9670;&nbsp;</a></span>Cy_MCWDT_GetMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the match comparison value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The match values are not supported by Counter 2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit match value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1A, CAT1B and CAT1D devices. </dd></dl>

</div>
</div>
<a id="ga2c7f8cc4f0897618bb6c4b3389357086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c7f8cc4f0897618bb6c4b3389357086">&#9670;&nbsp;</a></span>Cy_MCWDT_GetCountCascaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_MCWDT_GetCountCascaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the current value of combined C1-C0 cascaded counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes the registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The user must enable both counters, and cascade C0 to C1, before calling this function. C2 is not reported. Instead, to get a 64-bit C2-C1-C0 cascaded value, the user must call this function followed by Cy_MCWDT_GetCount(base, CY_MCWDT_COUNTER2), and then combine the results. </dd>
<dd>
This function does not return the correct result when it is called after the <a class="el" href="group__group__mcwdt__functions.html#ga90f8d4636fc67fc8abe3bfd87ab521ac" title="Enables all specified counters. ">Cy_MCWDT_Enable()</a> or <a class="el" href="group__group__mcwdt__functions.html#gac33b66c4254ceb468ecc48098b00e8c1" title="Resets all specified counters. ">Cy_MCWDT_ResetCounters()</a> function with a delay less than two lf_clk cycles. The recommended waitUs parameter value is 100 us.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The value of combined C1-C0 cascaded counters. </dd></dl>

</div>
</div>
<a id="ga038dc9c62219cdd225d194e93b26678d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga038dc9c62219cdd225d194e93b26678d">&#9670;&nbsp;</a></span>Cy_MCWDT_SetToggleBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetToggleBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a bit in Counter 2 to monitor for a toggle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">bit</td><td>The Counter 2 bit is set to monitor for a toggle. The valid range [0-31].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called when counters are running. Prior to calling this API, the counter must be disabled. </dd></dl>

</div>
</div>
<a id="gab0f889d8699b065ea682537959d2a59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0f889d8699b065ea682537959d2a59d">&#9670;&nbsp;</a></span>Cy_MCWDT_GetToggleBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetToggleBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports which bit in Counter 2 is monitored for a toggle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit that is monitored (range 0 to 31). </dd></dl>

</div>
</div>
<a id="ga82cd9aad79c9faf18b7a5ada22c3f7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82cd9aad79c9faf18b7a5ada22c3f7d3">&#9670;&nbsp;</a></span>Cy_MCWDT_GetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the current counter value of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A live counter value. Counters 0 and 1 are 16-bit counters and Counter 2 is a 32-bit counter. </dd></dl>

</div>
</div>
<a id="gac33b66c4254ceb468ecc48098b00e8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac33b66c4254ceb468ecc48098b00e8c1">&#9670;&nbsp;</a></span>Cy_MCWDT_ResetCounters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_ResetCounters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all specified counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all counters to reset. See the <a class="el" href="group__group__mcwdt__macros.html#gadb87c7b323120f1297143824fd7cded7">CY_MCWDT_CTR0</a>, CY_MCWDT_CTR1, and CY_MCWDT_CTR2 macros.</td></tr>
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because a reset occurs after one lf_clk cycle passes. The recommended value is 62 us. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function resets the counters two times to prevent the case when the Counter 1 is not reset when the counters are cascaded. The delay waitUs must be greater than 100 us when the counters are cascaded. The total delay is greater than 2*waitUs because the function has the delay after the first reset. </dd>
<dd>
Setting this parameter to a zero means No wait. In this case, it is the user's responsibility to check whether the selected counters were reset immediately after the function call. This can be done by the <a class="el" href="group__group__mcwdt__functions.html#ga82cd9aad79c9faf18b7a5ada22c3f7d3" title="Reports the current counter value of the specified counter. ">Cy_MCWDT_GetCount()</a> API.</dd>
<dd>
For CAT1C devices, only CY_MCWDT_CTR0 and CY_MCWDT_CTR1 can be Reset. </dd></dl>

</div>
</div>
<a id="ga6b294ace730b2fcbbf2d53d3685180a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b294ace730b2fcbbf2d53d3685180a6">&#9670;&nbsp;</a></span>Cy_MCWDT_GetInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the state of all MCWDT interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The OR'd state of the interrupts. See the <a class="el" href="group__group__mcwdt__macros.html#gadb87c7b323120f1297143824fd7cded7">CY_MCWDT_CTR0</a>, CY_MCWDT_CTR1, and CY_MCWDT_CTR2 macros. </dd></dl>

</div>
</div>
<a id="gab67a5413817743fcd829028da227ad4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67a5413817743fcd829028da227ad4b">&#9670;&nbsp;</a></span>Cy_MCWDT_ClearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all specified MCWDT interrupts. </p>
<p>All the WDT interrupts must be cleared by the firmware; otherwise interrupts are generated continuously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure describes registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all interrupt sources to clear. See the <a class="el" href="group__group__mcwdt__macros.html#gadb87c7b323120f1297143824fd7cded7">CY_MCWDT_CTR0</a>, CY_MCWDT_CTR1, and CY_MCWDT_CTR2 macros. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab9cc0d06889d45876cac4876b865e114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9cc0d06889d45876cac4876b865e114">&#9670;&nbsp;</a></span>Cy_MCWDT_SetInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets MCWDT interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all interrupt sources to set. See the <a class="el" href="group__group__mcwdt__macros.html#gadb87c7b323120f1297143824fd7cded7">CY_MCWDT_CTR0</a>, CY_MCWDT_CTR1, and CY_MCWDT_CTR2 macros. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86bedf42a58f28a08bb8368d155a5563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86bedf42a58f28a08bb8368d155a5563">&#9670;&nbsp;</a></span>Cy_MCWDT_GetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the CWDT interrupt mask register. </p>
<p>This register specifies which bits from the MCWDT interrupt request register will trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The OR'd state of the interrupt masks. See the <a class="el" href="group__group__mcwdt__macros.html#gadb87c7b323120f1297143824fd7cded7">CY_MCWDT_CTR0</a>, CY_MCWDT_CTR1, and CY_MCWDT_CTR2 macros. </dd></dl>

</div>
</div>
<a id="gaeaa26b488af90a877760cffc61ad08e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa26b488af90a877760cffc61ad08e3">&#9670;&nbsp;</a></span>Cy_MCWDT_SetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes MCWDT interrupt mask register. </p>
<p>This register configures which bits from MCWDT interrupt request register will trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all interrupt masks to set. See <a class="el" href="group__group__mcwdt__macros.html#gadb87c7b323120f1297143824fd7cded7">CY_MCWDT_CTR0</a>, CY_MCWDT_CTR1, and CY_MCWDT_CTR2 macros. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa998a0ecd6a11e77d25abaf0cb5af37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa998a0ecd6a11e77d25abaf0cb5af37">&#9670;&nbsp;</a></span>Cy_MCWDT_GetInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MCWDT interrupt masked request register. </p>
<p>This register contains the logical AND of corresponding bits from the MCWDT interrupt request and mask registers. In the interrupt service routine, this function identifies which of the enabled MCWDT interrupt sources caused an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of enabled MCWDT interrupt sources. See the <a class="el" href="group__group__mcwdt__macros.html#gadb87c7b323120f1297143824fd7cded7">CY_MCWDT_CTR0</a>, CY_MCWDT_CTR1, and CY_MCWDT_CTR2 macros. </dd></dl>

</div>
</div>
<a id="ga3a74c8b0934307d550ed201bb1b9fed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a74c8b0934307d550ed201bb1b9fed8">&#9670;&nbsp;</a></span>Cy_MCWDT_GetLowerLimit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetLowerLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga82c7d6c9b1da23690ddf4cb76e69d7c4">cy_en_mcwdtlowerlimit_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the Lower Limit value of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Lower Limit value. Counters 0 and 1 are 16-bit counters.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1B devices. </dd></dl>

</div>
</div>
<a id="gaae6c32b6cccf0dcbee4bd04c94898864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae6c32b6cccf0dcbee4bd04c94898864">&#9670;&nbsp;</a></span>Cy_MCWDT_SetLowerLimit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetLowerLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga82c7d6c9b1da23690ddf4cb76e69d7c4">cy_en_mcwdtlowerlimit_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lowerLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the lower limit value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
    <tr><td class="paramname">lowerLimit</td><td>The value to be written in the lower limit register The valid range is [0-65535] for c0 and [1-65535] for c1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The lower limit mode is not supported by Counter 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because the lower limit register write affects after two lf_clk cycles pass. The recommended value is 93 us. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. This must be taken into account when changing the lower limit register values.</dd>
<dd>
This API is available for CAT1B devices. </dd></dl>

</div>
</div>
<a id="ga325b3bb0d2404854c78908c5118c2ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga325b3bb0d2404854c78908c5118c2ce4">&#9670;&nbsp;</a></span>Cy_MCWDT_GetLowerLimitMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__mcwdt__enums.html#ga480796bb60575de9a724058f2ae31e7c">cy_en_mcwdtlowerlimitmode_t</a> Cy_MCWDT_GetLowerLimitMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga82c7d6c9b1da23690ddf4cb76e69d7c4">cy_en_mcwdtlowerlimit_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the lower limit mode of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current lower limit mode of the counter. See enum typedef cy_en_mcwdtlowerlimitmode_t.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1B devices. </dd></dl>

</div>
</div>
<a id="gafbe6c4d34f78ba955484a1524ef585ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbe6c4d34f78ba955484a1524ef585ea">&#9670;&nbsp;</a></span>Cy_MCWDT_SetLowerLimitMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetLowerLimitMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga82c7d6c9b1da23690ddf4cb76e69d7c4">cy_en_mcwdtlowerlimit_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga480796bb60575de9a724058f2ae31e7c">cy_en_mcwdtlowerlimitmode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the lower limit mode option for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The lower limit mode is not supported by Counter 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Set 0 - Do nothing, 1 - Assert WDT_INTx, 2 - Assert WDT Reset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called while the counters are running. Prior to calling this API, the counter must be disabled. This API is available for CAT1B devices. </dd></dl>

</div>
</div>
<a id="ga7049df180477872251c6bf5f979df30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7049df180477872251c6bf5f979df30c">&#9670;&nbsp;</a></span>Cy_MCWDT_GetLowerLimitCascaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MCWDT_GetLowerLimitCascaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets lower limit registers cascaded value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The lower limit mode is not supported by Counter 2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit lower limit register value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1B devices. </dd></dl>

</div>
</div>
<a id="gaa93172fa1b72d328964f90325421f2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa93172fa1b72d328964f90325421f2f5">&#9670;&nbsp;</a></span>Cy_MCWDT_SetCascadeCarryOutRollOver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetCascadeCarryOutRollOver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>carryoutconfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Rollover mode for carryout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The cascaded counter type. The valid cascaded type is either C0C1 or C1C2.</td></tr>
    <tr><td class="paramname">carryoutconfig</td><td>For CY_MCWDT_CASCADE_C0C1: FALSE: carry out on counter 0 match TRUE: carry out on counter 0 rollover. For CY_MCWDT_CASCADE_C1C2: FALSE: carry out on counter 1 match TRUE: carry out on counter 1 rollover.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1B devices. </dd></dl>

</div>
</div>
<a id="ga556f4e8c658c4f4e669d186938db36f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga556f4e8c658c4f4e669d186938db36f1">&#9670;&nbsp;</a></span>Cy_MCWDT_GetCascadeCarryOutRollOver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_MCWDT_GetCascadeCarryOutRollOver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if Rollover mode enabled for carryout or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The cascaded counter type. The valid cascaded type is either C0C1 or C1C2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True : Rollover Enabled False : Rollover Disabled</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1B devices. </dd></dl>

</div>
</div>
<a id="ga1bd47a8cc5217f1077a92f57bac19100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bd47a8cc5217f1077a92f57bac19100">&#9670;&nbsp;</a></span>Cy_MCWDT_SetCascadeMatchCombined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MCWDT_SetCascadeMatchCombined </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>matchconfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the match to combined cascade counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The cascaded counter type. The valid cascaded type is either C0C1 or C1C2.</td></tr>
    <tr><td class="paramname">matchconfig</td><td>For CY_MCWDT_CASCADE_C0C1: FALSE: Match based on counter 1 alone TRUE: Match based on counter 1 and counter 0 matching simultaneously For CY_MCWDT_CASCADE_C1C2: FALSE: Match based on counter 2 alone TRUE: Match based on counter 2 and counter 1 matching simultaneously</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1B devices. </dd></dl>

</div>
</div>
<a id="ga9d105e8b26101615b50496b3c584e364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d105e8b26101615b50496b3c584e364">&#9670;&nbsp;</a></span>Cy_MCWDT_GetCascadeMatchCombined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_MCWDT_GetCascadeMatchCombined </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_c_w_d_t___s_t_r_u_c_t___type.html">MCWDT_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga5839a43ea48c22508e74388c2215b887">cy_en_mcwdtcascade_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports if match is enabled with combined cascade counters or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The cascaded counter type. The valid cascaded type is either C0C1 or C1C2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True : Combined match is enabled False : Combined match is disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1B devices. </dd></dl>

</div>
</div>
<a id="ga1b1ea9a634f2e76b856d38a0c649a0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1ea9a634f2e76b856d38a0c649a0c4">&#9670;&nbsp;</a></span>Cy_MCWDT_CpuSelectForDpSlpPauseAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_CpuSelectForDpSlpPauseAction </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga56cabdb0b4e42968be47b13bbe6bebad">cy_en_mcwdt_select_core_t</a>&#160;</td>
          <td class="paramname"><em>core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select deep sleep of which core for pausing this counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">core</td><td>The selected core. Deep sleep of the core pause this counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga366d471122c4324a20bfb49b88b611f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga366d471122c4324a20bfb49b88b611f5">&#9670;&nbsp;</a></span>Cy_MCWDT_SetLowerAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_SetLowerAction </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga57fd8960981e53e849e7c7bcf2b85797">cy_en_mcwdt_lower_upper_action_t</a>&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the lower limit action of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
    <tr><td class="paramname">action</td><td>The action of operation for the counter. See enum typedef cy_en_mcwdt_lower_upper_action_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called while the counters are running. Prior to calling this API, the counter must be disabled.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gad043073e808d60849d106283d3955377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad043073e808d60849d106283d3955377">&#9670;&nbsp;</a></span>Cy_MCWDT_SetUpperAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_SetUpperAction </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga57fd8960981e53e849e7c7bcf2b85797">cy_en_mcwdt_lower_upper_action_t</a>&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the upper limit action of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
    <tr><td class="paramname">action</td><td>The action of operation for the counter. See enum typedef cy_en_mcwdt_lower_upper_action_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called while the counters are running. Prior to calling this API, the counter must be disabled.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga7d4361ed633c0302a39d077cfdc8d7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d4361ed633c0302a39d077cfdc8d7b4">&#9670;&nbsp;</a></span>Cy_MCWDT_SetWarnAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_SetWarnAction </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#ga58533cd6bd007e9a966e0c22ec228c67">cy_en_mcwdt_warn_action_t</a>&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the warn limit action of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
    <tr><td class="paramname">action</td><td>The action of operation for the counter. See enum typedef cy_en_mcwdt_warn_action_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called while the counters are running. Prior to calling this API, the counter must be disabled.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga3cca2590256f5f0b6509bd45dce71941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cca2590256f5f0b6509bd45dce71941">&#9670;&nbsp;</a></span>Cy_MCWDT_SetSubCounter2Action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_SetSubCounter2Action </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gad2667a60c671e6f199cdbf47cf2fbeaf">cy_en_mcwdt_cnt2_action_t</a>&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the counter 2 action of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">action</td><td>The action of operation for the counter. See enum typedef cy_en_mcwdt_cnt2_action_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called while the counters are running. Prior to calling this API, the counter must be disabled.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga19e5cc99601e7590a206211c24381db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19e5cc99601e7590a206211c24381db8">&#9670;&nbsp;</a></span>Cy_MCWDT_GetLowerAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mcwdt__enums.html#ga57fd8960981e53e849e7c7bcf2b85797">cy_en_mcwdt_lower_upper_action_t</a> Cy_MCWDT_GetLowerAction </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the lower limit action type of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current lower limit action type of the counter. See enum typedef cy_en_mcwdt_lower_upper_action_t.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga71678baab1ad3f68a2a11bfb0a4a6f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71678baab1ad3f68a2a11bfb0a4a6f40">&#9670;&nbsp;</a></span>Cy_MCWDT_GetUpperAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mcwdt__enums.html#ga57fd8960981e53e849e7c7bcf2b85797">cy_en_mcwdt_lower_upper_action_t</a> Cy_MCWDT_GetUpperAction </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the upper limit action type of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current upper limit action type of the counter. See enum typedef cy_en_mcwdt_lower_upper_action_t.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga6cd37cd4d24b8668a19f17f49b7c9631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cd37cd4d24b8668a19f17f49b7c9631">&#9670;&nbsp;</a></span>Cy_MCWDT_GetWarnAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mcwdt__enums.html#ga58533cd6bd007e9a966e0c22ec228c67">cy_en_mcwdt_warn_action_t</a> Cy_MCWDT_GetWarnAction </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the warn limit action type of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current warn limit action type of the counter. See enum typedef cy_en_mcwdt_warn_action_t.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga6ea81605e48bf608162140af9ea258d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea81605e48bf608162140af9ea258d7">&#9670;&nbsp;</a></span>Cy_MCWDT_GetSubCounter2Action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mcwdt__enums.html#gad2667a60c671e6f199cdbf47cf2fbeaf">cy_en_mcwdt_cnt2_action_t</a> Cy_MCWDT_GetSubCounter2Action </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the counter 2 action type of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current counter 2 action type of the counter. See enum typedef cy_en_mcwdt_cnt2_action_t.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga04d9c4538fc41df99f95c86545fa9f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04d9c4538fc41df99f95c86545fa9f60">&#9670;&nbsp;</a></span>Cy_MCWDT_SetAutoService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_SetAutoService </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Auto service option for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The auto service option is not supported by Counter 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Set 0 to disable; 1 to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called while the counters are running. Prior to calling this API, the counter must be disabled.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga5fe194dcc78fc8bd3c06f97464fef632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fe194dcc78fc8bd3c06f97464fef632">&#9670;&nbsp;</a></span>Cy_MCWDT_GetAutoService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_MCWDT_GetAutoService </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the Auto service setting for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Auto service status: 1 = enabled, 0 = disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The Auto service option is not supported by Counter 2.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga034fcbb8cca5d6de3a451f622e5717d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga034fcbb8cca5d6de3a451f622e5717d0">&#9670;&nbsp;</a></span>Cy_MCWDT_GetSleepDeepPause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_MCWDT_GetSleepDeepPause </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the Sleep deep pause setting for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Auto service status: 1 = enabled, 0 = disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gabba3ba56c68c48950212dc6d20956bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabba3ba56c68c48950212dc6d20956bd2">&#9670;&nbsp;</a></span>Cy_MCWDT_SetSleepDeepPause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_SetSleepDeepPause </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Sleep deep pause option for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-2].</td></tr>
    <tr><td class="paramname">enable</td><td>Set 0 to disable; 1 to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called while the counters are running. Prior to calling this API, the counter must be disabled.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga36e5f597079178fa716e8610507d888c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36e5f597079178fa716e8610507d888c">&#9670;&nbsp;</a></span>Cy_MCWDT_SetDebugRun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_SetDebugRun </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Debug run option for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-2].</td></tr>
    <tr><td class="paramname">enable</td><td>Set 0 to disable; 1 to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API must not be called while the counters are running. Prior to calling this API, the counter must be disabled.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gaf30fc627ed06db95b32b6c7f7d74ac7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf30fc627ed06db95b32b6c7f7d74ac7e">&#9670;&nbsp;</a></span>Cy_MCWDT_GetDebugRun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_MCWDT_GetDebugRun </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the Debug run setting for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Auto service status: 1 = enabled, 0 = disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga2f78aaf66e50a71ff8832f9e1546edeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f78aaf66e50a71ff8832f9e1546edeb">&#9670;&nbsp;</a></span>Cy_MCWDT_SetLowerLimit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_SetLowerLimit </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the lower limit value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
    <tr><td class="paramname">limit</td><td>The value to lower limit against the counter. The valid range is [0-65535] when Auto service is disabled and [1-65535] when Auto service enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The lower limit value is not supported by Counter 2.</dd>
<dd>
Action on lower limit is taken on the next increment after the counter value equal to lower limit value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because the match affects after two lf_clk cycles pass. The recommended value is 93 us. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. This must be taken into account when changing the match values on the running counters.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga189e0fc8639485938c9bec90ab7d2ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga189e0fc8639485938c9bec90ab7d2ea6">&#9670;&nbsp;</a></span>Cy_MCWDT_SetUpperLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_SetUpperLimit </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the upper limit value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
    <tr><td class="paramname">limit</td><td>The value to upper limit against the counter. The valid range is [0-65535] when Auto service is disabled and [1-65535] when Auto service enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The upper limit value is not supported by Counter 2.</dd>
<dd>
Action on upper limit is taken on the next increment after the counter value equal to upper limit value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because the match affects after two lf_clk cycles pass. The recommended value is 93 us. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. This must be taken into account when changing the match values on the running counters.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga7010d2642420171c8c53f9165cbb3be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7010d2642420171c8c53f9165cbb3be0">&#9670;&nbsp;</a></span>Cy_MCWDT_SetWarnLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_SetWarnLimit </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the warn limit value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
    <tr><td class="paramname">limit</td><td>The value to warn limit against the counter. The valid range is [0-65535] when Auto service is disabled and [1-65535] when Auto service enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The warn limit value is not supported by Counter 2.</dd>
<dd>
Action on warn limit is taken on the next increment after the counter value equal to warn limit value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because the match affects after two lf_clk cycles pass. The recommended value is 93 us. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. This must be taken into account when changing the match values on the running counters.</dd>
<dd>
This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gad05cf6c4a4b7c1bef71b9f1a84f53b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad05cf6c4a4b7c1bef71b9f1a84f53b3f">&#9670;&nbsp;</a></span>Cy_MCWDT_GetUpperLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_MCWDT_GetUpperLimit </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the upper limit comparison value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The upper limit value is not supported by Counter 2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit upper limit value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga4e08c92f6ce86bd1089c4c5eecf7635b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e08c92f6ce86bd1089c4c5eecf7635b">&#9670;&nbsp;</a></span>Cy_MCWDT_GetWarnLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_MCWDT_GetWarnLimit </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the warn limit comparison value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The warn limit value is not supported by Counter 2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit warn limit value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="ga070d6f92c33d9be8774711e690dffc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga070d6f92c33d9be8774711e690dffc0b">&#9670;&nbsp;</a></span>Cy_MCWDT_WaitForCounterReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_WaitForCounterReset </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wait completion of counter reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the MCWDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
<a id="gac4cf6e7d3f3ceb9c729d04e07320d2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4cf6e7d3f3ceb9c729d04e07320d2c5">&#9670;&nbsp;</a></span>Cy_MCWDT_ClearWatchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MCWDT_ClearWatchdog </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the MC watchdog counter, to prevent a XRES device reset or fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes the registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all counters to clear watchdog. See the <a class="el" href="group__group__mcwdt__macros.html#gadb87c7b323120f1297143824fd7cded7">CY_MCWDT_CTR0</a>, CY_MCWDT_CTR1, and CY_MCWDT_CTR2 macros. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga544d034462bd37c41e841570448a310f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga544d034462bd37c41e841570448a310f">&#9670;&nbsp;</a></span>Cy_MCWDT_GetLowerLimit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_MCWDT_GetLowerLimit </td>
          <td>(</td>
          <td class="paramtype">MCWDT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__mcwdt__enums.html#gaf24fe552bfb229753a1306574961f2a7">cy_en_mcwdtctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the lower limit comparison value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. The valid range is [0-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The lower limit value is not supported by Counter 2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit lower limit value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is available for CAT1C devices. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
