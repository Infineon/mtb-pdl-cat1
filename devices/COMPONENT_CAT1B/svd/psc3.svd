<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Infineon Technologies</vendor>
  <vendorID>Infineon</vendorID>
  <name>psc3</name>
  <series>PSC3</series>
  <version>1.0</version>
  <description>PSC3</description>
  <licenseText>(c) (2016-2024), Cypress Semiconductor Corporation (an Infineon company)\n
    or an affiliate of Cypress Semiconductor Corporation.\n
\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM33</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral interconnect</description>
      <baseAddress>0x42000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TIMEOUT_CTL</name>
          <description>Timeout control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT</name>
              <description>This field specifies a number of peripheral group root undivided (clk_group_root[i]) clock cycles. If an AHB-Lite bus transfer takes more than the specified number of cycles (timeout detection), the bus transfer is terminated with an AHB5 bus error and a timeout status is set. '0x0000'-'0xfffe': Number of peripheral group clock cycles. '0xffff': This value is the default/reset value and specifies that no timeout detection is performed: a bus transfer will never be terminated, and a interrupt will never be generated.
Note that TIMEOUT_CTL.TIMEOUT[15:0] in clk_pclk0_root (clk_hf0) is used directly in peripheral group clock domain clk_group_root[i], even if clk_group_root[i] is async to clk_pclk0_root. This is on the assumption that this register is programmed once by SW, remain constant. Following SW programming restrictions apply to TIMEOUT_CTL.TIMEOUT[15:0]. SW should make sure that no other AHB transactions are initiated through PERI before programming this register. SW should make sure that write to TIMEOUT_CTL.TIMEOUT[15:0] is completed by doing a readback.
Note that peripheral group-0 slaves are excluded from timeout (Refer Timeout section in mxsperi.1 BROS for more details).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HWRST_DISABLE</name>
              <description>This field provides control for HW to reset the slave that is causing the timeout to occur.
1 - no HW reset during timeout.
0 - HW resets the corresponding slave during timeout.
This ensures the AHB bus not to be hung after a timeout has occurred. HW asserts the reset along with fault request (peri_gp'i'_mmio_timeout_vio_req) and holds it until fault acknowledge (mmio_peri_gp'i'_timeout_vio_ack) is received from centralized fault infrastructure.
Note, SW needs to take care of the implication when clearing this bit when a HW reset has occurred as clearing this bit will cause HW reset de-assert.
Note that peripheral group-0 slaves are excluded from timeout (Refer Timeout section in mxsperi.1 BROS for more details).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>Trigger command</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0001FFF</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when ACTIVATE is '1'. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GROUP_SEL</name>
              <description>Specifies the trigger group:
'0'-'15': trigger multiplexer groups.
'16'-'31': trigger 1-to-1 groups.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_EDGE</name>
              <description>Specifies if the activated  trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive. The trigger reflects TR_CMD.ACTIVATE.
'1': edge sensitive trigger. The trigger is activated for two clk_peri cycles.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_SEL</name>
              <description>Specifies whether trigger activation is for a specific input or output trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_CTL.TR_SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.

Note: this field is not used for trigger 1-to-1 groups.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVATE</name>
              <description>SW sets this field to '1' to activate (set to '1') a trigger as identified by TR_SEL, TR_EDGE and OUT_SEL. HW sets this field to '0' for edge sensitive triggers AFTER the selected trigger is activated for two clk_peri cycles.

Note: when ACTIVATE is '1', SW should not modify the other register fields.
SW MUST NOT set ACTIVATE bit to '1' while updating the other register bits simultaneously. At first the SW MUST update the other register bits as needed, and then set ACTIVATE to '1' with a new register write.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INFRA_CLK_FORCE</name>
          <description>Infrastructure clock force enable</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Infrastructure clock force enable.
0: Disabled
1: Enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>6</dim>
          <dimIncrement>64</dimIncrement>
          <name>GR[%s]</name>
          <description>Peripheral group structure</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>CLOCK_CTL</name>
            <description>Clock control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF00</resetMask>
            <fields>
              <field>
                <name>INT8_DIV</name>
                <description>Specifies a group clock divider (from the peripheral clock 'clk_peri' to the group clock 'clk_group[1/2/3/4/5/...15]'). Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256].

Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL</name>
            <description>Slave control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>Slave Enable. Each bit indicates whether the respective slave is enabled. If the slave is disabled, its clock is gated off (constant '0').

Note: For peripheral group 0 slave 0,1, and 2 (the peripheral interconnect MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.
The peripheral IP that drives the Q-Channel back to Clock Controllers need to ensure that it has clock (usually driven by Clk_hf1~N that is only available after CPU configures their roots in the SRSS) to provide back the Q-Channel handshake, if not the deadlock situation will procure. To avoid deadlock mentioned above, all IPs in all groups other than group-0 are disabled  (SL_CTL.ENABLED is set to '0') by default after POR (cold boot) (i.e. PERI HW hardcodes local parameter SL_CTL_DEFAULT to 32'hFFFFFFFF for group-0 and to 32'h00000000 for other groups (group-1 to group-15)).  Once CPU is up and running &amp; Clk_hf1~N configured, CPU can enable them.
The SL_CTL.ENABLED are retained during DEEPSLEEP to avoid enabling configuration after wakeup.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL2</name>
            <description>Slave control2</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RST</name>
                <description>Slave reset. Each bit indicates whether the respective slave is enabled. If the slave is under reset, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 slave 0,1, and 2 (the peripheral interconnect MMIO registers), this field is a constant '0' (SW: R): the slave can NOT be in reset.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL3</name>
            <description>Slave control3</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SS_POWERSTATE</name>
                <description>Slave status to represent subsystem (SS) IP current power status. Each bit represents the respective IP power state (Note that separate mxsperi peripheral group should be defined for type4 peripheral, should not be mixed with type1/2/3 and same peripheral group can have multiple type4 peripherals)
0 - indiacates IP is in OFF state.
1 - indicates IP is in ON state.
This register exists only for peripheral group with type4 peripherals (has its own PPU, P/Q-Channel consolidation and clock gating).
This is readonly register connecting to PERI input signal coming from the respective SS IP.
Since this register is passthorugh of status signal from peripheral the default value defined is w.r.t. respective IP reset.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_WOUND</name>
            <description>Slave wounding</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DISABLED</name>
                <description>Slave disabled. Each bit indicates whether the respective slave is disabled. Setting this bit to 1 has the same effect as setting SL_CTL.ENABLED_0 to 0.  However, once set to 1, this bit cannot be changed back to 0 anymore.

Note: For peripheral group 0 slave 0,1, and 2 (the peripheral interconnect MMIO registers), this field is a constant '0' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>15</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_GR[%s]</name>
          <description>Trigger group</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x13FF</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>3</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_1TO1_GR[%s]</name>
          <description>Trigger 1-to-1 group</description>
          <addressOffset>0x0000C000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1301</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger:
'0'': constant signal level '0'.
'1': input trigger.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PPC</name>
      <description>Peripheral Protection Controller</description>
      <baseAddress>0x42020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>PPC</name>
          <description>Peripheral Protection Controller</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>PPC Control Registers</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RESP_CFG</name>
                <description>Response Configuration. This field configures the security violation response.
0 - Read-Zero Write Ignore (RZWI)
1 - Bus Error</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK_MASK</name>
            <description>Locked Mask</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCK_MASK</name>
                <description>A mask that indicates which protection contexts are 'locked'.  Once locked, a protection context cannot be unlocked until the next reset or power cycle. Bit i specifies the locked status for protection context i.
0: The protection context is unlocked.
1: The protection context is locked.

When a PC is locked, the PPC_PC_MASK, PPC_NS_ATT and PPC_S_P_ATT register bits for peripheral regions to which this PC has access can no longer be modified (PPC_NS_P_ATT is not subject to these restrictions).  The one exception to this is that PPC_PC_MASK bits associated with other protection contexts that are not themselves locked can still be cleared (but not set).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>1024</dim>
            <dimIncrement>4</dimIncrement>
            <name>PC_MASK[%s]</name>
            <description>Protection Context Mask</description>
            <addressOffset>0x1000</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PC_MASK</name>
                <description>A mask that indicates which protection contexts have access to a peripheral region.  Bit i specifies the access for protection context i.
0: The protection context has no access to this region.
1: The protection context has access to this region, subject to secure and privilege attribute constraints setup in PPC_NS_ATT, PPC_S_P_ATT, PPC_NS_P_ATT registers)</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>32</dim>
            <dimIncrement>4</dimIncrement>
            <name>NS_ATT[%s]</name>
            <description>Non-secure attribute</description>
            <addressOffset>0x2000</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NS</name>
                <description>Non-Secure. Each bit indicates whether access to a peripheral region must be secure or non-secure:
IF SECURITY_AWARE=0
0 - allow only secure access to respective peripheral region.
1 - allow only non-secure access to respective peripheral region.
IF SECURITY_AWARE=1
0 - allow only secure access to respective peripheral region.
1 - allows both secure and non-secure access to respective peripheral region.
(Note that, depending on this setting the privilege access requirement for this region is specified in the corresponding PPC_S_P_ATT or PPC_NS_P_ATT register)</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>32</dim>
            <dimIncrement>4</dimIncrement>
            <name>S_P_ATT[%s]</name>
            <description>Secure Privilege Attribute</description>
            <addressOffset>0x2400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>S_P</name>
                <description>Secure Privilege. Each bit indicates whether access to a secure peripheral region requires privilege:
0 - allow only secure privileged access to respective peripheral region.
1 - allow only secure unprivileged or privileged access to respective peripheral region.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>32</dim>
            <dimIncrement>4</dimIncrement>
            <name>NS_P_ATT[%s]</name>
            <description>Non-secure Privilege Attribute</description>
            <addressOffset>0x4000</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NS_P</name>
                <description>Non-Secure Privilege. Each bit indicates whether access to a non-secure peripheral region requires privilege:
0 - allow only non-secure privileged access to respective peripheral region.
1 - allow only non-secure unprivileged or privileged access to respective peripheral region.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>222</dim>
            <dimIncrement>4</dimIncrement>
            <name>R_ADDR[%s]</name>
            <description>Region Address</description>
            <addressOffset>0x00005000</addressOffset>
            <register>
              <name>R_ADDR</name>
              <description>Region Address</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFC</resetMask>
              <fields>
                <field>
                  <name>R_ADDR</name>
                  <description>This field specifies the base address of the peripheral region. The region size is defined by R_ATTR.R_SIZE. A region of n Bytes mus be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR must be '0's. E.g., a 64KB address region (R_SIZE is '15') must be 64 KByte aligned, and R_ADDR[13:0] must be '0's.</description>
                  <bitRange>[31:2]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <dim>222</dim>
            <dimIncrement>4</dimIncrement>
            <name>R_ATT[%s]</name>
            <description>Region Attribute</description>
            <addressOffset>0x00006000</addressOffset>
            <register>
              <name>R_ATT</name>
              <description>Region Attribute</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F000000</resetMask>
              <fields>
                <field>
                  <name>R_SIZE</name>
                  <description>This field specifies the size of the peripheral region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PERI_PCLK</name>
      <description>Peripheral PCLK groups</description>
      <baseAddress>0x42040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>7</dim>
          <dimIncrement>8192</dimIncrement>
          <name>GR[%s]</name>
          <description>PERI clock domains</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>DIV_CMD</name>
            <description>Divider command</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF03FF</resetValue>
            <resetMask>0xC3FF03FF</resetMask>
            <fields>
              <field>
                <name>DIV_SEL</name>
                <description>(TYPE_SEL, DIV_SEL) specifies the divider on which the command (DISABLE/ENABLE) is performed.

If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TYPE_SEL</name>
                <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PA_DIV_SEL</name>
                <description>(PA_TYPE_SEL, PA_DIV_SEL) specifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.

If PA_DIV_SEL is '255' and PA_TYPE_SEL is '3', 'clk_pclk_root[i]' is used as reference.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PA_TYPE_SEL</name>
                <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE</name>
                <description>Clock divider disable command (mutually exclusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.

The DIV_SEL and TYPE_SEL fields specify which divider is to be disabled.

The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.

The DIV_SEL and TYPE_SEL fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_pclk_root[i]' (typical usage) or to ANY enabled divider.

The PA_DIV_SEL and PA_TYPE_SEL fields specify the reference divider.

The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_pclk_root[i]'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_pclk_root[i]' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>CLOCK_CTL[%s]</name>
            <description>Clock control</description>
            <addressOffset>0xC00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>DIV_SEL</name>
                <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.

If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.

When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_pclk_root[i]' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '255' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TYPE_SEL</name>
                <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_8_CTL[%s]</name>
            <description>Divider control (for 8.0 divider)</description>
            <addressOffset>0x1000</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF01</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.

Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INT8_DIV</name>
                <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.

For the generation of a divided clock, the integer division range is restricted to [2, 256].

For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.

Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_16_CTL[%s]</name>
            <description>Divider control (for 16.0 divider)</description>
            <addressOffset>0x1400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF01</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.

Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INT16_DIV</name>
                <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.

For the generation of a divided clock, the integer division range is restricted to [2, 65,536].

For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.

Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[23:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_16_5_CTL[%s]</name>
            <description>Divider control (for 16.5 divider)</description>
            <addressOffset>0x1800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFF9</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.

Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FRAC5_DIV</name>
                <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_pclk_root[i]' cycle longer than other clock periods.

Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[7:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT16_DIV</name>
                <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.

For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].

For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].

Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[23:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>255</dim>
            <dimIncrement>4</dimIncrement>
            <name>DIV_24_5_CTL[%s]</name>
            <description>Divider control (for 24.5 divider)</description>
            <addressOffset>0x1C00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFF9</resetMask>
            <fields>
              <field>
                <name>EN</name>
                <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.

Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FRAC5_DIV</name>
                <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_pclk_root[i]' cycle longer than other clock periods.

Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[7:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT24_DIV</name>
                <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.

For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].

For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].

Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>RAMC_PPU0</name>
      <description>Power Policy Unit Registers for System RAM</description>
      <headerStructName>RAMC_PPU</headerStructName>
      <baseAddress>0x42100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWPR</name>
          <description>Power Policy Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x108</resetValue>
          <resetMask>0x10F110F</resetMask>
          <fields>
            <field>
              <name>PWR_POLICY</name>
              <description>Power mode policy.  When static power mode transitions are enabled, PWR_DYN_EN is set to 0, this is the target power mode for the PPU.  When dynamic power mode transitions are enabled, PWR_DYN_EN is set to 1, this is the minimum power mode for the PPU.

This PPU supports the following modes: OFF(0), MEM_RET(2), ON(8).  Do not use WARM_RST(9) or other unsupported modes.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DYN_EN</name>
              <description>Power mode dynamic transition enable.  When this bit is set to 1 dynamic transitions are enabled for power modes, allowing transitions to be initiated by changes on power mode DEVACTIVE inputs.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_EN</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_POLICY</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_DYN_EN</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMER</name>
          <description>Power Mode Emulation Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>EMU_EN</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWSR</name>
          <description>Power Status Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10F110F</resetMask>
          <fields>
            <field>
              <name>PWR_STATUS</name>
              <description>Power mode status.  These bits reflect the current power mode of the PPU.  See PPU_PWPR.PWR_POLICY for power mode enumeration.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DYN_STATUS</name>
              <description>Power mode dynamic transition status.  When set to 1 power mode dynamic transitions are enabled.  There might be a delay in dynamic transitions becoming active or inactive if the PPU is transitioning when PWR_DYN_EN is programmed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCK_STATUS</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_STATUS</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_DYN_STATUS</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DISR</name>
          <description>Device Interface Input Current Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0007FF</resetMask>
          <fields>
            <field>
              <name>PWR_DEVACTIVE_STATUS</name>
              <description>Status of the power mode DEVACTIVE inputs.

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 0 is for Q-channel device 0 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_DEVACTIVE_STATUS</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MISR</name>
          <description>Miscellaneous Input Current Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>PCSMPACCEPT_STATUS</name>
              <description>The status of the PCSMPACCEPT input.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVACCEPT_STATUS</name>
              <description>Status of the device interface DEVACCEPT inputs.

There is one bit for each device interface DEVQACCEPTn.  For example, bit 8 is for Q-Channel 0 DEVQACCEPTn and bit 9 for Q-Channel 1 DEVQACCEPTn.   Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVDENY_STATUS</name>
              <description>Status of the device interface DEVDENY inputs.

There is one bit for each device interface DEVQDENY.  For example, bit 16 is for Q-Channel 0 DEVQDENY, and bit 17 for Q-Channel 1 DEVQDENY.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STSR</name>
          <description>Stored Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STORED_DEVDENY</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UNLK</name>
          <description>Unlock register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWCR</name>
          <description>Power Configuration Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0xFF07FFFF</resetMask>
          <fields>
            <field>
              <name>DEVREQEN</name>
              <description>When set to 1 enables the device interface handshake for transitions.  All available bits are reset to 1.

There is one bit for each device interface channel.  For example, bit 0 is for Q-Channel 0, and bit 1 is for Q-Channel 1.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DEVACTIVEEN</name>
              <description>These bits enable the power mode DEVACTIVE inputs.  When a bit is to 1 the related DEVACTIVE input is enabled, when set to 0 it is disabled.  All available bits are reset to 1.

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 8 is for the Q-Channel 0 DEVQACTIVE, and bit 9 for the Q-Channel 1 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[18:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_DEVACTIVEEN</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTCR</name>
          <description>Power Mode Transition Configuration Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WARM_RST_DEVREQEN</name>
              <description>Transition behavior between ON and WARM_RST.  This bit should not be modified when the PPU is in WARM_RST, or if the PPU is performing a transition, otherwise PPU behavior is UNPREDICTABLE.
0:  The PPU does not perform a device interface handshake when transitioning between ON and WARM_RST.
1:  The PPU performs a device interface handshake when transitioning between ON and WARM_RST.  This disables all Q-Channels for this transition.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_RECOV_PORST_EN</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IMR</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3A</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>STA_POLICY_TRN_IRQ_MASK</name>
              <description>Static full policy transition completion event mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_ACCEPT_IRQ_MASK</name>
              <description>Static transition acceptance event mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_DENY_IRQ_MASK</name>
              <description>Static transition denial event mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_ACCEPT_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_DENY_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKED_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AIMR</name>
          <description>Additional Interrupt Mask Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1E</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>UNSPT_POLICY_IRQ_MASK</name>
              <description>Unsupported Policy event mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ACCEPT_IRQ_MASK</name>
              <description>Dynamic transition acceptance event mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_DENY_IRQ_MASK</name>
              <description>Dynamic transition denial event mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF07FFBF</resetMask>
          <fields>
            <field>
              <name>STA_POLICY_TRN_IRQ</name>
              <description>Static full policy transition completion event status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_ACCEPT_IRQ</name>
              <description>Static transition acceptance event status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_DENY_IRQ</name>
              <description>Static transition denial event status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_ACCEPT_IRQ</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_DENY_IRQ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKED_IRQ</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTHER_IRQ</name>
              <description>Indicates there is an interrupt event pending in the Additional Interrupt Status Register (PPU_AISR).</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_ACTIVE_EDGE_IRQ</name>
              <description>N/A</description>
              <bitRange>[18:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_ACTIVE_EDGE_IRQ</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AISR</name>
          <description>Additional Interrupt Status Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>UNSPT_POLICY_IRQ</name>
              <description>Unsupported Policy event status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ACCEPT_IRQ</name>
              <description>Dynamic transition acceptance event status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_DENY_IRQ</name>
              <description>Dynamic transition denial event status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR</name>
          <description>Input Edge Sensitivity Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>DEVACTIVE00_EDGE</name>
              <description>DEVACTIVE 0 edge sensitivity.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE01_EDGE</name>
              <description>N/A</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE02_EDGE</name>
              <description>N/A</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE03_EDGE</name>
              <description>N/A</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE04_EDGE</name>
              <description>N/A</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE05_EDGE</name>
              <description>N/A</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE06_EDGE</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE07_EDGE</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE08_EDGE</name>
              <description>N/A</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE09_EDGE</name>
              <description>N/A</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE10_EDGE</name>
              <description>N/A</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OPSR</name>
          <description>Operating Mode Active Edge Sensitivity Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DEVACTIVE16_EDGE</name>
              <description>N/A</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE17_EDGE</name>
              <description>N/A</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE18_EDGE</name>
              <description>N/A</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE19_EDGE</name>
              <description>N/A</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE20_EDGE</name>
              <description>N/A</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE21_EDGE</name>
              <description>N/A</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE22_EDGE</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE23_EDGE</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FUNRR</name>
          <description>Functional Retention RAM Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FUNC_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FULRR</name>
          <description>Full Retention RAM Configuration Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FULL_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEMRR</name>
          <description>Memory Retention RAM Configuration Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MEM_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EDTR0</name>
          <description>Power Mode Entry Delay Register 0</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFF_DEL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOGIC_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EDTR1</name>
          <description>Power Mode Entry Delay Register 1</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>MEM_OFF_DEL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FUNC_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDR0</name>
          <description>Device Control Delay Configuration Register 0</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKEN_RST_DLY</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ISO_CLKEN_DLY</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RST_HWSTAT_DLY</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDR1</name>
          <description>Device Control Delay Configuration Register 1</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ISO_RST_DLY</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLKEN_ISO_DLY</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR0</name>
          <description>PPU Identification Register 0</description>
          <addressOffset>0xFB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x10530501</resetValue>
          <resetMask>0x3FF7FFFF</resetMask>
          <fields>
            <field>
              <name>DEVCHAN</name>
              <description>No. of Device Interface Channels.  The device enumeration is:
Device 0: PDCM</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_OPMODE</name>
              <description>No. of operating modes supported is NUM_OPMODE + 1.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_OFF_SPT</name>
              <description>OFF support.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_OFF_EMU_SPT</name>
              <description>OFF_EMU support.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_RET_SPT</name>
              <description>MEM_RET support.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_RET_EMU_SPT</name>
              <description>MEM_RET_EMU support.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_LGC_RET_SPT</name>
              <description>LOGIC_RET support.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_OFF_SPT</name>
              <description>MEM_OFF support.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_FULL_RET_SPT</name>
              <description>FULL_RET support.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_FUNC_RET_SPT</name>
              <description>FUNC_RET support.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_ON_SPT</name>
              <description>ON support.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_WRM_RST_SPT</name>
              <description>WARM_RST support.  Ignore this bit.  Do not use WARM_RST.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_DBG_RECOV_SPT</name>
              <description>DBG_RECOV support.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_OFF_SPT</name>
              <description>Dynamic OFF support.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_OFF_EMU_SPT</name>
              <description>Dynamic OFF_EMU support.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_RET_SPT</name>
              <description>Dynamic MEM_RET support.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_RET_EMU_SPT</name>
              <description>Dynamic MEM_RET_EMU support</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_LGC_RET_SPT</name>
              <description>Dynamic LOGIC_RET support.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_OFF_SPT</name>
              <description>Dynamic MEM_OFF support.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_FULL_RET_SPT</name>
              <description>Dynamic FULL_RET support.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_FUNC_RET_SPT</name>
              <description>Dynamic FUNC_RET support.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_ON_SPT</name>
              <description>Dynamic ON support.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_WRM_RST_SPT</name>
              <description>Dynamic WARM_RST support.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR1</name>
          <description>PPU Identification Register 1</description>
          <addressOffset>0xFB4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1777</resetMask>
          <fields>
            <field>
              <name>PWR_MODE_ENTRY_DEL_SPT</name>
              <description>Power mode entry delay support.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_DEV_DEL_SPT</name>
              <description>Software device delay control configuration support.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCK_SPT</name>
              <description>Lock and the lock interrupt event are supported.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MEM_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FUNC_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ_SPT</name>
              <description>Power policy transition completion event status.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ_SPT</name>
              <description>Operating policy transition completion event status.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_ACTIVE</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFF_MEM_RET_TRANS</name>
              <description>OFF to MEM_RET direct transition.  Indicates if direct transitions from OFF to MEM_RET and from OFF_EMU to MEM_RET_EMU are supported.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IIDR</name>
          <description>Implementation Identification Register</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB50043B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER</name>
              <description>Implementer identification.  [11:8] The JEP106 continuation code of the implementer.  [7] Always 0.  [6:0] The JEP106 identity code of the implementer.  For an Arm implementation, bits [11:0] are 0x43B.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>Minor revision of the product.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VARIANT</name>
              <description>Major revision of the product.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRODUCT_ID</name>
              <description>PPU part identification.</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AIDR</name>
          <description>Architecture Identification Register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x11</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ARCH_REV_MINOR</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCH_REV_MAJOR</name>
              <description>N/A</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID4</name>
          <description>Implementation Defined Identification Register (PID4)</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER_11_8</name>
              <description>The JEP106 continuation code of the implementer, which is 0x4 hardcoded value.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID0</name>
          <description>Implementation Defined Identification Register (PID0)</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB5</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID_7_0</name>
              <description>PPU part identification bits [7:0].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID1</name>
          <description>Implementation Defined Identification Register (PID1)</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID_11_8</name>
              <description>PPU part identification bits [11:8]</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER_3_0</name>
              <description>JEP106_ID bits [3:0]</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID2</name>
          <description>Implementation Defined Identification Register (PID2)</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER_6_4</name>
              <description>JEP106_ID bits [6:4]</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CONST_HIGH</name>
              <description>Constant HIGH</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REV_CONST</name>
              <description>Constant LOW  Revision (4 bits)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID3</name>
          <description>Implementation Defined Identification Register (PID3)</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PID3_REV_CONST</name>
              <description>Constant LOW (4 bits)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PID3_REVISION</name>
              <description>Minor revision of the product.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID0</name>
          <description>Implementation Defined Identification Register (ID0)</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xD</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID0</name>
              <description>ID0 hard coded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID1</name>
          <description>Implementation Defined Identification Register (ID1)</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xF0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID1</name>
              <description>ID1 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID2</name>
          <description>Implementation Defined Identification Register (ID2)</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID2</name>
              <description>ID2 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID3</name>
          <description>Implementation Defined Identification Register (ID3)</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB1</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID3</name>
              <description>ID3 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ICACHE0</name>
      <description>CM33_0/1 CA APB interface</description>
      <headerStructName>ICACHE</headerStructName>
      <baseAddress>0x42103000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Cache control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xDF030003</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking for cache accesses:
0: Disabled.
1: Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for cache.
When '1', the parity (ECC_CTL.PARITY[6:0]) is used when a cache refill is done to the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>Specifies the cache way for which cache information is provided in STATUS0/1/2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>Specifies the cache set for which cache information is provided in STATUS0/1/2.</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.

Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>Cache enable:
0: Disabled. The cache tag valid bits are reset to '0's and the cache LRU information is set to '1's (making way 0 the LRU way and way 3 the MRU way).
1: Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Cache command</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Invalidation of cahce and buffer. SW writes a '1' to clear the caches. HW sets this field to '0' when the operation is completed. The caches' LRU structures are also reset to their default state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFF_INV</name>
              <description>Invalidation of  buffers (does not invalidate the caches). SW writes a '1' to clear the buffers. HW sets this field to '0' when the operation is completed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS0</name>
          <description>Cache status 0</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>Sixteen valid bits of the cache line specified by CTL.WAY and CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS1</name>
          <description>Cache status 1</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>Cache line address of the cache line specified by CTL.WAY and CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS2</name>
          <description>Cache status 2</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x3F</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>Six bit LRU representation of the cache set specified by CTL.SET_ADDR. The encoding of the field is as follows ('X_LRU_Y' indicates that way X is Less Recently Used than way Y):
Bit 5: 0_LRU_1: way 0 less recently used than way 1.
Bit 4: 0_LRU_2.
Bit 3: 0_LRU_3.
Bit 2: 1_LRU_2.
Bit 1: 1_LRU_3.
Bit 0: 2_LRU_3.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS_PPU</name>
      <description>Power Policy Unit Registers for CPUSS</description>
      <baseAddress>0x42105000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWPR</name>
          <description>Power Policy Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x108</resetValue>
          <resetMask>0x10F110F</resetMask>
          <fields>
            <field>
              <name>PWR_POLICY</name>
              <description>Power mode policy.  When static power mode transitions are enabled, PWR_DYN_EN is set to 0, this is the target power mode for the PPU.  When dynamic power mode transitions are enabled, PWR_DYN_EN is set to 1, this is the minimum power mode for the PPU.

This PPU supports the following modes: OFF(0), FULL_RET(5), ON(8).  Do not use WARM_RST(9) or other unsupported modes.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DYN_EN</name>
              <description>Power mode dynamic transition enable.  When this bit is set to 1 dynamic transitions are enabled for power modes, allowing transitions to be initiated by changes on power mode DEVACTIVE inputs.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_EN</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_POLICY</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_DYN_EN</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMER</name>
          <description>Power Mode Emulation Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>EMU_EN</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWSR</name>
          <description>Power Status Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10F110F</resetMask>
          <fields>
            <field>
              <name>PWR_STATUS</name>
              <description>Power mode status.  These bits reflect the current power mode of the PPU.  See PPU_PWPR.PWR_POLICY for power mode enumeration.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DYN_STATUS</name>
              <description>Power mode dynamic transition status.  When set to 1 power mode dynamic transitions are enabled.  There might be a delay in dynamic transitions becoming active or inactive if the PPU is transitioning when PWR_DYN_EN is programmed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCK_STATUS</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_STATUS</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_DYN_STATUS</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DISR</name>
          <description>Device Interface Input Current Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0007FF</resetMask>
          <fields>
            <field>
              <name>PWR_DEVACTIVE_STATUS</name>
              <description>Status of the power mode DEVACTIVE inputs.

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 0 is for Q-channel device 0 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_DEVACTIVE_STATUS</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MISR</name>
          <description>Miscellaneous Input Current Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>PCSMPACCEPT_STATUS</name>
              <description>The status of the PCSMPACCEPT input.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVACCEPT_STATUS</name>
              <description>Status of the device interface DEVACCEPT inputs.

There is one bit for each device interface DEVQACCEPTn.  For example, bit 8 is for Q-Channel 0 DEVQACCEPTn and bit 9 for Q-Channel 1 DEVQACCEPTn.   Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DEVDENY_STATUS</name>
              <description>Status of the device interface DEVDENY inputs.

There is one bit for each device interface DEVQDENY.  For example, bit 16 is for Q-Channel 0 DEVQDENY, and bit 17 for Q-Channel 1 DEVQDENY.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STSR</name>
          <description>Stored Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STORED_DEVDENY</name>
              <description>Status of the DEVDENY signals from the last device interface Q-Channel transition.  For Q-Channel:  There is one bit for each device interface DEVQDENY.  For example, bit 0 is for Q-Channel 0 DEVQDENY, and bit 1 for Q-Channel 1 DEVQDENY.  Refer to PPU_DISR.PWR_DEVACTIVE_STATUS for device enumeration.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UNLK</name>
          <description>Unlock register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWCR</name>
          <description>Power Configuration Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x303</resetValue>
          <resetMask>0xFF07FFFF</resetMask>
          <fields>
            <field>
              <name>DEVREQEN</name>
              <description>When set to 1 enables the device interface handshake for transitions.  All available bits are reset to 1.

There is one bit for each device interface channel.  For example, bit 0 is for Q-Channel 0, and bit 1 is for Q-Channel 1.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DEVACTIVEEN</name>
              <description>These bits enable the power mode DEVACTIVE inputs.  When a bit is to 1 the related DEVACTIVE input is enabled, when set to 0 it is disabled.  All available bits are reset to 1.

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 8 is for the Q-Channel 0 DEVQACTIVE, and bit 9 for the Q-Channel 1 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
              <bitRange>[18:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_DEVACTIVEEN</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTCR</name>
          <description>Power Mode Transition Configuration Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WARM_RST_DEVREQEN</name>
              <description>Transition behavior between ON and WARM_RST.  This bit should not be modified when the PPU is in WARM_RST, or if the PPU is performing a transition, otherwise PPU behavior is UNPREDICTABLE.
0:  The PPU does not perform a device interface handshake when transitioning between ON and WARM_RST.
1:  The PPU performs a device interface handshake when transitioning between ON and WARM_RST.  This disables all Q-Channels for this transition.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_RECOV_PORST_EN</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IMR</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>STA_POLICY_TRN_IRQ_MASK</name>
              <description>Static full policy transition completion event mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_ACCEPT_IRQ_MASK</name>
              <description>Static transition acceptance event mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_DENY_IRQ_MASK</name>
              <description>Static transition denial event mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_ACCEPT_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_DENY_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKED_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AIMR</name>
          <description>Additional Interrupt Mask Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x6</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>UNSPT_POLICY_IRQ_MASK</name>
              <description>Unsupported Policy event mask.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ACCEPT_IRQ_MASK</name>
              <description>Dynamic transition acceptance event mask.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_DENY_IRQ_MASK</name>
              <description>Dynamic transition denial event mask.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ_MASK</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF07FFBF</resetMask>
          <fields>
            <field>
              <name>STA_POLICY_TRN_IRQ</name>
              <description>Static full policy transition completion event status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_ACCEPT_IRQ</name>
              <description>Static transition acceptance event status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_DENY_IRQ</name>
              <description>Static transition denial event status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_ACCEPT_IRQ</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMU_DENY_IRQ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKED_IRQ</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OTHER_IRQ</name>
              <description>Indicates there is an interrupt event pending in the Additional Interrupt Status Register (PPU_AISR).</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_ACTIVE_EDGE_IRQ</name>
              <description>N/A</description>
              <bitRange>[18:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_ACTIVE_EDGE_IRQ</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AISR</name>
          <description>Additional Interrupt Status Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>UNSPT_POLICY_IRQ</name>
              <description>Unsupported Policy event status.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_ACCEPT_IRQ</name>
              <description>Dynamic transition acceptance event status.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYN_DENY_IRQ</name>
              <description>Dynamic transition denial event status.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR</name>
          <description>Input Edge Sensitivity Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>DEVACTIVE00_EDGE</name>
              <description>DEVACTIVE 0 edge sensitivity.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE01_EDGE</name>
              <description>DEVACTIVE 1 edge sensitivity.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE02_EDGE</name>
              <description>DEVACTIVE 2 edge sensitivity.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE03_EDGE</name>
              <description>N/A</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE04_EDGE</name>
              <description>N/A</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE05_EDGE</name>
              <description>N/A</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE06_EDGE</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE07_EDGE</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE08_EDGE</name>
              <description>N/A</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE09_EDGE</name>
              <description>N/A</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE10_EDGE</name>
              <description>N/A</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OPSR</name>
          <description>Operating Mode Active Edge Sensitivity Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DEVACTIVE16_EDGE</name>
              <description>N/A</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE17_EDGE</name>
              <description>N/A</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE18_EDGE</name>
              <description>N/A</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE19_EDGE</name>
              <description>N/A</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE20_EDGE</name>
              <description>N/A</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE21_EDGE</name>
              <description>N/A</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE22_EDGE</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEVACTIVE23_EDGE</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FUNRR</name>
          <description>Functional Retention RAM Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FUNC_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FULRR</name>
          <description>Full Retention RAM Configuration Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FULL_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEMRR</name>
          <description>Memory Retention RAM Configuration Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MEM_RET_RAM_CFG</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EDTR0</name>
          <description>Power Mode Entry Delay Register 0</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFF_DEL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOGIC_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EDTR1</name>
          <description>Power Mode Entry Delay Register 1</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>MEM_OFF_DEL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FUNC_RET_DEL</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDR0</name>
          <description>Device Control Delay Configuration Register 0</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKEN_RST_DLY</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ISO_CLKEN_DLY</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RST_HWSTAT_DLY</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDR1</name>
          <description>Device Control Delay Configuration Register 1</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>ISO_RST_DLY</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLKEN_ISO_DLY</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR0</name>
          <description>PPU Identification Register 0</description>
          <addressOffset>0xFB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x14134102</resetValue>
          <resetMask>0x3FF7FFFF</resetMask>
          <fields>
            <field>
              <name>DEVCHAN</name>
              <description>No. of Device Interface Channels.
0: This is a P-Channel PPU.  Refer to PPU_IDR1.OP_ACTIVE for the number of DEVPACTIVE inputs and their meaning.
non-zero: The value is the number of Q-Channels.

The device enumeration is:
Device 0: SRSS PDCM,
Device 1: CPUSS SEQ between SS level LPD500 EXP &amp; PERI Q-Channel</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_OPMODE</name>
              <description>No. of operating modes supported is NUM_OPMODE + 1.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_OFF_SPT</name>
              <description>OFF support.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_OFF_EMU_SPT</name>
              <description>OFF_EMU support.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_RET_SPT</name>
              <description>MEM_RET support.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_RET_EMU_SPT</name>
              <description>MEM_RET_EMU support.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_LGC_RET_SPT</name>
              <description>LOGIC_RET support.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_MEM_OFF_SPT</name>
              <description>MEM_OFF support.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_FULL_RET_SPT</name>
              <description>FULL_RET support.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_FUNC_RET_SPT</name>
              <description>FUNC_RET support.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_ON_SPT</name>
              <description>ON support.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_WRM_RST_SPT</name>
              <description>WARM_RST support.  Ignore this bit.  Do not use WARM_RST.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_DBG_RECOV_SPT</name>
              <description>DBG_RECOV support.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_OFF_SPT</name>
              <description>Dynamic OFF support.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_OFF_EMU_SPT</name>
              <description>Dynamic OFF_EMU support.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_RET_SPT</name>
              <description>Dynamic MEM_RET support.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_RET_EMU_SPT</name>
              <description>Dynamic MEM_RET_EMU support</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_LGC_RET_SPT</name>
              <description>Dynamic LOGIC_RET support.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_MEM_OFF_SPT</name>
              <description>Dynamic MEM_OFF support.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_FULL_RET_SPT</name>
              <description>Dynamic FULL_RET support.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_FUNC_RET_SPT</name>
              <description>Dynamic FUNC_RET support.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_ON_SPT</name>
              <description>Dynamic ON support.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DYN_WRM_RST_SPT</name>
              <description>Dynamic WARM_RST support.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR1</name>
          <description>PPU Identification Register 1</description>
          <addressOffset>0xFB4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1777</resetMask>
          <fields>
            <field>
              <name>PWR_MODE_ENTRY_DEL_SPT</name>
              <description>Power mode entry delay support.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_DEV_DEL_SPT</name>
              <description>Software device delay control configuration support.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCK_SPT</name>
              <description>Lock and the lock interrupt event are supported.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MEM_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FUNC_RET_RAM_REG</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_POLICY_PWR_IRQ_SPT</name>
              <description>Power policy transition completion event status.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STA_POLICY_OP_IRQ_SPT</name>
              <description>Operating policy transition completion event status.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OP_ACTIVE</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OFF_MEM_RET_TRANS</name>
              <description>OFF to MEM_RET direct transition.  Indicates if direct transitions from OFF to MEM_RET and from OFF_EMU to MEM_RET_EMU are supported.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IIDR</name>
          <description>Implementation Identification Register</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB50043B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER</name>
              <description>Implementer identification.  [11:8] The JEP106 continuation code of the implementer.  [7] Always 0.  [6:0] The JEP106 identity code of the implementer.  For an Arm implementation, bits [11:0] are 0x43B.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>Minor revision of the product.</description>
              <bitRange>[15:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VARIANT</name>
              <description>Major revision of the product.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRODUCT_ID</name>
              <description>PPU part identification.</description>
              <bitRange>[31:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AIDR</name>
          <description>Architecture Identification Register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x11</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ARCH_REV_MINOR</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ARCH_REV_MAJOR</name>
              <description>N/A</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID4</name>
          <description>Implementation Defined Identification Register (PID4)</description>
          <addressOffset>0xFD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER_11_8</name>
              <description>The JEP106 continuation code of the implementer, which is 0x4 hardcoded value.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID0</name>
          <description>Implementation Defined Identification Register (PID0)</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB5</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID_7_0</name>
              <description>PPU part identification bits [7:0].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID1</name>
          <description>Implementation Defined Identification Register (PID1)</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PRODUCT_ID_11_8</name>
              <description>PPU part identification bits [11:8]</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER_3_0</name>
              <description>JEP106_ID bits [3:0]</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID2</name>
          <description>Implementation Defined Identification Register (PID2)</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>IMPLEMENTER_6_4</name>
              <description>JEP106_ID bits [6:4]</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CONST_HIGH</name>
              <description>Constant HIGH</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REV_CONST</name>
              <description>Constant LOW  Revision (4 bits)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID3</name>
          <description>Implementation Defined Identification Register (PID3)</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PID3_REV_CONST</name>
              <description>Constant LOW (4 bits)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PID3_REVISION</name>
              <description>Minor revision of the product.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID0</name>
          <description>Implementation Defined Identification Register (ID0)</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xD</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID0</name>
              <description>ID0 hard coded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID1</name>
          <description>Implementation Defined Identification Register (ID1)</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xF0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID1</name>
              <description>ID1 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID2</name>
          <description>Implementation Defined Identification Register (ID2)</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID2</name>
              <description>ID2 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID3</name>
          <description>Implementation Defined Identification Register (ID3)</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xB1</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ID3</name>
              <description>ID3 hardcoded value</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RAMC0</name>
      <description>RAMC0/1/2</description>
      <headerStructName>RAMC</headerStructName>
      <baseAddress>0x42110000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10003</resetMask>
          <fields>
            <field>
              <name>SRAM_WS</name>
              <description>Wait states.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WS_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_2</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_3</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_FORCE</name>
              <description>Force EAM clock gating to be always ON.
0: Disabled
1: Enabled

This bit provides fail safe mechanism for dynamic clock gating added on EAM block.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x11</resetValue>
          <resetMask>0x11</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. This information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DONE</name>
              <description>After a PWR_MACRO_CTL.OFF change this flag indicates if the new power mode has taken effect or not.
1: Indicates change is effective;
0: Indicates change is in progress;</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x7F000F</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>ECC enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ECC_DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECC_ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUTO_CORRECT</name>
              <description>ECC auto correction:
'0': Disabled. Corrected ECC errors are ONLY HW corrected 'on-the-fly' (not corrected in the SRAM). Fault reporting is enabled.
'1': Enabled. Correctable ECC errors are HW corrected 'on-the-fly' and in the SRAM, without CPU intervention. Fault reporting is enabled.

Note: This field is ignored when EN is '0' or when CHECK_EN is '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EN</name>
              <description>ECC parity injection:
'0': Disabled.
'1': Enabled. Instead of calculating the parity from the transfer's write data, the parity is taken from PARITY upon a match of the transfer's write address with ECC_MATCH.WORD_ADDR (no match is performed on the transfer's write strobes/mask).

Note: Parity injection invalidates the write buffer for this word address. If only a part of 64-bit data word is written AND consistency should be maintained, STATUS.ALL_WB_EMPTY is '1' should be checked before.

Note: This field is ignored when EN is '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHECK_EN</name>
              <description>ECC checking enable:
'0': Disabled. No ECC checking and associated bus errors. No fault reporting. Intended for SRAM initialization.
'1': Enabled.

Note: This field is ignored when EN is '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Injected parity.</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_STATUS0</name>
          <description>ECC status 0</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>ECC error address. This register captures the address location when ECC error happens.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_STATUS1</name>
          <description>ECC status 1</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>SYNDROME</name>
              <description>This register captures the ECC syndrome when ECC error happens.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_MATCH</name>
          <description>ECC match</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM address and when the ECC_CTL.INJ_EN bit is '1', the parity (ECC_CTL.PARITY) is injected.</description>
              <bitRange>[24:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_MACRO_CTL</name>
          <description>SRAM power partition power control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFF</name>
              <description>Each bit represent the individual RAM power partition power state.  One bit for each macro of RAM controller when all 32 bits are populated as 32 independent power partitions.
0: Macros in power partion is to be powered-ON
1: Macros in power partion is to be powered-OFF

Note 1: it is not allowed to disable a macro during access to its address range.
Note 2: it is not allowed to disable few macros while enable others in the same AHB write transaction.

It is mandatory to check for STATUS.PWR_DONE to become 1 once this PWR_MACRO_DTL register contents are changed to ensure SRAM mode transition is completed successfully.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_MACRO_CTL_LOCK</name>
          <description>SRAM power partition power control Lock</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>PWR_MACRO_CTL_LOCK</name>
              <description>Prohibits Read/Write access to PWR_MACRO_CTL register when this field is not equal to 0.  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.
By default AHB reads/writes to PWR_MACRO_CTL register are locked.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_CHG</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR0</name>
                  <description>Clears bit 0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR1</name>
                  <description>Clears bit 1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET01</name>
                  <description>Sets both bits 0 and 1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_DELAY_CTL</name>
          <description>SRAM power switch power up &amp; sequence delay</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x9020009</resetValue>
          <resetMask>0xFFFF03FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number of IMO clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ0_DELAY</name>
              <description>Number of IMO clock cycles delay needed for sequence-0 of SRAM power transition</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ1_DELAY</name>
              <description>Number of IMO clock cycles delay needed for sequence-1 of SRAM power transition</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>MPC</name>
          <description>MPC Memory Protection Controller registers</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>CFG</name>
            <description>Config register with error response, RegionID PPC_MPC_MAIN is the security owner PC. The error response configuration is located in CFG.RESPONSE, only one such configuration exists applying to all protection contexts in the system.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x10</resetMask>
            <fields>
              <field>
                <name>RESPONSE</name>
                <description>Response Configuration for Security and PC violations
0: Read-Zero Write Ignore (RAZ/WI)
1: Bus Error</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTRL</name>
            <description>Control register with lock bit and auto-increment only (Separate CTRL for each PC depends on access_pc)</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for this protection context as a side effect of each read/write access to BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for this protection context. Software can set this bit but not clear it once set.  When set, write operations to BLK_LUT are not possible  from this protection context. Setting LOCK also blocks writes to CTRL itself (for that PC copy). All writes are ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_MAX</name>
            <description>Max value of block-based index register</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; See product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_CFG</name>
            <description>Block size &amp; initialization in progress</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ... up to 15: 1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to BLK_LUT is blocked (BLK_IDX increment is also ignored). The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_IDX</name>
            <description>Index of 32-block group accessed through BLK_LUT (Separate IDX for each PC depending on access_pc)</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_LUT</name>
            <description>NS status for 32 blocks at BLK_IDX with PC=&lt;access_pc&gt;</description>
            <addressOffset>0x110</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ATTR_NS0</name>
                <description>NS bit for block 0 based on BLK_IDX</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS1</name>
                <description>NS bit for block 1 based on BLK_IDX</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS2</name>
                <description>NS bit for block 2 based on BLK_IDX</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS3</name>
                <description>NS bit for block 3 based on BLK_IDX</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS4</name>
                <description>NS bit for block 4 based on BLK_IDX</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS5</name>
                <description>NS bit for block 5 based on BLK_IDX</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS6</name>
                <description>NS bit for block 6 based on BLK_IDX</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS7</name>
                <description>NS bit for block 7 based on BLK_IDX</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS8</name>
                <description>NS bit for block 8 based on BLK_IDX</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS9</name>
                <description>NS bit for block 9 based on BLK_IDX</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS10</name>
                <description>NS bit for block 10 based on BLK_IDX</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS11</name>
                <description>NS bit for block 11 based on BLK_IDX</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS12</name>
                <description>NS bit for block 12 based on BLK_IDX</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS13</name>
                <description>NS bit for block 13 based on BLK_IDX</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS14</name>
                <description>NS bit for block 14 based on BLK_IDX</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS15</name>
                <description>NS bit for block 15 based on BLK_IDX</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS16</name>
                <description>NS bit for block 16 based on BLK_IDX</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS17</name>
                <description>NS bit for block 17 based on BLK_IDX</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS18</name>
                <description>NS bit for block 18 based on BLK_IDX</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS19</name>
                <description>NS bit for block 19 based on BLK_IDX</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS20</name>
                <description>NS bit for block 20 based on BLK_IDX</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS21</name>
                <description>NS bit for block 21 based on BLK_IDX</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS22</name>
                <description>NS bit for block 22 based on BLK_IDX</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS23</name>
                <description>NS bit for block 23 based on BLK_IDX</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS24</name>
                <description>NS bit for block 24 based on BLK_IDX</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS25</name>
                <description>NS bit for block 25 based on BLK_IDX</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS26</name>
                <description>NS bit for block 26 based on BLK_IDX</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS27</name>
                <description>NS bit for block 27 based on BLK_IDX</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS28</name>
                <description>NS bit for block 28 based on BLK_IDX</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS29</name>
                <description>NS bit for block 29 based on BLK_IDX</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS30</name>
                <description>NS bit for block 30 based on BLK_IDX</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS31</name>
                <description>NS bit for block 31 based on BLK_IDX</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_CTRL</name>
            <description>Control register with lock bit and auto-increment only</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for each read/write of ROT_BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for the root-of-trust configuration registers. Software can set this bit but not clear it once set.  When set, write operations to ROT_BLK_LUT are not possible. Write is ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_MAX</name>
            <description>Max value of block-based index register for ROT</description>
            <addressOffset>0x208</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_CFG</name>
            <description>Same as BLK_CFG</description>
            <addressOffset>0x20C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ...up to 15:1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to ROT_BLK_LUT is RAZWI. The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_IDX</name>
            <description>Index of 8-block group accessed through ROT_BLK_LUT_*</description>
            <addressOffset>0x210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using ROT_BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_PC</name>
            <description>Protection context of 8-block group accesses through ROT_BLK_LUT</description>
            <addressOffset>0x214</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Specify PC values for ROT_BLK_IDX and ROT_BLK_LUT</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_LUT</name>
            <description>(R,W,NS) bits for 8 blocks at ROT_BLK_IDX for PC=ROT_BKL_PC</description>
            <addressOffset>0x218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x77777777</resetMask>
            <fields>
              <field>
                <name>ATTR0</name>
                <description>W/R/NS bits for block 0 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR1</name>
                <description>W/R/NS bits for block 1 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR2</name>
                <description>W/R/NS bits for block 2 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR3</name>
                <description>W/R/NS bits for block 3 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR4</name>
                <description>W/R/NS bits for block 4 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR5</name>
                <description>W/R/NS bits for block 5 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR6</name>
                <description>W/R/NS bits for block 6 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR7</name>
                <description>W/R/NS bits for block 7 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PROMC</name>
      <description>Patchable ROM Controller</description>
      <baseAddress>0x42140000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ROM_WS</name>
              <description>Wait states.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WS_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_2</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WS_3</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <name>MPC</name>
          <description>MPC Memory Protection Controller registers</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>CFG</name>
            <description>Config register with error response, RegionID PPC_MPC_MAIN is the security owner PC. The error response configuration is located in CFG.RESPONSE, only one such configuration exists applying to all protection contexts in the system.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x10</resetMask>
            <fields>
              <field>
                <name>RESPONSE</name>
                <description>Response Configuration for Security and PC violations
0: Read-Zero Write Ignore (RAZ/WI)
1: Bus Error</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTRL</name>
            <description>Control register with lock bit and auto-increment only (Separate CTRL for each PC depends on access_pc)</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for this protection context as a side effect of each read/write access to BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for this protection context. Software can set this bit but not clear it once set.  When set, write operations to BLK_LUT are not possible  from this protection context. Setting LOCK also blocks writes to CTRL itself (for that PC copy). All writes are ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_MAX</name>
            <description>Max value of block-based index register</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; See product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_CFG</name>
            <description>Block size &amp; initialization in progress</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ... up to 15: 1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to BLK_LUT is blocked (BLK_IDX increment is also ignored). The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_IDX</name>
            <description>Index of 32-block group accessed through BLK_LUT (Separate IDX for each PC depending on access_pc)</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_LUT</name>
            <description>NS status for 32 blocks at BLK_IDX with PC=&lt;access_pc&gt;</description>
            <addressOffset>0x110</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ATTR_NS0</name>
                <description>NS bit for block 0 based on BLK_IDX</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS1</name>
                <description>NS bit for block 1 based on BLK_IDX</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS2</name>
                <description>NS bit for block 2 based on BLK_IDX</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS3</name>
                <description>NS bit for block 3 based on BLK_IDX</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS4</name>
                <description>NS bit for block 4 based on BLK_IDX</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS5</name>
                <description>NS bit for block 5 based on BLK_IDX</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS6</name>
                <description>NS bit for block 6 based on BLK_IDX</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS7</name>
                <description>NS bit for block 7 based on BLK_IDX</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS8</name>
                <description>NS bit for block 8 based on BLK_IDX</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS9</name>
                <description>NS bit for block 9 based on BLK_IDX</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS10</name>
                <description>NS bit for block 10 based on BLK_IDX</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS11</name>
                <description>NS bit for block 11 based on BLK_IDX</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS12</name>
                <description>NS bit for block 12 based on BLK_IDX</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS13</name>
                <description>NS bit for block 13 based on BLK_IDX</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS14</name>
                <description>NS bit for block 14 based on BLK_IDX</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS15</name>
                <description>NS bit for block 15 based on BLK_IDX</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS16</name>
                <description>NS bit for block 16 based on BLK_IDX</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS17</name>
                <description>NS bit for block 17 based on BLK_IDX</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS18</name>
                <description>NS bit for block 18 based on BLK_IDX</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS19</name>
                <description>NS bit for block 19 based on BLK_IDX</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS20</name>
                <description>NS bit for block 20 based on BLK_IDX</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS21</name>
                <description>NS bit for block 21 based on BLK_IDX</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS22</name>
                <description>NS bit for block 22 based on BLK_IDX</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS23</name>
                <description>NS bit for block 23 based on BLK_IDX</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS24</name>
                <description>NS bit for block 24 based on BLK_IDX</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS25</name>
                <description>NS bit for block 25 based on BLK_IDX</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS26</name>
                <description>NS bit for block 26 based on BLK_IDX</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS27</name>
                <description>NS bit for block 27 based on BLK_IDX</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS28</name>
                <description>NS bit for block 28 based on BLK_IDX</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS29</name>
                <description>NS bit for block 29 based on BLK_IDX</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS30</name>
                <description>NS bit for block 30 based on BLK_IDX</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS31</name>
                <description>NS bit for block 31 based on BLK_IDX</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_CTRL</name>
            <description>Control register with lock bit and auto-increment only</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for each read/write of ROT_BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for the root-of-trust configuration registers. Software can set this bit but not clear it once set.  When set, write operations to ROT_BLK_LUT are not possible. Write is ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_MAX</name>
            <description>Max value of block-based index register for ROT</description>
            <addressOffset>0x208</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_CFG</name>
            <description>Same as BLK_CFG</description>
            <addressOffset>0x20C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ...up to 15:1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to ROT_BLK_LUT is RAZWI. The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_IDX</name>
            <description>Index of 8-block group accessed through ROT_BLK_LUT_*</description>
            <addressOffset>0x210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using ROT_BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_PC</name>
            <description>Protection context of 8-block group accesses through ROT_BLK_LUT</description>
            <addressOffset>0x214</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Specify PC values for ROT_BLK_IDX and ROT_BLK_LUT</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_LUT</name>
            <description>(R,W,NS) bits for 8 blocks at ROT_BLK_IDX for PC=ROT_BKL_PC</description>
            <addressOffset>0x218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x77777777</resetMask>
            <fields>
              <field>
                <name>ATTR0</name>
                <description>W/R/NS bits for block 0 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR1</name>
                <description>W/R/NS bits for block 1 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR2</name>
                <description>W/R/NS bits for block 2 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR3</name>
                <description>W/R/NS bits for block 3 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR4</name>
                <description>W/R/NS bits for block 4 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR5</name>
                <description>W/R/NS bits for block 5 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR6</name>
                <description>W/R/NS bits for block 6 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR7</name>
                <description>W/R/NS bits for block 7 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASHC</name>
      <description>FLASHC</description>
      <baseAddress>0x42150000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>FLASH_CTL</name>
          <description>Flash control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF05130F</resetMask>
          <fields>
            <field>
              <name>RBUS_WS</name>
              <description>FLASH macro main interface (R-bus) wait states:
'0': 0 wait states.
...
'15': 15 wait states</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BANK_MAPPING</name>
              <description>Specifies mapping of FLASH macro main subregion.
00: MAIN (Mapping A), WORK (Mapping A).
01: MAIN (Mapping B), WORK (Mapping A).
10: MAIN (Mapping A), WORK (Mapping B).
11: MAIN (Mapping B), WORK (Mapping B).

This field is only used when MAIN_BANK_MODE is '1' (dual bank mode).</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BANK_MODE</name>
              <description>Specifies bank mode of FLASH macro main array.
0: Single bank mode.
1: Dual bank mode.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking for FLASH main (R-bus) interface:
0: Disabled. ECC checking/reporting on FLASH main interface is disabled. No correctable or non-correctable faults are reported.
1: Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RBUS_ERR_SILENT</name>
              <description>Please note that it is SW's responsibility that I$ of M33 must be disabled before setting RBUS_ERR_SILENT HIGH. Otherwise, the erroneous goes to I$ which is NOT desired.
Specifies bus transfer behavior for a non-recoverable error on the FLASH macro main interface (either a non-correctable ECC error, a FLASH macro main interface internal error, a FLASH macro main interface memory hole access):
0: Bus transfer has a bus error.
1: Bus transfer does NOT have a bus error; i.e. the error is 'silent'
In either case, the erroneous FLASH macro data is returned to CPU since I$ is disabled.

This field is ONLY used by CPU bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error and fault/interrupt, in case of a non-recoverable error.

Note: All CPU bus masters have dedicated status registers (CM33 to register the occurrence of FLASH macro main interface (R-bus) internal errors.

Note: fault reporting can be used to identify the error that occurred:
- FLASH macro main interface internal error.
- FLASH macro main interface non-recoverable ECC error.
- FLASH macro main interface recoverable ECC error (over its threshold).
- FLASH macro main interface memory hole error.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENFORCE_PC_LOCK</name>
              <description>This bit can be set once and not cleared thereafter.  When set the PC inheritiance and locking mechanism described with the FLASH_LOCK register is enabled.  When cleared, access to the flash controller and flash macro is possible from any protection context with appropriate PPC permissions.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK_SECTOR_OPERATIONS</name>
              <description>This bit can be set once and not cleared thereafter.  When set it is no longer possible to perform sector erase or sector DFT operations.  The flash controller will block any write operations to the FM_CTL register pertaining to such operations.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK_SUBSECTOR_OPERATIONS</name>
              <description>This bit can be set once and not cleared thereafter.  When set it is no longer possible to perform subsector erase or subsector DFT operations.  The flash controller will block any write operations to the FM_CTL register pertaining to such operations.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK_BULK_OPERATIONS</name>
              <description>This bit can be set once and not cleared thereafter.  When set it is no longer possible to perform bulk erase or bulk DFT operations.  The flash controller will block any write operations to the FM_CTL register pertaining to such operations.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SECTOR_M</name>
          <description># of sector of a FM</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SECTOR_M</name>
              <description># of sectors of a FM, must be an even number, same value as RTL parameter SECTOR_M.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_MAIN_N</name>
          <description>Size of MAIN in 8KB block for each pair of sectors</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAIN_N</name>
              <description>Size of MAIN_NVM in 8KB blocks for each pair of sectors, same value as RTL parameter MAIN_N.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_WORK_Z</name>
          <description>Size of WORK in 8KB block for each pair of sectors</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORK_Z</name>
              <description>Size of WORK_NVM in 8KB blocks for each pair of sectors, same value as RTL parameter WORK_Z, the value WORK_Z can be zero.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_SFLASH_Y</name>
          <description>Size of SLFASH in 8KB block in Sector 1</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>SFLASH_Y</name>
              <description>Size of SFLASH_NVM in 8KB blocks in Sector 1, same value as RTL parameter SFLASH_Y.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFLASH_SECNUM</name>
              <description>0: Not allowed
1: SM only in Sector 1</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_REFRESH_ROW</name>
          <description>Size of refresh rows for each sector</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REFRESH_ROW</name>
              <description>Size of refresh rows for each sector, same value as RTL parameter REFRESH_ROW
All sectors of a FM must have the same refresh rows
It is 4 per sector for s40flash.3 FM.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CMD</name>
          <description>Command</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2</resetMask>
          <fields>
            <field>
              <name>BUFF_INV</name>
              <description>Invalidation of ALL buffers. SW writes a '1' to clear the buffers. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_LOCK</name>
          <description>Flash Controller Lock Register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000000F</resetMask>
          <fields>
            <field>
              <name>PC</name>
              <description>When FLASH_LOCK is acquired, even PPC allows, further MMIO access is possible only to this FLASH_LOCK.PC (&amp; same HMASTER_ID) irrespective of corresponding PPC attributes. Other PCs or the same PC but different HMASTER_ID violation results in bus error &amp; operation ignored. There is no further interrupt/fault triggered for this violation.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LOCKED</name>
              <description>Software writes this register bit to 1 to 'lock' the flash controller to its own protection context (after setting the protection context by writing to a flash memory location).
Once set, any subsequent (AHB) writes result in bus error and operation ignored.
Software (FLASH.PC) reads back this field to check whether the lock succeeded.  Software (FLASH_LOCK.PC) clears this field when it has completed a program/erase operation.
To avoid deadlock and for management purpose, HW entitles PC0 the omnipotent capability to read FLASH_LOCK.PC and to release FLASH_LOCK.LOCKED no matter which PC acquires it.
All PCs allowed by PPC can access FLASH_LOCK when its LOCKED bit is LOW (not locked).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PWR_CTL</name>
          <description>Flash power control</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Controls 'enable' pin of the Flash memory.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_HV</name>
              <description>Controls 'enable_hv' pin of the Flash memory.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENFORCE_PC_LOCK_SHADOW</name>
          <description>Shadow bit of FLASH_CTL.ENFORCE_PC_LOCK</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>PC_LOCK_SHADOW</name>
              <description>Shadow register of FLASH_CTL.ENFORCE_PC_LOCK. Read only irrespective of PPC's configuration.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_INJ_EN</name>
          <description>ECC injection enable on read</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000101</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_ENABLE</name>
              <description>Enable ECC error injection for FLASH R-bus interface (while FLASH_CTL.ECC_EN enabled) .
1'b0: ECC_INJ_EN is disabled.
1'b1: ECC_INJ_EN is enabled.
Only the PC specified by ECC_INJ_PC can access (read/write)  ECC_INJ_ENABLE and ECC_ERROR when ECC_INJ_ENABLE is high excpet PC0 which can access it at any time to break the potential deadlock of ECC_INJ_EN.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_ERROR</name>
              <description>1'b0: If the injected ECC does not trigger any non-recoverable error (ECC errors &lt;= 1).
1'b1: If the injected ECC triggers non-recoverable error (ECC errors &gt;= 2). The AHB read transaction results in bus error. There is no additional fault/interrupt trigged.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_PC</name>
              <description>The PC is inherited from the master who enabled ECC_INJ_ENABLE (while ECC_INJ_ENABLE is low)</description>
              <bitRange>[31:28]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_INJ_CTL</name>
          <description>ECC injection control</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
The word address WORD_ADDR[22:0] is FM column address (module-internal offset), including cxa, bax, axa, sector, row/page definitions. On a FLASH R-bus read and when ECC_INJ_EN bit is '1', and when ECC_INJ_EN.ECC_INJ_PC value matches, the parity (PARITY[8:0]) replaces the FM parity.
When ECC_INJ_ENABLE is 1'b1, only PC specified by ECC_INJ_EN.ECC_INJ_PC can access (read/write) WORD_ADDR  and PARITY.</description>
              <bitRange>[22:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.
The 9-bit ECC PARITY[8:0] is for a 128bit long word.</description>
              <bitRange>[31:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_LOGIR</name>
          <description>Interrupt threshold for number of ECC correctable error</description>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECCTHRESHOLD</name>
              <description>Interrupt/fault threshold for number of ECC single-bit failures indicated in
bit[31:16].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC1CNT</name>
              <description>Number of ECC single-bit failures detected and corrected during the memory read operations
SW writes to register ECC_LOGIR.ECC1CNT are ignored if SW writes any number other than the real RTL counter. But write value of 16'b0 is allowed to clear ECC_LOGIR.ECC1CNT (when the number of ECC single-bit failures detected and corrected reaches threshold value).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>MPC</name>
          <description>MPC Memory Protection Controller registers</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>CFG</name>
            <description>Config register with error response, RegionID PPC_MPC_MAIN is the security owner PC. The error response configuration is located in CFG.RESPONSE, only one such configuration exists applying to all protection contexts in the system.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x10</resetMask>
            <fields>
              <field>
                <name>RESPONSE</name>
                <description>Response Configuration for Security and PC violations
0: Read-Zero Write Ignore (RAZ/WI)
1: Bus Error</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTRL</name>
            <description>Control register with lock bit and auto-increment only (Separate CTRL for each PC depends on access_pc)</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for this protection context as a side effect of each read/write access to BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for this protection context. Software can set this bit but not clear it once set.  When set, write operations to BLK_LUT are not possible  from this protection context. Setting LOCK also blocks writes to CTRL itself (for that PC copy). All writes are ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_MAX</name>
            <description>Max value of block-based index register</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; See product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_CFG</name>
            <description>Block size &amp; initialization in progress</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ... up to 15: 1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to BLK_LUT is blocked (BLK_IDX increment is also ignored). The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_IDX</name>
            <description>Index of 32-block group accessed through BLK_LUT (Separate IDX for each PC depending on access_pc)</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLK_LUT</name>
            <description>NS status for 32 blocks at BLK_IDX with PC=&lt;access_pc&gt;</description>
            <addressOffset>0x110</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ATTR_NS0</name>
                <description>NS bit for block 0 based on BLK_IDX</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS1</name>
                <description>NS bit for block 1 based on BLK_IDX</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS2</name>
                <description>NS bit for block 2 based on BLK_IDX</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS3</name>
                <description>NS bit for block 3 based on BLK_IDX</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS4</name>
                <description>NS bit for block 4 based on BLK_IDX</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS5</name>
                <description>NS bit for block 5 based on BLK_IDX</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS6</name>
                <description>NS bit for block 6 based on BLK_IDX</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS7</name>
                <description>NS bit for block 7 based on BLK_IDX</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS8</name>
                <description>NS bit for block 8 based on BLK_IDX</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS9</name>
                <description>NS bit for block 9 based on BLK_IDX</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS10</name>
                <description>NS bit for block 10 based on BLK_IDX</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS11</name>
                <description>NS bit for block 11 based on BLK_IDX</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS12</name>
                <description>NS bit for block 12 based on BLK_IDX</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS13</name>
                <description>NS bit for block 13 based on BLK_IDX</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS14</name>
                <description>NS bit for block 14 based on BLK_IDX</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS15</name>
                <description>NS bit for block 15 based on BLK_IDX</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS16</name>
                <description>NS bit for block 16 based on BLK_IDX</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS17</name>
                <description>NS bit for block 17 based on BLK_IDX</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS18</name>
                <description>NS bit for block 18 based on BLK_IDX</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS19</name>
                <description>NS bit for block 19 based on BLK_IDX</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS20</name>
                <description>NS bit for block 20 based on BLK_IDX</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS21</name>
                <description>NS bit for block 21 based on BLK_IDX</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS22</name>
                <description>NS bit for block 22 based on BLK_IDX</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS23</name>
                <description>NS bit for block 23 based on BLK_IDX</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS24</name>
                <description>NS bit for block 24 based on BLK_IDX</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS25</name>
                <description>NS bit for block 25 based on BLK_IDX</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS26</name>
                <description>NS bit for block 26 based on BLK_IDX</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS27</name>
                <description>NS bit for block 27 based on BLK_IDX</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS28</name>
                <description>NS bit for block 28 based on BLK_IDX</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS29</name>
                <description>NS bit for block 29 based on BLK_IDX</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS30</name>
                <description>NS bit for block 30 based on BLK_IDX</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR_NS31</name>
                <description>NS bit for block 31 based on BLK_IDX</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_CTRL</name>
            <description>Control register with lock bit and auto-increment only</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x100</resetValue>
            <resetMask>0x80000100</resetMask>
            <fields>
              <field>
                <name>AUTO_INC</name>
                <description>Auto-increment BLK_IDX by 1 for each read/write of ROT_BLK_LUT</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Security lockdown for the root-of-trust configuration registers. Software can set this bit but not clear it once set.  When set, write operations to ROT_BLK_LUT are not possible. Write is ignored.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_MAX</name>
            <description>Max value of block-based index register for ROT</description>
            <addressOffset>0x208</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Maximum value of block-based index register.  The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_CFG</name>
            <description>Same as BLK_CFG</description>
            <addressOffset>0x20C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x8000000F</resetMask>
            <fields>
              <field>
                <name>BLOCK_SIZE</name>
                <description>Block size of individually protected blocks (0: 32B, 1: 64B, ...up to 15:1MB)
Block size= (1&lt;&lt;(BLOCK_SIZE+5))
The number and size blocks in an MPC is design time configurable and for embedded memories defaults to covering the entire memory using 4kB blocks; see product datasheet for details on protection of external memories.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_IN_PROGRESS</name>
                <description>During initialization INIT_IN_PROGRESS is '1' and MMIO register accesses to ROT_BLK_LUT is RAZWI. The block attributes are retained in DeepSleep (and obviously Active) power mode. Initialization is only required from a power mode in which the block attributes are not retained. E.g., initialization is required for a cold boot (after a Power-on-Reset).
HW initializes the block attributes: the NS attributes are set to '0' (secure), the R attributes are set to '1' (read access allowed) and the W attributes are set to '1' (write access allowed). During initialization, the MPC supports memory accesses (memory accesses are NOT blocked) with the initialization block attribute values as mentioned above. This e.g. allows MPC initialization to proceed in parallel with boot program memory accesses (as opposed to serializing the two), improving device boot time.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_IDX</name>
            <description>Index of 8-block group accessed through ROT_BLK_LUT_*</description>
            <addressOffset>0x210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VALUE</name>
                <description>Index value for accessing block-based lookup table using ROT_BLK_LUT. Programming out of LUT range is an user error and it loops back to '0' once overflow occurs.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_PC</name>
            <description>Protection context of 8-block group accesses through ROT_BLK_LUT</description>
            <addressOffset>0x214</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Specify PC values for ROT_BLK_IDX and ROT_BLK_LUT</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ROT_BLK_LUT</name>
            <description>(R,W,NS) bits for 8 blocks at ROT_BLK_IDX for PC=ROT_BKL_PC</description>
            <addressOffset>0x218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x77777777</resetMask>
            <fields>
              <field>
                <name>ATTR0</name>
                <description>W/R/NS bits for block 0 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR1</name>
                <description>W/R/NS bits for block 1 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR2</name>
                <description>W/R/NS bits for block 2 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR3</name>
                <description>W/R/NS bits for block 3 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR4</name>
                <description>W/R/NS bits for block 4 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR5</name>
                <description>W/R/NS bits for block 5 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR6</name>
                <description>W/R/NS bits for block 6 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ATTR7</name>
                <description>W/R/NS bits for block 7 indicated by ROT_BLK_IDX for ROT_BLK_PC PC</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>FM_CTL</name>
          <description>Flash Macro Registers are maintained by SONOS FM team. Please read 002-26677 BROS for details.</description>
          <addressOffset>0x00002000</addressOffset>
          <register>
            <name>RED_CTL01</name>
            <description>Redundancy Control normal sectors 0,1</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_0</name>
                <description>Bad Row Pair Address for Sector 0</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_0</name>
                <description>'1': Redundancy Enable for Sector 0</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_1</name>
                <description>Bad Row Pair Address for Sector 1</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_1</name>
                <description>'1': Redundancy Enable for Sector 1</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_AXA</name>
                <description>'1': Redundancy Enable for SM Rows in Sector 1; Uses RED_ADDR_1 bits for Bad Row Pair Address</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL23</name>
            <description>Redundancy Control normal sectors 2,3</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_2</name>
                <description>Bad Row Pair Address for Sector 2</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_2</name>
                <description>1': Redundancy Enable for Sector 2</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_3</name>
                <description>Bad Row Pair Address for Sector 3</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_3</name>
                <description>1': Redundancy Enable for Sector 3</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>132</dim>
            <dimIncrement>4</dimIncrement>
            <name>FM_PL_DATA[%s]</name>
            <description>Flash macro Page Latches data</description>
            <addressOffset>0x800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Normal PL data read: four page latch Bytes
When reading the page latches it requires FM_CTL.IF_SEL to be '1'
Note: the high Voltage page latches are readable for test mode functionality.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLASH_MACRO_CTL</name>
            <description>Flash macro control</description>
            <addressOffset>0xA10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FF030F</resetMask>
            <fields>
              <field>
                <name>FM_MODE</name>
                <description>Requires (IF_SEL|WR_EN)=1
Flash macro mode selection</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_SEQ</name>
                <description>Requires (IF_SEL|WR_EN)=1
Flash macro sequence selection</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAA_MUX_SEL</name>
                <description>Direct memory cell access address.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_SEL</name>
                <description>Interface selection. Specifies the interface that is used for flash memory read operations:
0: R interface is used (default value). In this case, the flash memory address is provided as part of the R signal interface.
1: C interface is used. In this case, the flash memory address is provided by FM_MEM_ADDR (the page address) and by the C interface access offset in the FM_MEM_DATA structure.
Note: IF_SEL and WR_EN cannot be changed at the same time</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WR_EN</name>
                <description>0: normal mode
1: Fm Write Enable
Note: IF_SEL and WR_EN cannot be changed at the same time</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0xA14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x1800</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER_STATUS</name>
                <description>This is the timer_en bit set by writing a '1' in the TIMER_CTL bit 31. It is reset by HW when the timer expires
0: timer not running
1: Timer is enabled and not expired yet</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HV_REGS_ISOLATED</name>
                <description>Indicates the isolation status at HV trim and redundancy registers inputs
0: Not isolated, writing permitted
1: isolated writing disabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ILLEGAL_HVOP</name>
                <description>Indicates a bulk,sector erase, program has been requested when axa=1
0: no error
1: illegal HV operation error</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TURBO_N</name>
                <description>After FM power up indicates the analog blocks currents are boosted to faster reach their functional state..
Used in the testchip boot only as an 'FM READY' flag.
0: turbo mode
1: normal mode</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_EN_MON</name>
                <description>FM_CTL.WR_EN bit after being synchronized in clk_r domain</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IF_SEL_MON</name>
                <description>FM_CTL.IF_SEL bit after being synchronized in clk_r domain</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMER_PE_SYNC</name>
                <description>The actual timer state sync-ed in clk_c domain:
0: timer is not running:
1: timer is running;</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>R_GRANT_DELAY_STATUS</name>
                <description>0: R_GRANT_DELAY timer is not running
1: R_GRANT_DELAY timer is running</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FM_BUSY</name>
                <description>0': FM not busy
1: FM BUSY : R_GRANT is 0 as result of a busy request from FM ready, or from HV operations.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FM_READY</name>
                <description>0: FM not ready
1: FM ready</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>POS_PUMP_VLO</name>
                <description>POS pump VLO</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NEG_PUMP_VHI</name>
                <description>NEG pump VHI</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWW</name>
                <description>FM Type  (Read While Write or Not Read While Write):
0: Non RWW FM Type
1:  RWW FM Type</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ECC_CFG</name>
                <description>Geometry ECC configuration:
0: FM with No ECC
1: FM with ECC</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SECTOR1_SR</name>
                <description>0:  Sector 1 does not contain special rows. The special rows are located in separate special sectors.
1:  Sector 1 contains special rows</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESET_MM</name>
                <description>Test_only, internal node: mpcon  reset_mm</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ROW_ODD</name>
                <description>Test_only, internal node: mpcon  row_odd</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ROW_EVEN</name>
                <description>Test_only, internal node: mpcon  row_even</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_SUB_SECTOR_N</name>
                <description>Test_only, internal node: mpcon  bk_subb</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_SECTOR</name>
                <description>Test_only, internal node: mpcon  bk_sec</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_BULK_ALL</name>
                <description>Test_only, internal node: mpcon  bk_all</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CBUS_RA_MATCH</name>
                <description>Test_only, internal node: mpcon  ra match</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CBUS_RED_ROW_EN</name>
                <description>Test_only, internal node: mpcon  red_row_en</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RQ_ERROR</name>
                <description>Test_only, internal node:  rq_error  sync-de in clk_c domain</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PUMP_PDAC</name>
                <description>Test_only, internal node: regif pdac outputs to pos pump</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PUMP_NDAC</name>
                <description>Test_only, internal node: regif ndac outputs to pos pump</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_ADDR</name>
            <description>Flash macro address</description>
            <addressOffset>0xA18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Row address.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BA</name>
                <description>Bank address.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AXA</name>
                <description>Auxiliairy address field:
0: regular flash memory.
1: supervisory flash memory.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BOOKMARK</name>
            <description>Bookmark register - keeps the current FW HV seq</description>
            <addressOffset>0xA1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BOOKMARK</name>
                <description>Used by FW. Keeps the Current HV cycle sequence</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GEOMETRY</name>
            <description>Regular flash geometry</description>
            <addressOffset>0xA20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x940100FF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ROW_COUNT</name>
                <description>Number of rows (minus 1):
0: 1 row
1: 2 rows
2: 3 rows
...
'65535': 65536 rows
For 128kB macro the value of this field  is x7F (128 rows)
For 256kB macro the value of this field  is xFF (256 rows)
For 512kB macro the value of this field  is x1FF (512 rows)
For 1MB macro the value of this field  is x1FF (512 rows)</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BANK_COUNT</name>
                <description>Number of banks (minus 1):
0: 1 bank
1: 2 banks
...
'255': 256 banks
For 128kB, 256kB and 512kB macros the value of this field  is 1 (2 banks)
For 1MB macro the value of this field  is 3 (4 banks)</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_SIZE_LOG2</name>
                <description>Number of Bytes per word (log 2). A word is defined as the data that is read from the flash macro over the R interface with a single read access:
0: 1 Byte
1: 2 Bytes
2: 4 Bytes
...
3: 128 Bytes

The currently planned flash macros have a word size of either 32-bit, 64-bit or 128-bit, resulting in WORD_SIZE_LOG2 settings of 2, 3 and 4 respectively.
All 4 macros used in PSOC C3 family will see this field as 4</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PAGE_SIZE_LOG2</name>
                <description>Number of Bytes per page (log 2):
0: 1 Byte
1: 2 Bytes
2: 4 Bytes
...
15: 32768 Bytes

The currently planned flash macros have a page size of either 256 Byte or 512 Byte, resulting in PAGE_SIZE_LOG2 settings of 8 and 9 respectively.
All 4 macros used in PSOC C3 family will see this field as 9</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GEOMETRY_SUPERVISORY</name>
            <description>Supervisory flash geometry</description>
            <addressOffset>0xA24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x9400003F</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ROW_COUNT</name>
                <description>Number of rows (minus 1). ROW_COUNT is typically less than GEOMETRY.ROW_COUNT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BANK_COUNT</name>
                <description>Number of banks (minus 1). BANK_COUNT is less or equal to GEOMETRY.BANK_COUNT.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_SIZE_LOG2</name>
                <description>Number of Bytes per word (log 2). See GEOMETRY.WORD_SIZE_LOG2. Typically, WORD_SIZE_LOG2 equals GEOMETRY.WORD_SIZE_LOG2.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PAGE_SIZE_LOG2</name>
                <description>Number of Bytes per page (log 2). See GEOMETRY.PAGE_SIZE_LOG2. Typically, PAGE_SIZE_LOG2 equals GEOMETRY.PAGE_SIZE_LOG2.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CTL0</name>
            <description>Analog control 0</description>
            <addressOffset>0xA28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MDAC</name>
                <description>Trimming of the output margin Voltage as a function of Vpos and Vneg.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE_ANA_CTL0</name>
                <description>Spare bit</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ECC_ENC_DIS</name>
                <description>0': ECC encoder is enabled for the FM with ECC feature. The PL ECC bits are loaded automatically
'1': ECC encoder disabled. - The Macro needs to be in C-BUS mode - IF_SEL=1 to write and keep this bit at 1</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DNU_2_TM_ECC_DIS</name>
                <description>Do Not Use this bit as it is for test Mode use only. Write only to 0 in normal mode  (tm_ecc_dis in RTL)</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RST_SFT_HVPL</name>
                <description>1:  Page Latches Soft Reset</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLIP_AMUXBUS_AB</name>
                <description>Flips amuxbusa and amuxbusb
0: amuxbusa, amuxbusb
1:  amuxbusb, amuxbusb</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NDAC_MIN</name>
                <description>NDAC staircase min value</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_MIN</name>
                <description>PDAC staircase min value</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ01</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq0-seq1 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ12</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq1-seq2 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ23</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq2-seq3 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_SEQ30</name>
                <description>PROG&amp;PRE_PROG&amp; ERASE: Scale for R_GRANT_DELAY on seq3-seq0 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_PEON</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on PE On transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_PEOFF</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on PE OFF transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CTL1</name>
            <description>Analog control 1</description>
            <addressOffset>0xA2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xD32FAFA</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NDAC_MAX</name>
                <description>Ndac Max Value.Trimming of negative pump output Voltage.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NDAC_STEP</name>
                <description>Ndac step increment</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_MAX</name>
                <description>Pdac Max Value.Trimming of positive pump output Voltage:</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_STEP</name>
                <description>Pdac step increment</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_STEP_TIME</name>
                <description>Ndac/Pdac step duration: (1uS .. 255uS) * 8
When = 0 N/PDAC_MAX control the pumps</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_ZERO_TIME</name>
                <description>Ndac/Pdac LO duration: (1uS .. 255uS) * 8
When 0, N/PDAC don't return to 0</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_PL_WRDATA_ALL</name>
            <description>Flash macro write page latches all</description>
            <addressOffset>0xA30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Write all high Voltage page latches with the same 32-bit data in a single write cycle. In order to also write same lower 8bit from 32-bit data to all the ECC bits in the page latches, set ANA_CTL0.ECC_ENC_DIS=1.
Read always returns 0. Used for test mode and sims only</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_REFRESH_ADDR</name>
            <description>Address bit to point to scratch area</description>
            <addressOffset>0xA34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x11</resetMask>
            <fields>
              <field>
                <name>FM_BXA</name>
                <description>Address bit to point to scratch area
0: Point to normal rows in sector
1: Point to scratch rows in sector. For engineering use only.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_CXA</name>
                <description>Address bit to point to Column 33
0: Point to normal columns in sector
1: Point to Column 33 used for BL Disturb Counter. For engineering use only.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_DELAY_ERS</name>
            <description>R-grant delay for erase</description>
            <addressOffset>0xA38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ01</name>
                <description>ERASE: R-grant blocking delay on seq0-seq1 transition. Scale = ANA_CTL0.SCALE_SEQ01
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ12</name>
                <description>ERASE: R-grant blocking delay on seq1-seq2 transition. Scale = ANA_CTL0.SCALE_SEQ12
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ23</name>
                <description>ERASE: R-grant blocking delay on seq2-seq3 transition. Scale = ANA_CTL0.SCALE_SEQ23
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_SCALE_ERS</name>
            <description>R-grant delay scale for erase</description>
            <addressOffset>0xA3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF03FF</resetMask>
            <fields>
              <field>
                <name>SCALE_ERS_SEQ01</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq0-seq1 transition:
'00': 0.125uS
'01': 1uS
'10': 10uS
'11': 100uS</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_SEQ12</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq1-seq2 transition:
'00': 0.125uS
'01': 1uS
'10': 10uS
'11': 100uS</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_SEQ23</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq2-seq3 transition:
'00': 0.125uS
'01': 1uS
'10': 10uS
'11': 100uS</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_PEON</name>
                <description>ERASE: Scale for R_GRANT_DELAY on PE On transition:
'00': 0.125uS
'01': 1uS
'10': 10uS
'11': 100uS</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_PEOFF</name>
                <description>ERASE: Scale for R_GRANT_DELAY on PE OFF transition:
'00': 0.125uS
'01': 1uS
'10': 10uS
'11': 100uS</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_PEON</name>
                <description>ERASE: R-grant blocking delay on PE ON. Scale = ANA_CTL0.SCALE_PEON
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_PEOFF</name>
                <description>ERASE: R-grant blocking delay on PE OFF. Scale = ANA_CTL0.SCALE_PEOFF
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PW_SEQ23</name>
            <description>HV Pulse Delay for seq2 post &amp; seq3</description>
            <addressOffset>0xA40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PW_SEQ2_POST</name>
                <description>Seq2 post delay</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PW_SEQ3</name>
                <description>Seq3 delay</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PW_SEQ12</name>
            <description>HV Pulse Delay for seq 1&amp;2 pre</description>
            <addressOffset>0xA44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PW_SEQ1</name>
                <description>Seq1 delay</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PW_SEQ2_PRE</name>
                <description>Seq2 pre delay</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WAIT_CTL</name>
            <description>Wait State control</description>
            <addressOffset>0xA48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x30B09</resetValue>
            <resetMask>0x27070F0F</resetMask>
            <fields>
              <field>
                <name>WAIT_FM_MEM_RD</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a read from the memory</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FM_HV_RD</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a read from the Page Latches.
Common for reading HV Page Latches and the DATA_COMP_RESULT bit</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FM_HV_WR</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a write to the Page Latches.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_RWW_MODE</name>
                <description>2'b00: Full CBUS MODE
2'b01: RWW
2'b10: RWW. R_GRANT is stalling r_bus for the whole program/erase duration</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LV_SPARE_1</name>
                <description>Spare register</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PL_SOFT_SET_EN</name>
                <description>Page latch soft set enable, 0 = disabled, 1 = enabled (at end of seq_2), taken care in API</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_DELAY_PRG</name>
            <description>R-grant delay for program</description>
            <addressOffset>0xA4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8FFFFFFF</resetMask>
            <fields>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ12</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq1-seq2 transition. Scale = ANA_CTL0.SCALE_SEQ12
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ23</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq2-seq3 transition. Scale = ANA_CTL0.SCALE_SEQ23
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_SEQ30</name>
                <description>PROG&amp;PRE_PROG &amp; ERASE: R-grant blocking delay on seq3-seq0 transition. Scale = ANA_CTL0.SCALE_SEQ30
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_CLK</name>
                <description>Frequency divider from clk_t  to create the 8MHz reference clock for R_grant delay.
The value of 0 is equivalent with 1. If the clock clk_t = 8MHz the value needs to be 1
The value of this field is the integer result of 'clk_t frequency / 8'.
Example: for clk_t=100 this field is INT(100/8) =12.
This field is updated at runtime with the  'SW_RGRANT_DELAY_CLK ' value from the HV parameters table</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HV_PARAMS_LOADED</name>
                <description>0': HV Pulse common params not loaded
'1': HV Pulse common params  loaded: r-grant delays, r-grant scale, prescaler, timer values for seq1,seq2_pre, seq2_post, seq3</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIMER_CLK_CTL</name>
            <description>Timer prescaler (clk_t to timer clock frequency divider)</description>
            <addressOffset>0xA50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER_CLOCK_FREQ</name>
                <description>Clk_t frequency divider to provide the 1MHz reference clock for the Regif Timer.
Equal to the frequency in MHz of the timer clock 'clk_t'.
Example: if 'clk_t' has a frequency of 4 MHz then this field value is '4'
Max clk_t frequency = 100MHz.
This field is updated at runtime with the  'SW_TIMER_CLOCK_FREQ ' value from the HV parameters table</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_PEON</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on PE ON. Scale = ANA_CTL0.SCALE_PEON
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_PEOFF</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on PE OFF. Scale = ANA_CTL0.SCALE_PEOFF
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ01</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq0-seq1 transition. Scale = ANA_CTL0.SCALE_SEQ01
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIMER_CTL</name>
            <description>Timer control</description>
            <addressOffset>0xA54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x4000001</resetValue>
            <resetMask>0xE700FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Timer period in either microseconds (SCALE is '0') or 100's of microseconds (SCALE is '1') multiples.</description>
                <bitRange>[14:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE</name>
                <description>Timer tick scale:
0: 1 microsecond.
1: 100 microseconds.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_SEQUENCE</name>
                <description>1': Starts1 the HV automatic sequencing
Cleared by HW</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRE_PROG</name>
                <description>1 during pre-program operation</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRE_PROG_CSL</name>
                <description>0: CSL lines driven by MDAC
1: CSL lines driven by VNEG_G</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PUMP_EN</name>
                <description>Pump enable:
0: disabled
1: enabled (also requires FM_CTL.IF_SEL to be'1', this additional restriction is required to prevent non intentional clearing of the FM).
SW sets this field to '1' to generate a single PE pulse.
HW clears this field when timer is expired.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACLK_EN</name>
                <description>ACLK enable (generates a single cycle pulse for the FM):
0: disabled
1: enabled. SW set this field to '1' to generate a single cycle pulse. HW sets this field to '0' when the pulse is generated.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMER_EN</name>
                <description>Timer enable:
0: disabled
1: enabled. SW sets this field to '1' to start the timer. HW sets this field to '0' when the timer is expired.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ACLK_CTL</name>
            <description>MPCON clock</description>
            <addressOffset>0xA58</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACLK_GEN</name>
                <description>Write '1b1'  to generate one clock pulse for HV control registers (mpcon outputs)</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xA5C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xA60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xA64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xA68</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Logical and of corresponding request and mask fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL0</name>
            <description>Cal control - VCT, VBG, CDAC, IPREF</description>
            <addressOffset>0xA6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x16D96</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VCT_TRIM_HV</name>
                <description>Bandgap Voltage Temperature Compensation trim control.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CDAC_HV</name>
                <description>Temperature compensated trim DAC. To control Vctat slope for VNEG.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TRIM_HV</name>
                <description>Bandgap Voltage trim control.</description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TC_TRIM_HV</name>
                <description>Bandgap Voltage Temperature Compensation trim control</description>
                <bitRange>[17:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIMA_HV</name>
                <description>Adds 100-150nA boost on IPREF</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE_CTL0_HV</name>
                <description>Spare trim bits, DNU</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL1</name>
            <description>Cal control - ICREF, IPREF</description>
            <addressOffset>0xA70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x43CE7</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>ICREF_TRIM_HV</name>
                <description>Bandgap Current  trim control.</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICREF_TC_TRIM_HV</name>
                <description>Bandgap Current Temperature Compensation trim control</description>
                <bitRange>[9:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIM_HV</name>
                <description>Bandgap IPTAT trim control.</description>
                <bitRange>[14:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TC_HV</name>
                <description>IPREF Slope Control</description>
                <bitRange>[18:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE_CTL1_HV</name>
                <description>Spare trim bit, DNU</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL2</name>
            <description>Cal control - IDAC, IBS_CTL, LAT_DIS</description>
            <addressOffset>0xA74</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xA028</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>IDAC_ULP_HV</name>
                <description>Sets the sense current reference offset value. Refer to trim tables for details.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE_ULP_CTL2_HV</name>
                <description>Spare bit to be used in ULP configuration</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL_ULP_HV</name>
                <description>0: Uses VBG as reference for VLIM - ULP Mode
1: Uses VCTAT as reference for VLIM - ULP mode</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IDAC_LP_HV</name>
                <description>Sets the sense current reference offset value. Refer to trim tables for details.</description>
                <bitRange>[17:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE_LP_CTL2_HV</name>
                <description>Spare bit to be used in LP configuration</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL_LP_HV</name>
                <description>0: Uses VBG as reference for VLIM - LP Mode
1: Uses VCTAT as reference for VLIM - LP mode</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL3</name>
            <description>Cal control - OSC trims, FDIV, REG_ACT, TURBO, LP_ULP_SW</description>
            <addressOffset>0xA78</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2794</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>OSC_TRIM_HV</name>
                <description>Flash macro pump clock trim control.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OSC_RANGE_TRIM_HV</name>
                <description>0: Oscillator Low Frequency range
1: Oscillator High Frequency Range</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VPROT_ACT_HV</name>
                <description>Forces VPROT in active mode all the time</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OSC_TEMPCO_HV</name>
                <description>0: Uses VBG as reference
1: Uses VCTAT as reference</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LAT_DIS3_HV</name>
                <description>0: Enable saen3 control for data out latches
1: Disable saen3 control for data out latches</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PM_EN_HV</name>
                <description>0: Sense Amp bias similar to _ver2
1: pbias enabled in Sense Amp for Better Margin</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REG_ACT_HV</name>
                <description>0: VBST regulator will operate in active/standby mode based on control signal.
1: Forces the VBST regulator in active mode all the time</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FDIV_TRIM_HV</name>
                <description>FDIV_TRIM_HV[1:0]: Assuming oscillator frequency of 8MHz in standby.
Following are the clock frequencies seen by doubler
00: F = 0.5MHz
01: F = 1MHz
10: F = 2MHz
11: F = 4MHz</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VDDHI_HV</name>
                <description>0: vdd &lt; 2.3V
1: vdd &gt;= 2.3V
'0' setting can used for vdd &gt; 2.3V also, but with a current penalty.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TURBO_PULSEW_HV</name>
                <description>Turbo pulse width trim (Typical)
00: 40 us
01: 20 us
10: 15 us
11: 8 us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IOSC_TRIM_HV</name>
                <description>Oscillator Bias Current Trim during Standby
0.33 uA -- 1.65 uA</description>
                <bitRange>[16:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CL_ISO_DIS_HV</name>
                <description>0: The internal logic controlls the CL isolation
1: Forces CL bypass</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>R_GRANT_EN_HV</name>
                <description>0: r_grant handshake disabled, r_grant always 1.
1: r_grant handshake  enabled</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LP_ULP_SW_HV</name>
                <description>LP&lt;--&gt;ULP switch for trim signals:
0: LP
1: ULP</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL4</name>
            <description>Cal control - VLIM, IDAC, SDAC, ITIM ULP trims</description>
            <addressOffset>0xA7C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x18F22</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VLIM_TRIM_ULP_HV</name>
                <description>VLIM_TRIM[1:0]:
00: V2 = 650mV
01: V2 = 700mV
10: V2 = 750mV - Default
11: V2 = 800mV</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE_CTL4_ULP_HV</name>
                <description>N/A</description>
                <bitRange>[4:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SDAC_ULP_HV</name>
                <description>Sets the sense current reference temp slope. Refer to trim tables for details.</description>
                <bitRange>[6:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ITIM_ULP_HV</name>
                <description>Trimming of timing current</description>
                <bitRange>[12:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DEL_ULP_HV</name>
                <description>00: Default : delay 1ns
01: Delayed by 1.5us
10: Delayed by 2.0us
11: Delayed by 2.5us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T8_ULP_HV</name>
                <description>saen3 pulse width trim (Current trim)</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>READY_RESTART_N_HV</name>
                <description>Toggle: 1--&gt;0, ready goes low, ready will remain low as long as the bit is low. Toggle the bit back to 1 to activate the ready logic. To be used by API only.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBST_S_DIS_HV</name>
                <description>0: VBST_S voltage for each sector to allow VBST level to be dropped to VCC during Erase in the selected sector, reducing coupling to GBL.
1: VBST_S voltage for each sector stays at VBST level during Erase in the selected sector.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_HVPULSE_HV</name>
                <description>0: HV Pulse controlled by FW
1: HV Pulse controlled by Hardware</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UGB_EN_HV</name>
                <description>UGB enable in TM control</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL5</name>
            <description>Cal control - VLIM, IDAC, SDAC, ITIM LP trims</description>
            <addressOffset>0xA80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1422</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VLIM_TRIM_LP_HV</name>
                <description>VLIM_TRIM[1:0]:
00: V2 = 650mV
01: V2 = 700mV
10: V2 = 750mV - Default
11: V2 = 800mV</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE_CTL5_LP_HV</name>
                <description>Spare Bit, not used</description>
                <bitRange>[4:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SDAC_LP_HV</name>
                <description>Sets the sense current reference temp slope. Refer to trim tables for details.</description>
                <bitRange>[6:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ITIM_LP_HV</name>
                <description>Trimming of timing current</description>
                <bitRange>[12:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DEL_LP_HV</name>
                <description>00: Delayed by 1us
01: Delayed by 1.5us
10: Delayed by 2.0us
11: Delayed by 2.5us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T8_LP_HV</name>
                <description>saen3 pulse width trim (Current trim)</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE2_CTL5_LP_HV</name>
                <description>Spare Bit, not used</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AMUX_SEL_HV</name>
                <description>Amux Select in AMUX_UGB
00: Bypass UGB for both amuxbusa and amuxbusb
01: Bypass UGB for amuxbusb while passing amuxbusa through UGB.
10: Bypass UGB for amuxbusa while passing amuxbusb through UGB.
11: UGB Calibrate mode</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL6</name>
            <description>Cal control - SA CTL LP/ULP trims</description>
            <addressOffset>0xA84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x6CAD7</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>SA_CTL_TRIM_T1_ULP_HV</name>
                <description>clk_trk delay</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T4_ULP_HV</name>
                <description>SA_CTL_TRIM_T4_ULP_HV&lt;2&gt;= eqi (eq current trim)
SA_CTL_TRIM_T4_ULP_HV&lt;1:0&gt; = eqc (eq cap trim)</description>
                <bitRange>[4:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T5_ULP_HV</name>
                <description>SA_CTL_TRIM_T5_ULP_HV&lt;2&gt;= evi (integration current trim)
SA_CTL_TRIM_T5_ULP_HV&lt;1:0&gt; = evc (integration cap trim)</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T6_ULP_HV</name>
                <description>SA_CTL_TRIM_T6_ULP_HV&lt;1&gt;= eni (enable current trim)
SA_CTL_TRIM_T6_ULP_HV&lt;0&gt; = ecn (enable cap trim)</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T1_LP_HV</name>
                <description>clk_trk delay</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T4_LP_HV</name>
                <description>SA_CTL_TRIM_T4_LP_HV&lt;2&gt;= eqi (eq current trim)
SA_CTL_TRIM_T4_LP_HV&lt;1:0&gt; = eqc (eq cap trim)</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T5_LP_HV</name>
                <description>SA_CTL_TRIM_T5_LP_HV&lt;2&gt;= evi (integration current trim)
SA_CTL_TRIM_T5_LP_HV&lt;1:0&gt; = evc (integration cap trim)</description>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T6_LP_HV</name>
                <description>SA_CTL_TRIM_T6_LP_HV&lt;1&gt;= eni (enable current trim)
SA_CTL_TRIM_T6_LP_HV&lt;0&gt; = ecn (enable cap trim)</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL7</name>
            <description>Cal control - ERSX8_CLK_SEL, FM_ACTIVE, TURBO_EXT</description>
            <addressOffset>0xA88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x18C00</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>ERSX8_CLK_SEL_HV</name>
                <description>Clock frequency into the ersx8 shift register block
00: Oscillator clock
01: Oscillator clock / 2
10: Oscillator clock / 4
11: Oscillator clock / 8</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_ACTIVE_HV</name>
                <description>0: Normal operation
1: Forces FM SYS in active mode</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TURBO_EXT_HV</name>
                <description>0: Normal operation
1: Uses external turbo pulse</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_HWCTL_DIS_HV</name>
                <description>0': ndac, pdac staircase hardware controlled
1: ndac, pdac staircase disabled. Enables FW control.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DIS_HV</name>
                <description>0': fm ready is enabled
1: fm ready is disabled (fm_ready is always '1')</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERSX8_EN_ALL_HV</name>
                <description>0': Staggered turn on/off of GWL
1: GWL are turned on/off at the same time (old FM legacy)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>READY_DEL_HV</name>
                <description>0: Ready Delay trim.
1: Ready Delay trim.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE_CTL7_HV</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PTRIM_ULP_HV</name>
                <description>SA PBIAS Trim for ULP Operation</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE2_CTL7_ULP_HV</name>
                <description>N/A</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PTRIM_LP_HV</name>
                <description>SA PBIAS Trim for LP Operation</description>
                <bitRange>[16:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE3_CTL7_LP_HV</name>
                <description>N/A</description>
                <bitRange>[19:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>33</dim>
            <dimIncrement>4</dimIncrement>
            <name>FM_PL_ECC[%s]</name>
            <description>Flash macro Page Latches ECC</description>
            <addressOffset>0xB00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>DATA9</name>
                <description>if_sel must be 1
Normal PL ECC  data read: one page latch Byte
When reading the page latches it requires FM_CTL.IF_SEL to be '1'
Note: the high Voltage page latches are readable for test mode functionality.
Only even addresses, address step =8.</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA9_1</name>
                <description>ECC encoder output. Can be read any time at address 0xa00</description>
                <bitRange>[24:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>132</dim>
            <dimIncrement>4</dimIncrement>
            <name>FM_MEM_DATA[%s]</name>
            <description>Flash macro memory sense amplifier data</description>
            <addressOffset>0xC00</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Sense amplifier and column multiplexer structure Bytes. The read data is dependent on FM_CTL.IF_SEL
- IF_SEL is 0: data as specified by the R interface address; If accessed when IF_SEL=0, the data read is not valid.
- IF_SEL is 1: data as specified by FM_MEM_ADDR and the offset of the accessed FM_MEM_DATA register.

Four FM data out Bytes.
Each access is a full FM core read through C-BUS.
The row address is given by the FM_ADDRESS register, the word and column addresses are driven by c_addr bus.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>33</dim>
            <dimIncrement>4</dimIncrement>
            <name>FM_MEM_ECC[%s]</name>
            <description>Flash macro memory sense amplifier ECC.</description>
            <addressOffset>0xF00</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>ECC_PARITY</name>
                <description>Sense amplifier ECC Bits.  FM_CTL.IF_SEL must be 1.
FM ECC data.
Each access is a full FM core read through C-BUS.
The row address is given by the FM_ADDRESS register, the word and column addresses are driven by c_addr bus.</description>
                <bitRange>[8:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>MXCM33</name>
      <description>MXCM33-0/1</description>
      <baseAddress>0x42160000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CM33_CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F001F10</resetMask>
          <fields>
            <field>
              <name>CPU_WAIT</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKNSVTOR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKSVTAIRCR</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKSMPU</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKNSMPU</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKSAU</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IOC_MASK</name>
              <description>CPU floating point unit (FPU) exception mask for the CPU's FPCSR.IOC 'invalid operation' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt.
'1': the CPU's exception condition activates the CPU's floating point interrupt.

Note: the ARM architecture does NOT support FPU exceptions; i.e. there is no precise FPU exception handler. Instead, FPU conditions are captured in the CPU's FPCSR register and the conditions are provided as CPU interface signals. The interface signals are 'masked' with the fields provided by this register (CM33_CTL). The 'masked' signals are reduced/OR-ed into a single CPU floating point interrupt signal. The associated CPU interrupt handler allows for imprecise handling of FPU exception conditions.

Note: the CPU's FPCSR exception conditions are 'sticky'. Typically, the CPU FPU interrupt handler will clear the exception condition(s) to '0'.

Note: by default, the FPU exception masks are '0'. Therefore, FPU exception conditions will NOT activate the CPU's floating point interrupt.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZC_MASK</name>
              <description>N/A</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OFC_MASK</name>
              <description>N/A</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UFC_MASK</name>
              <description>N/A</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IXC_MASK</name>
              <description>N/A</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDC_MASK</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_CMD</name>
          <description>Command</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050002</resetValue>
          <resetMask>0xFFFF0002</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Processor enable:
'0': Disabled. Processor clock is turned off and reset is activated. After SW clears this field to '0', HW automatically sets this field to '1'. This effectively results in a CM33 reset, followed by a CM33 warm boot.
'1': Enabled.
Note: The intent is that this bit is modified only through an external probe or by the other CM33 while this CM33 is in Sleep or DeepSleep power mode. If this field is cleared to '0' by this CM33 itself, it should be done under controlled conditions (such that undesirable side effects can be prevented).

Note: The CM33 CPU has a AIRCR.SYSRESETREQ register field that allows the CM33 to reset the complete device (ENABLED only disables/enables the CM33), resulting in a warm boot. This CPU register field has similar 'built-in protection' as this register to prevent accidental system writes (the upper 16-bits of the register need to be written with a 0x05fa key value; see CPU user manual for more details).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_STATUS</name>
          <description>Status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM33_INT_STATUS[%s]</name>
          <description>CM33 interrupt status</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM33 activated system interrupt index for given CPU interrupt.

Multiple system interrupts can be mapped on the same CPU interrupt. The selected system interrupt is the system interrupt with the lowest system interrupt index that has an activated interrupt request at the time of the fetch (system_interrupts[SYSTEM_INT_IDX] is '1').

The CPU interrupt handler SW can read SYSTEM_INT_IDX to determine the system interrupt that activated the handler.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>Valid indication for SYSTEM_INT_IDX. When '0', no system interrupt for CPU interrupt 0 is valid/activated.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM33_NMI_CTL[%s]</name>
          <description>CM33 NMI control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_EVENT_CTL</name>
          <description>CM33 event control</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>MASK</name>
              <description>One mask bit for each CPU (other than itself).
0: Mask is not set.
1: RX event from the corresponding CPU is masked.
Bit 0: Other CM33 CPU event
Bit 1: CM55_0 CPU event
Bit 2: CM55_1 CPU event
Bit 3: CM55_2 CPU event
Bit 4: CM55_3 CPU event</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_S_VECTOR_TABLE_BASE</name>
          <description>CM33 secure vector table base</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF80</resetMask>
          <fields>
            <field>
              <name>ADDR25</name>
              <description>Address of CM33 secure vector table to be used at reset.
Default value:
ADDR25: 0x0200000 if PROM is present (points to Secure ROM start address i.e. 0x1000_0000).
ADDR25: 0x0680000 if PROM is not present (points to Secure RAMC0 start address i.e. 0x3400_0000).</description>
              <bitRange>[31:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_NS_VECTOR_TABLE_BASE</name>
          <description>CM33 non-secure vector table base</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF80</resetMask>
          <fields>
            <field>
              <name>ADDR25</name>
              <description>Address of CM33 non-secure vector table to be used at reset.  Default value:
ADDR25: 0x0000000 if PROM is present (points to Non-Secure ROM start address i.e. 0x0000_0000).
ADDR25: 0x0480000 if PROM is not present (points to Non-Secure RAMC0 start address i.e. 0x2400_0000).</description>
              <bitRange>[31:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_PC_CTL</name>
          <description>CM33 protection context control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Valid fields for the protection context handler CM33_PCi_HANDLER registers:
Bit 0: Valid field for CM33_PC0_HANDLER.
Bit 1: Valid field for CM33_PC1_HANDLER.
Bit 2: Valid field for CM33_PC2_HANDLER.
Bit 3: Valid field for CM33_PC3_HANDLER.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_PC0_HANDLER</name>
          <description>CM33 protection context 0 handler</description>
          <addressOffset>0x2040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 0 handler. This field is used to detect entry to Cypress 'trusted' code through an exception/interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_PC1_HANDLER</name>
          <description>CM33 protection context 1 handler</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 1 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_PC2_HANDLER</name>
          <description>CM33 protection context 2 handler</description>
          <addressOffset>0x2140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 2 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM33_PC3_HANDLER</name>
          <description>CM33 protection context 3 handler</description>
          <addressOffset>0x2180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 3 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM33_SYSTEM_INT_CTL[%s]</name>
          <description>CM33 system interrupt control</description>
          <addressOffset>0x8000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>CPU interrupt index (legal range [0, 15]). This field specifies to which CPU interrupt the system interrupt is mapped. E.g., if CPU_INT_IDX is '6', the system interrupt is mapped to CPU interrupt '6'.

Note: it is possible to map multiple system interrupts to the same CPU interrupt. It is advised to assign different priorities to the CPU interrupts and to assign system interrupts to CPU interrupts accordingly.

Note: CPU_INT_IDX register width is derived from mxcm33 parameter IRQ_IDX_WIDTH.
IRQ_IDX_WIDTH  = (CM33_INT_NR == 16) ? 4 : 3</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>Interrupt enable:
'0': Disabled. The system interrupt will NOT be mapped to any CPU interrupt.
'1': Enabled. The system interrupt is mapped on CPU interrupt CPU_INT_IDX.

Note: the CPUs have dedicated XXX_SYSTEM_INT_CTL registers. In other words, the CPUs can use different CPU interrupts for the same system interrupt. However, typically only one of the CPUs will have the ENABLED field of a specific system interrupt set to '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DW0</name>
      <description>DW-0/1</description>
      <headerStructName>DW</headerStructName>
      <baseAddress>0x42180000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x80000003</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable SECDED ECC checking (Single Error Correction Double Error Detection Error Correcting Code Functionality).
'0': Disabled
'1': Enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable parity injection for SRAM.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of the SRAM.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. Disabling the IP activates the IP's Active logic reset: Active logic and non-retention MMIO registers are reset (retention MMIO registers are not affected).
Note that DW SRAM writes/reads are possible when ENABLED=0 also.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>Active channel, user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>Active channel, secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>B</name>
              <description>Active channel, non-bufferable/bufferable access control:
'0': non-bufferable
'1': bufferable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>Active channel protection context.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRIO</name>
              <description>Active channel priority.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>Active channel preemptable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_IDX</name>
              <description>Active channel index.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the DW controller.
'0': Default/inactive state.
'1': Loading descriptor.
'2': Loading data element from source location.
'3': Storing data element to destination location.
'4': CRC functionality (only used for CRC transfer descriptor type).
'5': Update of active control information (e.g. source and destination addresses) and wait for trigger de-activation.
'6': Error.</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Active channel present:
'0': No.
'1': Yes.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_CTL</name>
          <description>Active descriptor control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_SRC</name>
          <description>Active descriptor source</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_SRC of the currently active descriptor.

Base address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_DST</name>
          <description>Active descriptor destination</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_DST of the currently active descriptor.

Base address of destination location.

Note: For a CRC transfer descriptor, this field should be programmed with the address of the CRC_LFSR_CTL register. The calculated CRC LFSR state is written to this address (through the CRYPTO AHB-Lite master interface) when the input trigger is processed. The write transfer will be submitted to the CPUSS and PERI protection schemes.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_X_CTL</name>
          <description>Active descriptor X loop control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_X_CTL of the currently active descriptor.

[11:0] SRC_X_INCR
Specifies increment of source address for each X loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047]. If this field is '0', the source address is not incremented. This is useful for reading from RX FIFO structures.

[23:12] DST_X_INCR
Specifies increment of destination address for each X loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047]. If this field is '0', the destination address is not incremented. This is useful for writing to TX FIFO structures.

Note: this field is not used for CRC transfer descriptors and must be set to '0'.

[31:24] X_COUNT
Number of iterations (minus 1) of the 'X loop' (X_COUNT+1 is the number of single transfers in a 1D transfer). This field is an unsigned number in the range [0, 255], representing 1 through 256 iterations.

For a single transfer descriptor type, descriptor will not have X_CTL.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_Y_CTL</name>
          <description>Active descriptor Y loop control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_Y_CTL of the currently active descriptor.

[11:0] SRC_Y_INCR
Specifies increment of source address for each Y loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047].

[23:12] DST_Y_INCR
Specifies increment of destination address for each Y loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047].

[31:24] Y_COUNT
Number of iterations (minus 1) of the 'Y loop' (X_COUNT+1)*(Y_COUNT+1) is the number of single transfers in a 2D transfer). This field is an unsigned number in the range [0, 255], representing 1 through 256 iterations.

For single, 1D and CRC transfer descriptor types, descriptor will not have Y_CTL.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_NEXT_PTR</name>
          <description>Active descriptor next pointer</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Copy of DESCR_NEXT_PTR of the currently active descriptor.

[31:2] ADDR
Address of next descriptor in descriptor list. When this field is '0', this is the last descriptor in the descriptor list.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_SRC</name>
          <description>Active source</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>SRC_ADDR</name>
              <description>Current address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DST</name>
          <description>Active destination</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DST_ADDR</name>
              <description>Current address of destination location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFE0003FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM word address and when CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CTL</name>
          <description>CRC control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>DATA_REVERSE</name>
              <description>Specifies the bit order in which a data Byte is processed (reversal is performed after XORing):
'0': Most significant bit (bit 1) first.
'1': Least significant bit (bit 0) first.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REM_REVERSE</name>
              <description>Specifies whether the remainder is bit reversed (reversal is performed after XORing):
'0': No.
'1': Yes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_DATA_CTL</name>
          <description>CRC data control</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_XOR</name>
              <description>Specifies a byte mask with which each data byte is XOR'd. The XOR is performed before data reversal.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL_CTL</name>
          <description>CRC polynomial control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>CRC polynomial. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned/shifted such that the more significant bits (bit 31 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's. Some frequently used polynomials:
- CRC32: POLYNOMIAL is 0x04c11db7 (x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1).
- CRC16: POLYNOMIAL is 0x80050000 (x^16 + x^15 + x^2 + 1, shifted by 16 bit positions).
- CRC16 CCITT: POLYNOMIAL is 0x10210000 (x^16 + x^12 + x^5 + 1, shifted by 16 bit positions).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_LFSR_CTL</name>
          <description>CRC LFSR control</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR32</name>
              <description>State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to implement CRC. This register needs to be initialized by SW to provide the CRC seed value.

The seed value should be aligned such that the more significant bits (bit 31 and down) contain the seed value and the less significant bits (bit 0 and up) contain padding '0's.

Note that SW can write this field. This functionality can be used prevent information leakage (through either CRC_LFSR_CTL or CRC_REM_RESULT).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_CTL</name>
          <description>CRC remainder control</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM_XOR</name>
              <description>Specifies a mask with which the CRC_LFSR_CTL.LFSR32 register is XOR'd to produce a remainder. The XOR is performed before remainder reversal.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_RESULT</name>
          <description>CRC remainder result</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM</name>
              <description>Remainder value. The alignment of the remainder depends on CRC_REM_CTL0.REM_REVERSE:
'0': the more significant bits (bit 31 and down) contain the remainder.
'1': the less significant bits (bit 0 and up) contain the remainder.

Note: This field is combinatorially derived from CRC_LFSR_CTL.LFSR32, CRC_CTL.REM_REVERSE and CRC_REM_CTL.REM_XOR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>64</dimIncrement>
          <name>CH_STRUCT[%s]</name>
          <description>DW channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CH_CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000300</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the P field for the user/privileged access control ('hprot[1]').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the NS field for the secure/non-secure access control ('hnonsec').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control ('hprot[2]').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>Protection context.

This field is set with the protection context of the transaction that writes this register;  i.e.  the 'write data' is ignored and instead the context is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel uses the PC field for the protection context.

Note: protection context (PC) is routed on 'hauser' bus of the AHB5 bus.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
'2'
'3': lowest priority.

Channels with the same priority constitute a priority group. Priority decoding determines the highest priority pending channel. This channel is determined as follows. First, the highest priority group with pending channels is identified. Second, within this priority group, round robin arbitration is applied. Round robin arbitration (within a priority group) gives the highest priority to the lower channel indices (within the priority group).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>Specifies if the channel is preemptable.
'0': Not preemptable.
'1': Preemptable. This field allows higher priority pending channels (from a higher priority group; i.e. an active channel can NOT be preempted by a pending channel in the same priority group) to preempt the active channel in between 'single transfers' (a 1D transfer consists out of X_COUNT single transfers; a 2D transfer consists out of X_COUNT*Y_COUNT single transfers). Preemption will NOT affect the pending status of channel. As a result, after completion of a higher priority activated channel, the current channel may be reactivated.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. The channel's trigger is ignored and the channel cannot be made pending and therefore cannot be made active. If a pending channel is disabled, the channel is made non pending. If the activate channel is disabled, the channel is de-activated (bus transactions are completed).
'1': Enabled.

SW sets this field to '1' to enable a specific channel.

HW sets this field to '0' on an error interrupt cause (the specific error is specified by CH_STATUS.INTR_CAUSE).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_STATUS</name>
            <description>Channel status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>INTR_CAUSE</name>
                <description>Specifies the source of the interrupt cause:
'0': NO_INTR
'1': COMPLETION
'2': SRC_BUS_ERROR
'3': DST_BUS_ERROR
'4': SRC_MISAL
'5': DST_MISAL
'6': CURR_PTR_NULL
'7': ACTIVE_CH_DISABLED
'8': DESCR_BUS_ERROR
'9'-'15': Not used.

For error related interrupt causes (INTR_CAUSE is '2', '3', ..., '8'), the channel is disabled (HW sets CH_CTL.ENABLED to '0').</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PENDING</name>
                <description>Specifies pending DW channels; i.e. enabled channels whose trigger got activated. This field includes all channels that are in the pending state (not scheduled) or active state (scheduled and performing data transfer(s)).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_IDX</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor.

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor.

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Y_IDX</name>
                <description>Specifies the Y loop index, with X_COUNT taken from the current descriptor.

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor.

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_CURR_PTR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor.

Note: Typically, when SW updates the current descriptor pointer CH_CURR_PTR, it also sets CH_IDX.X_IDX and CH_IDX.Y_IDX to '0'.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Set to '1', when event (as specified by CH_STATUS.INTR_CAUSE) is detected. Write INTR.CH field with '1', to clear bit. Write INTR_SET.CH field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR.CH field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA0</name>
            <description>SRAM data 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA1</name>
            <description>SRAM data 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Refer SRAM_DATA0</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channel software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DW0">
      <name>DW1</name>
      <baseAddress>0x42190000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>SYSCPUSS registers</description>
      <baseAddress>0x421C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ioss_interrupts_gpio_0</name>
        <description>GPIO Port Interrupt #0</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_1</name>
        <description>GPIO Port Interrupt #1</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_2</name>
        <description>GPIO Port Interrupt #2</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_3</name>
        <description>GPIO Port Interrupt #3</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_4</name>
        <description>GPIO Port Interrupt #4</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_5</name>
        <description>GPIO Port Interrupt #5</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_6</name>
        <description>GPIO Port Interrupt #6</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_7</name>
        <description>GPIO Port Interrupt #7</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_8</name>
        <description>GPIO Port Interrupt #8</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_9</name>
        <description>GPIO Port Interrupt #9</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_sec_gpio_0</name>
        <description>GPIO Port Secure Interrupt #0</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_sec_gpio_1</name>
        <description>GPIO Port Secure Interrupt #1</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_sec_gpio_2</name>
        <description>GPIO Port Secure Interrupt #2</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_sec_gpio_3</name>
        <description>GPIO Port Secure Interrupt #3</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_sec_gpio_4</name>
        <description>GPIO Port Secure Interrupt #4</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_sec_gpio_5</name>
        <description>GPIO Port Secure Interrupt #5</description>
        <value>15</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_sec_gpio_6</name>
        <description>GPIO Port Secure Interrupt #6</description>
        <value>16</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_sec_gpio_7</name>
        <description>GPIO Port Secure Interrupt #7</description>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_sec_gpio_8</name>
        <description>GPIO Port Secure Interrupt #8</description>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_sec_gpio_9</name>
        <description>GPIO Port Secure Interrupt #9</description>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_vdd</name>
        <description>GPIO Supply Detect Interrupt</description>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_gpio</name>
        <description>GPIO All Ports - Interrupts</description>
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_sec_gpio</name>
        <description>GPIO All Ports  - Secure  Interrupts</description>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>scb_0_interrupt</name>
        <description>Serial Communication Block #0 (DeepSleep capable)</description>
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_mcwdt_0</name>
        <description>Multi Counter Watchdog Timer interrupt</description>
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_backup</name>
        <description>Backup domain interrupt</description>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_dpslp_0</name>
        <description>cpuss Inter Process Communication Interrupt #0</description>
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_dpslp_1</name>
        <description>cpuss Inter Process Communication Interrupt #1</description>
        <value>27</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_wdt</name>
        <description>Interrupt from WDT</description>
        <value>28</value>
      </interrupt>
      <interrupt>
        <name>lpcomp_interrupt</name>
        <description>LPCOMP</description>
        <value>29</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt</name>
        <description>Other combined Interrupts for srss (LVD and CLKCAL, CLKCAL only supported in Active mode)</description>
        <value>30</value>
      </interrupt>
      <interrupt>
        <name>scb_1_interrupt</name>
        <description>Serial Communication Block #1</description>
        <value>31</value>
      </interrupt>
      <interrupt>
        <name>scb_2_interrupt</name>
        <description>Serial Communication Block #2</description>
        <value>32</value>
      </interrupt>
      <interrupt>
        <name>scb_3_interrupt</name>
        <description>Serial Communication Block #3</description>
        <value>33</value>
      </interrupt>
      <interrupt>
        <name>scb_4_interrupt</name>
        <description>Serial Communication Block #4</description>
        <value>34</value>
      </interrupt>
      <interrupt>
        <name>scb_5_interrupt</name>
        <description>Serial Communication Block #5</description>
        <value>35</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_fm_cbus</name>
        <description>FLASH Macro interrupt</description>
        <value>36</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_0</name>
        <description>cpuss DataWire #0, Channel #0</description>
        <value>37</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_1</name>
        <description>cpuss DataWire #0, Channel #1</description>
        <value>38</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_2</name>
        <description>cpuss DataWire #0, Channel #2</description>
        <value>39</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_3</name>
        <description>cpuss DataWire #0, Channel #3</description>
        <value>40</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_4</name>
        <description>cpuss DataWire #0, Channel #4</description>
        <value>41</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_5</name>
        <description>cpuss DataWire #0, Channel #5</description>
        <value>42</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_6</name>
        <description>cpuss DataWire #0, Channel #6</description>
        <value>43</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_7</name>
        <description>cpuss DataWire #0, Channel #7</description>
        <value>44</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_8</name>
        <description>cpuss DataWire #0, Channel #8</description>
        <value>45</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_9</name>
        <description>cpuss DataWire #0, Channel #9</description>
        <value>46</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_10</name>
        <description>cpuss DataWire #0, Channel #10</description>
        <value>47</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_11</name>
        <description>cpuss DataWire #0, Channel #11</description>
        <value>48</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_12</name>
        <description>cpuss DataWire #0, Channel #12</description>
        <value>49</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_13</name>
        <description>cpuss DataWire #0, Channel #13</description>
        <value>50</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_14</name>
        <description>cpuss DataWire #0, Channel #14</description>
        <value>51</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_15</name>
        <description>cpuss DataWire #0, Channel #15</description>
        <value>52</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_0</name>
        <description>cpuss DataWire #1, Channel #0</description>
        <value>53</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_1</name>
        <description>cpuss DataWire #1, Channel #1</description>
        <value>54</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_2</name>
        <description>cpuss DataWire #1, Channel #2</description>
        <value>55</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_3</name>
        <description>cpuss DataWire #1, Channel #3</description>
        <value>56</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_4</name>
        <description>cpuss DataWire #1, Channel #4</description>
        <value>57</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_5</name>
        <description>cpuss DataWire #1, Channel #5</description>
        <value>58</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_6</name>
        <description>cpuss DataWire #1, Channel #6</description>
        <value>59</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_7</name>
        <description>cpuss DataWire #1, Channel #7</description>
        <value>60</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_8</name>
        <description>cpuss DataWire #1, Channel #8</description>
        <value>61</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_9</name>
        <description>cpuss DataWire #1, Channel #9</description>
        <value>62</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_10</name>
        <description>cpuss DataWire #1, Channel #10</description>
        <value>63</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_11</name>
        <description>cpuss DataWire #1, Channel #11</description>
        <value>64</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_12</name>
        <description>cpuss DataWire #1, Channel #12</description>
        <value>65</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_13</name>
        <description>cpuss DataWire #1, Channel #13</description>
        <value>66</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_14</name>
        <description>cpuss DataWire #1, Channel #14</description>
        <value>67</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_15</name>
        <description>cpuss DataWire #1, Channel #15</description>
        <value>68</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_ppu_sramc0</name>
        <description>PPU SRAM0</description>
        <value>69</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_cm33_0_fp</name>
        <description>CM33 0 Floating Point Interrupt</description>
        <value>70</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm33_0_cti_0</name>
        <description>CM33-0 CTI interrupt outputs</description>
        <value>71</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm33_0_cti_1</name>
        <description>CM33-1 CTI interrupt outputs</description>
        <value>72</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_fault_0</name>
        <description>cpuss Faults interrupt</description>
        <value>73</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_ppu_cpuss</name>
        <description>cpuss PPU Interrupt</description>
        <value>74</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_msc</name>
        <description>cpuss Master Security Controller Interrupt</description>
        <value>75</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_0</name>
        <description>TCPWM #0, Counter #0</description>
        <value>76</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_1</name>
        <description>TCPWM #0, Counter #1</description>
        <value>77</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_2</name>
        <description>TCPWM #0, Counter #2</description>
        <value>78</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_3</name>
        <description>TCPWM #0, Counter #3</description>
        <value>79</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_256</name>
        <description>TCPWM #0, Counter #256</description>
        <value>80</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_257</name>
        <description>TCPWM #0, Counter #257</description>
        <value>81</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_258</name>
        <description>TCPWM #0, Counter #258</description>
        <value>82</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_259</name>
        <description>TCPWM #0, Counter #259</description>
        <value>83</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_260</name>
        <description>TCPWM #0, Counter #260</description>
        <value>84</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_261</name>
        <description>TCPWM #0, Counter #261</description>
        <value>85</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_262</name>
        <description>TCPWM #0, Counter #262</description>
        <value>86</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_263</name>
        <description>TCPWM #0, Counter #263</description>
        <value>87</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_512</name>
        <description>TCPWM #0, Counter #512</description>
        <value>88</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_513</name>
        <description>TCPWM #0, Counter #513</description>
        <value>89</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_514</name>
        <description>TCPWM #0, Counter #514</description>
        <value>90</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_515</name>
        <description>TCPWM #0, Counter #515</description>
        <value>91</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_516</name>
        <description>TCPWM #0, Counter #516</description>
        <value>92</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_517</name>
        <description>TCPWM #0, Counter #517</description>
        <value>93</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_518</name>
        <description>TCPWM #0, Counter #518</description>
        <value>94</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_519</name>
        <description>TCPWM #0, Counter #519</description>
        <value>95</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_main_ppu</name>
        <description>SRSS Main PPU Interrupt</description>
        <value>96</value>
      </interrupt>
      <interrupt>
        <name>cryptolite_interrupt_error</name>
        <description>Crypto Interrupt</description>
        <value>97</value>
      </interrupt>
      <interrupt>
        <name>cryptolite_interrupt_trng</name>
        <description>TRNG interrupt</description>
        <value>98</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupts0_0</name>
        <description>CAN #0, Interrupt #0, Channel #0</description>
        <value>99</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupts1_0</name>
        <description>CAN #0, Interrupt #1, Channel #0</description>
        <value>100</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupts0_1</name>
        <description>CAN #0, Interrupt #0, Channel #1</description>
        <value>101</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupts1_1</name>
        <description>CAN #0, Interrupt #1, Channel #1</description>
        <value>102</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupt0</name>
        <description>Can #0, Consolidated interrupt #0</description>
        <value>103</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupt1</name>
        <description>Can #0, Consolidated interrupt #1</description>
        <value>104</value>
      </interrupt>
      <interrupt>
        <name>cordic_interrupt_mxcordic</name>
        <description>CORDIC</description>
        <value>105</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_motif_interrupt_64</name>
        <description>TCPWM #0, MOTIF #1 SR0</description>
        <value>106</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_motif_interrupt_65</name>
        <description>TCPWM #0, MOTIF #1 SR1</description>
        <value>107</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_mcpass</name>
        <description>Combined MCPASS interrupt, AC, Error conditions</description>
        <value>108</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_results</name>
        <description>Combined SAR Entry and FIR results interrupt</description>
        <value>109</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_entry_done_0</name>
        <description>Individual SAR Entry result interrupts [0]</description>
        <value>110</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_entry_done_1</name>
        <description>Individual SAR Entry result interrupts [1]</description>
        <value>111</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_entry_done_2</name>
        <description>Individual SAR Entry result interrupts [2]</description>
        <value>112</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_entry_done_3</name>
        <description>Individual SAR Entry result interrupts [3]</description>
        <value>113</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_entry_done_4</name>
        <description>Individual SAR Entry result interrupts [4]</description>
        <value>114</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_entry_done_5</name>
        <description>Individual SAR Entry result interrupts [5]</description>
        <value>115</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_entry_done_6</name>
        <description>Individual SAR Entry result interrupts [6]</description>
        <value>116</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_entry_done_7</name>
        <description>Individual SAR Entry result interrupts [7]</description>
        <value>117</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_fir_done_0</name>
        <description>Individual FIR result interrupts[0]</description>
        <value>118</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_fir_done_1</name>
        <description>Individual FIR result interrupts[1]</description>
        <value>119</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_ranges</name>
        <description>Combined SAR range interrupt</description>
        <value>120</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_range_0</name>
        <description>Individual SAR range interrupts[0]</description>
        <value>121</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_range_1</name>
        <description>Individual SAR range interrupts[1]</description>
        <value>122</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_range_2</name>
        <description>Individual SAR range interrupts[2]</description>
        <value>123</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_range_3</name>
        <description>Individual SAR range interrupts[3]</description>
        <value>124</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_range_4</name>
        <description>Individual SAR range interrupts[4]</description>
        <value>125</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_range_5</name>
        <description>Individual SAR range interrupts[5]</description>
        <value>126</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_range_6</name>
        <description>Individual SAR range interrupts[6]</description>
        <value>127</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_range_7</name>
        <description>Individual SAR range interrupts[7]</description>
        <value>128</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_csg_dacs</name>
        <description>Combined CSG DAC interrupt</description>
        <value>129</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_csg_dac_0</name>
        <description>Individual CSG DAC interrupts ( 5 in PSOC C3 )[0]</description>
        <value>130</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_csg_dac_1</name>
        <description>Individual CSG DAC interrupts ( 5 in PSOC C3 )[1]</description>
        <value>131</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_csg_dac_2</name>
        <description>Individual CSG DAC interrupts ( 5 in PSOC C3 )[2]</description>
        <value>132</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_csg_dac_3</name>
        <description>Individual CSG DAC interrupts ( 5 in PSOC C3 )[3]</description>
        <value>133</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_csg_dac_4</name>
        <description>Individual CSG DAC interrupts ( 5 in PSOC C3 )[4]</description>
        <value>134</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_csg_dac_5</name>
        <description>Individual CSG DAC interrupts ( 5 in PSOC C3 )[5]</description>
        <value>135</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_csg_dac_6</name>
        <description>Individual CSG DAC interrupts ( 5 in PSOC C3 )[6]</description>
        <value>136</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_csg_dac_7</name>
        <description>Individual CSG DAC interrupts ( 5 in PSOC C3 )[7]</description>
        <value>137</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_csg_cmps</name>
        <description>Combined CSG CMP interrupts</description>
        <value>138</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_fifos</name>
        <description>Combined FIFO interrupts</description>
        <value>139</value>
      </interrupt>
      <registers>
        <register>
          <name>IDENTITY</name>
          <description>Identity</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>This field specifies the privileged setting ('0': user mode; '1': privileged mode) of the transfer that reads the register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>This field specifies the security setting ('0': secure mode; '1': non-secure mode) of the transfer that reads the register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>This field specifies the protection context of the transfer that reads the register.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>This field specifies the bus master identifier of the transfer that reads the register.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRODUCT_ID</name>
          <description>Product identifier and version (same as CoreSight RomTables)</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FAMILY_ID</name>
              <description>Family ID. Common ID for a product family.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJOR_REV</name>
              <description>Major Revision, starts with 1, increments with all layer tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MINOR_REV</name>
              <description>Minor Revision, starts with 1, increments with metal layer only tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DP_STATUS</name>
          <description>Debug port status</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SWJ_CONNECTED</name>
              <description>Specifies if the SWJ debug port is connected; i.e. debug host interface is active:
'0': Not connected/not active.
'1': Connected/active.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_DEBUG_EN</name>
              <description>Specifies if SWJ debug is enabled, i.e. CDBGPWRUPACK is '1' and thus debug clocks are on:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_JTAG_SEL</name>
              <description>Specifies if the JTAG interface is selected.
'0': JTAG not selected.
'1': JTAG selected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_SWD_SEL</name>
              <description>Specifies if the SWD interface is selected.
'0': SWD not selected.
'1': SWD selected.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUFF_CTL</name>
          <description>Buffer control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WRITE_BUFF</name>
              <description>Specifies if write transfer can be buffered in the bus infrastructure bridges:
'0': Write transfers are not buffered, independent of the transfer's bufferable attribute.
'1': Write transfers can be buffered, if the transfer's bufferable attribute indicates that the transfer is a bufferable/posted write.

This bit will control only the IPs which use mxambatk AHB2AHB bridge (mxambatk_ahb2ahb) and it will NOT control the buffering that may be happening in bus infrastructure components used from ARM SIE200.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_SET</name>
          <description>Calibration support set and read</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read without side effect, write 1 to set</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_CLR</name>
          <description>Calibration support clear and reset</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read side effect: when read all bits are cleared, write 1 to clear a specific bit
Note: no exception for the debug host, it also causes the read side effect</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INFRA_CTL</name>
          <description>Infrastructure Control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>CLOCK_FORCE</name>
              <description>Force Infrastructure clock gating to be always ON.
0: Disabled
1: Enabled</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTICK_S_CTL</name>
          <description>Secure SysTick timer control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000147</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>TENMS</name>
              <description>Specifies the number of clock source cycles (minus 1) that make up 10 ms. E.g., for a 32,768 Hz reference clock, TENMS is 328 - 1 = 327.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SOURCE</name>
              <description>Specifies an external clock source:
'0': The low frequency clock 'clk_lf' is selected. The precision of this clock depends on whether the low frequency clock source is a SRSS internal RC oscillator (imprecise) or a device external crystal oscillator (precise).
'1': The internal main oscillator (IMO) clock 'clk_imo' is selected. The MXS40 platform uses a fixed frequency IMO clock.
o '2': The external crystal oscillator (ECO) clock 'clk_eco' is selected.
'3': The SRSS 'clk_timer' is selected ('clk_timer' is a divided/gated version of 'clk_hf' or 'clk_imo').

Note: If NOREF is '1', the CLOCK_SOURCE value is NOT used.
Note: It is SW's responsibility to provide the correct NOREF, SKEW and TENMS field values for the selected clock source.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKEW</name>
              <description>Specifies the precision of the clock source and if the TENMS field represents exactly 10 ms (clock source frequency is a multiple of 100 Hz). This affects the suitability of the SysTick timer as a SW real-time clock:
'0': Precise.
'1': Imprecise.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOREF</name>
              <description>Specifies if an external clock source is provided:
'0': An external clock source is provided.
'1': An external clock source is NOT provided and only the CPU internal clock can be used as SysTick timer clock source.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTICK_NS_CTL</name>
          <description>Non Secure SysTick timer control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000147</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>TENMS</name>
              <description>Specifies the number of clock source cycles (minus 1) that make up 10 ms. E.g., for a 32,768 Hz reference clock, TENMS is 328 - 1 = 327.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SOURCE</name>
              <description>Specifies an external clock source:
'0': The low frequency clock 'clk_lf' is selected. The precision of this clock depends on whether the low frequency clock source is a SRSS internal RC oscillator (imprecise) or a device external crystal oscillator (precise).
'1': The internal main oscillator (IMO) clock 'clk_imo' is selected. The MXS40 platform uses a fixed frequency IMO clock.
o '2': The external crystal oscillator (ECO) clock 'clk_eco' is selected.
'3': The SRSS 'clk_timer' is selected ('clk_timer' is a divided/gated version of 'clk_hf' or 'clk_imo').

Note: If NOREF is '1', the CLOCK_SOURCE value is NOT used.
Note: It is SW's responsibility to provide the correct NOREF, SKEW and TENMS field values for the selected clock source.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKEW</name>
              <description>Specifies the precision of the clock source and if the TENMS field represents exactly 10 ms (clock source frequency is a multiple of 100 Hz). This affects the suitability of the SysTick timer as a SW real-time clock:
'0': Precise.
'1': Imprecise.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOREF</name>
              <description>Specifies if an external clock source is provided:
'0': An external clock source is provided.
'1': An external clock source is NOT provided and only the CPU internal clock can be used as SysTick timer clock source.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MSC</name>
          <description>Master security controller Interrupt</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>CODE_MS0_MSC</name>
              <description>This interrupt cause field is activated (HW sets the field to '1') when there is a MSC interrupt violation.

SW writes a '1' to this field to clear the interrupt cause to '0'. The HW captures a new MSC interrupt only after clearing the interrupt cause.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_MS0_MSC</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_MS1_MSC</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXP_MS_MSC</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC0_MSC</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC1_MSC</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK_MSC</name>
          <description>Master security controller Interrupt mask</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>CODE_MS0_MSC</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_MS0_MSC</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_MS1_MSC</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXP_MS_MSC</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC0_MSC</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC1_MSC</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED_MSC</name>
          <description>Master security controller Interrupt masked</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>CODE_MS0_MSC</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYS_MS0_MSC</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYS_MS1_MSC</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXP_MS_MSC</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC0_MSC</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DMAC1_MSC</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AP_CTL</name>
          <description>Access port control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FF77FF7</resetMask>
          <fields>
            <field>
              <name>CM33_0_ENABLE</name>
              <description>Enables the CM33_0 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_ENABLE</name>
              <description>Enables the CM33_1 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_ENABLE</name>
              <description>Enables the system AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_DBG_ENABLE</name>
              <description>Invasive debug enable for CM33_0.
'0': Disables all halt-mode and invasive debug features.
'1': Enables invasive debug features.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_NID_ENABLE</name>
              <description>Non-invasive debug enable for CM33_0.
'0': Disables all trace and non-invasive debug features.
'1': Enables all trace and non-invasive debug features.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_SPID_ENABLE</name>
              <description>Secure invasive debug enable for CM33_0.
'0': disables all halt mode and invasive debug features when the processor is in Secure state.
'1': Enables all halt mode and invasive debug features when the processor is in Secure state.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_SPNID_ENABLE</name>
              <description>Secure non-invasive debug enable for CM33_0.
'0': Disables non-invasive debug features when the processor is in Secure state.
'1': Enables non-invasive debug features when the processor is in Secure state.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_DBG_ENABLE</name>
              <description>Refer CM33_0_DBG_ENABLE.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_NID_ENABLE</name>
              <description>Refer CM33_0_NID_ENABLE.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_SPID_ENABLE</name>
              <description>Refer CM33_0_SPID_ENABLE.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_SPNID_ENABLE</name>
              <description>Refer CM33_0_SPNID_ENABLE.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_SECURE_ENABLE</name>
              <description>Enables the CM33_0 secure AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_SECURE_ENABLE</name>
              <description>Enables the CM33_1 secure AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_SECURE_ENABLE</name>
              <description>Enables the system secure AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_DISABLE</name>
              <description>Disables the CM33_0 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM0_DISABLE is '0' and CM0_ENABLE is '1'.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_DISABLE</name>
              <description>Disables the CM33_1 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM33_DISABLE is '0' and CM33_ENABLE is '1'.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_DISABLE</name>
              <description>Disables the system AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when SYS_DISABLE is '0' and SYS_ENABLE is '1'.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_DBG_DISABLE</name>
              <description>Disable Invasive debug for CM33_0.
'1': Disables all halt-mode and invasive debug features.
'0': Enables invasive debug features.

Typically, this field is set by the Cypress boot code with information from eFUSE. The invasive debug is only enabled when CM33_0_DBG_DISABLE is '0' and CM33_0_DBG_ENABLE is '1'.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_NID_DISABLE</name>
              <description>Disable Non-invasive debug for CM33_0.
'1': Disables all trace and non-invasive debug features.
'0': Enables all trace and non-invasive debug features.

Typically, this field is set by the Cypress boot code with information from eFUSE. The non-invasive debug is only enabled when CM33_0_NID_DISABLE is '0' and CM33_0_NID_ENABLE is '1'.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_SPID_DISABLE</name>
              <description>Secure invasive debug disable for CM33_0.
'1': disables all halt mode and invasive debug features when the processor is in Secure state.
'0': Enables all halt mode and invasive debug features when the processor is in Secure state.

Typically, this field is set by the Cypress boot code with information from eFUSE. The invasive debug in secure state is only enabled when CM33_0_SPID_DISABLE is '0' and CM33_0_SPID_ENABLE is '1'.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_SPNID_DISABLE</name>
              <description>Secure non-invasive debug disable for CM33_0.
'1': Disables non-invasive debug features when the processor is in Secure state.
'0': Enables non-invasive debug features when the processor is in Secure state.

Typically, this field is set by the Cypress boot code with information from eFUSE. The non-invasive debug in secure state is only enabled when CM33_0_SPNID_DISABLE is '0' and CM33_0_SPNID_ENABLE is '1'.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_DBG_DISABLE</name>
              <description>Refer CM33_0_DBG_DISABLE description.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_NID_DISABLE</name>
              <description>Refer CM33_0_NID_DISABLE description.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_SPID_DISABLE</name>
              <description>Refer CM33_0_SPID_DISABLE description.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_SPNID_DISABLE</name>
              <description>Refer CM33_0_SPNID_DISABLE description.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_0_SECURE_DISABLE</name>
              <description>Disables the CM33_0 secure AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM0_DISABLE is '0' and CM0_ENABLE is '1'.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM33_1_SECURE_DISABLE</name>
              <description>Disables the CM33_1 secure AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM33_DISABLE is '0' and CM33_ENABLE is '1'.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_SECURE_DISABLE</name>
              <description>Disables the system secure AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when SYS_DISABLE is '0' and SYS_ENABLE is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection status</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5B719A4F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATE</name>
              <description>Protection state:
            PROTECTION is '0x5B719A4F': UNKNOWN state.
            PROTECTION is '0x5D48F714': VIRGIN state.
            PROTECTION is '0xC39D5455': OPEN state
            PROTECTION is '0x652372F7': NORMAL state.
            PROTECTION is '0x8DF117A1': SECURE state.
            PROTECTION is '0xFBF6D1B6': RMA state
            PROTECTION is '0x2E94B3DD': DEAD state.
            PROTECTION is '0x3A5BC6F1': CORRUPTED state.
            PROTECTION is '0x3F80442F': TESTMODE state.

The following state transitions are allowed (and enforced by HW):
- UNKNOWN =&gt; VIRGIN/RMA/OPEN/NORMAL/SECURE/DEAD/CORRUPTED
- RMA/OPEN/NORMAL/SECURE =&gt; DEAD
- RMA/OPEN/NORMAL/SECURE =&gt; TESTMODE
- RMA/OPEN/NORMAL/SECURE =&gt; CORRUPTED
An attempt to make a NOT allowed state transition will NOT affect this register field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MS_CTL_2_1</name>
      <description>Master control registers</description>
      <baseAddress>0x421C4000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>32</dim>
          <dimIncrement>16</dimIncrement>
          <name>MS[%s]</name>
          <description>Master protection context control</description>
          <headerStructName>MS</headerStructName>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Master 'x' protection context control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF0003</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>Privileged setting ('0': user mode; '1': privileged mode).

Notes:
This field is ONLY used for masters that do NOT provide their own user/privileged access control attribute.
The default/reset field value provides privileged mode access capabilities.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Master security controller configuration.
0: Bus master is secure. Master can send both secure and non-secure transfers. Accesses to secure addresses are not blocked and the security flag, HNONSEC, is set accordingly.
1: Bus master is non-secure. Master can send only non-secure
transfers. Access to secure addresses, that is, outside the
Uncheck regions, are blocked.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK</name>
                <description>Protection context mask for protection contexts '15' down to '0'. Bit PC_MASK[i] indicates if the MS_PC_STRUCT[x].PC[3:0] protection context field can be set to the value 'i':
- PC_MASK[i] is '0': MS_PC_STRUCT[x].PC[3:0] can NOT be set to 'i'; and PC[3:0] is not changed.
- PC_MASK[i] is '1': MS_PC_STRUCT[x].PC[3:0] can be set to 'i'.

Note: When CM33_0 CM33_PC_CTL.VALID[i] is '1' (the associated protection context handler is valid), write transfers to PC_MASK[i] always write '0', regardless of data written. This ensures that when valid protection context handlers are used to enter protection contexts 0, 1, 2 or 3 through HW (HW modifies MS_PC_STRUCT[x].PC[3:0] on entry of the handler), it is NOT possible for SW to enter those protection contexts.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>32</dim>
          <dimIncrement>16</dimIncrement>
          <name>MS_PC[%s]</name>
          <description>Master protection context value</description>
          <headerStructName>MS_PC</headerStructName>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>PC</name>
            <description>Master 'x' protection context value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Active protection context (PC). Modifications to this field are constrained by the associated  MS_CTL_STRUCT[x].CTL.PC_MASK value. PC[3:0] can be set to 'i' only if the corresponding mask bit (PC_MASK[i]) is '1'.

The CM33_0 PC register is special: the PC field is modifiable by BOTH HW and SW (for all other masters, the PC field is modifiable by SW ONLY. For CM33_0 PC field HW modifications, the following holds:
* On entry of a CM33_PC0/1/2/3_HANDLER exception/interrupt handler:
   IF (the new PC is the same as MS_PC_STRUCT[0].PC)
       PC is not affected; PC_SAVED is not affected.
   ELSE IF (CM33_PC_CTL.VALID[MS_PC_STRUCT[0].PC])
       An AHB5 bus error is generated for the exception handler fetch;
       PC is not affected; PC_SAVED is not affected.
   ELSE
       PC = 'new PC'; PC_SAVED = PC (push operation).
* On entry of any other exception/interrupt handler:
   PC = PC_SAVED; PC_SAVED is not affected (pop operation).


Note: this field is NOT used by the DW controllers, DMA controllers as they inherit the protection context from master that configures the corresponding channel.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>N/A</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC_READ_MIR</name>
            <description>Master 'x' protection context value read mirror register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Read-only mirror of PC.PC</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Read-only mirror of PC.PC_SAVED</description>
                <bitRange>[19:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CODE_MS0_MSC_ACG_CTL</name>
          <description>CODE_MS0 master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_MS0_MSC_ACG_CTL</name>
          <description>SYS_MS0  master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_MS1_MSC_ACG_CTL</name>
          <description>SYS_MS1  master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXP_MS_MSC_ACG_CTL</name>
          <description>EXP_MS  master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC0_MSC_ACG_CTL</name>
          <description>DMAC-0  master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC1_MSC_ACG_CTL</name>
          <description>DMAC-1  master security Controller &amp; ACG configuration</description>
          <addressOffset>0x2040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CFG_GATE_RESP</name>
              <description>Response type when the ACG is blocking the incoming transfers:
0: Waited transfer
1: Error response</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_RESP</name>
              <description>Reseponse type when transfers are not allowed by MSC.
0: Read as zero, write ignore.
1: Error response.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS_SL_CTL</name>
      <description>SYSCPUSS Internal slave control registers</description>
      <baseAddress>0x421C8000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SL_CTL</name>
          <description>Slave control (Clock enables)</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFF</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>PROMC_ENABLED</name>
              <description>Slave enable controls. Each bit indicates whether the respective slave is enabled or not.
0: Disabled
1: Enabled
If the slave is disabled, its clock is gated off (constant '0').
Any access (MMIO AHB access or ROM/System SRAM memory access) to slave  when disabled result in AHB error response.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RRAMC_ENABLED</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASHC_ENABLED</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC0_ENABLED</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC1_ENABLED</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC2_ENABLED</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DW0_ENABLED</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DW1_ENABLED</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC0_ENABLED</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC1_ENABLED</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPC_ENABLED</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULT_ENABLED</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SL_CTL2</name>
          <description>Slave control2 (Reset enables)</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>PROMC_RST</name>
              <description>Slave reset controls. Each bit indicates whether the respective slave reset is enabled or not.
0: Disabled
1: Enabled
If the slave is under reset enabled state, its clock is gated off (constant '0') and its resets are in activated state (rst_n = 0)
Any access (MMIO AHB access or ROM/System SRAM memory access) to slave  when disabled result in AHB error response.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RRAMC_RST</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASHC_RST</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC0_RST</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC1_RST</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAMC2_RST</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DW0_RST</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DW1_RST</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC0_RST</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAC1_RST</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPC_RST</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULT_RST</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IPC</name>
      <description>IPC</description>
      <baseAddress>0x421D0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>32</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>IPC structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>ACQUIRE</name>
            <description>IPC acquire</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>N/A</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>N/A</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier  that successfully acquired the lock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUCCESS</name>
                <description>N/A</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RELEASE</name>
            <description>IPC release</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_RELEASE</name>
                <description>Writing this field releases a lock and allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'.

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NOTIFY</name>
            <description>IPC notification</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'.

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>IPC data 0</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>IPC data 1</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK_STATUS</name>
            <description>IPC lock status</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>N/A</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>N/A</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACQUIRED</name>
                <description>N/A</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>32</dimIncrement>
          <name>INTR_STRUCT[%s]</name>
          <description>IPC interrupt structure</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC release event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC notification event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>FAULT</name>
      <description>Fault structures</description>
      <baseAddress>0x421E0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>STRUCT</name>
          <description>Fault structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Fault control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>TR_EN</name>
                <description>Trigger output enable:
'0': Disabled. The trigger output 'tr_fault' is '0'.
'1': Enabled. The trigger output 'tr_fault' reflects STATUS.VALID. The trigger can be used to initiate a Datawire transfer of the FAULT data (FAULT_DATA0 through FAULT_DATA3).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_EN</name>
                <description>IO output signal enable:
'0': Disabled. The IO output signal 'fault_out' is '0'. The IO output enable signal 'fault_out_en' is '0'.
'1': Enabled. The IO output signal 'fault_out' reflects STATUS.VALID. The IO output enable signal 'fault_out_en' is '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_REQ_EN</name>
                <description>Reset request enable:
'0': Disabled.
'1': Enabled. The output reset request signal 'fault_reset_req' reflects STATUS.VALID. This reset causes a warm/soft/core reset. This warm/soft/core reset does not affect the fault logic STATUS, DATA0, ..., DATA3 registers (allowing for post soft reset failure analysis).

The 'fault_reset_req' signals of the individual fault report structures are combined (logically OR'd) into a single SRSS 'fault_reset_req' signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Fault status</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>IDX</name>
                <description>The fault source index for which fault information is captured in DATA0 through DATA3. The fault information is fault source specific and described below.

Note: this register field (and associated fault source data in DATA0 through DATA3) should only be considered valid, when VALID is '1'.

The description of the encoded meaning of this field is comes from the Fault assignment in the Product TRM.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>N/A</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>4</dimIncrement>
            <name>DATA[%s]</name>
            <description>Fault data</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Captured fault source data.

Note: the DATA registers can only be written when STATUS.VALID is '0'.

Note: the fault source index STATUS.IDX specifies the format of the DATA registers.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING0</name>
            <description>Fault pending 0</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the fault source.  The list of fault sources is in the product.xls in the 'Faults' tab.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING1</name>
            <description>Fault pending 1</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: Peripheral group 0 PPU.
Bit 1: Peripheral group 1 PPU.
Bit 2: Peripheral group 2 PPU.
Bit 3: Peripheral group 3 PPU.
Bit 4: Peripheral group 4 PPU.
Bit 5: Peripheral group 5 PPU.
Bit 6: Peripheral group 6 PPU.
Bit 7: Peripheral group 7 PPU.
...
Bit 15: Peripheral group 15 PPU.

Bit 16 - 31: See STATUS register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING2</name>
            <description>Fault pending 2</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0 - 31: See STATUS register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK0</name>
            <description>Fault mask 0</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 31 to 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK1</name>
            <description>Fault mask 1</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 63 to 32.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK2</name>
            <description>Fault mask 2</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 95 to 64.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>This interrupt cause field is activated (HW sets the field to '1') when an enabled (MASK0/MASK1/MASK2) pending fault source is captured:
- STATUS.VALID is set to '1'.
- STATUS.IDX specifies the fault source index.
- DATA0 through DATA3 captures the fault source data.

SW writes a '1' to this field to clear the interrupt cause to '0'. SW clear STATUS.VALID to '0' to enable capture of the next fault. Note that when there is an enabled pending fault source, the pending fault source is captured immediately and INTR.FAULT is immediately activated (set to '1').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSS</name>
      <description>SRSS Core Registers</description>
      <baseAddress>0x42200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_LVD_STATUS</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Status Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD1_OK</name>
              <description>HVLVD1 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_STATUS2</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Status Register #2</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD2_OUT</name>
              <description>HVLVD2 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_DSI_SELECT[%s]</name>
          <description>Clock DSI Select Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>DSI_MUX</name>
              <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or as reference inputs for the FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DSI_OUT0</name>
                  <description>DSI0 - dsi_out[0]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT1</name>
                  <description>DSI1 - dsi_out[1]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT2</name>
                  <description>DSI2 - dsi_out[2]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT3</name>
                  <description>DSI3 - dsi_out[3]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT4</name>
                  <description>DSI4 - dsi_out[4]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT5</name>
                  <description>DSI5 - dsi_out[5]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT6</name>
                  <description>DSI6 - dsi_out[6]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT7</name>
                  <description>DSI7 - dsi_out[7]</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT8</name>
                  <description>DSI8 - dsi_out[8]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT9</name>
                  <description>DSI9 - dsi_out[9]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT10</name>
                  <description>DSI10 - dsi_out[10]</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT11</name>
                  <description>DSI11 - dsi_out[11]</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT12</name>
                  <description>DSI12 - dsi_out[12]</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT13</name>
                  <description>DSI13 - dsi_out[13]</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT14</name>
                  <description>DSI14 - dsi_out[14]</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT15</name>
                  <description>DSI15 - dsi_out[15]</description>
                  <value>15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator #0</description>
                  <value>16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator</description>
                  <value>17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock</description>
                  <value>18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision Internal Low-speed Oscillator</description>
                  <value>19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>ILO1 - Internal Low-speed Oscillator #1, if present.</description>
                  <value>20</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_FAST</name>
          <description>Fast Clock Output Select Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF0FFF</resetMask>
          <fields>
            <field>
              <name>FAST_SEL0</name>
              <description>Select signal for fast clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL0 and HFCLK_SEL0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL0</name>
                  <description>Selects the clock path chosen by PATH_SEL0 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL0</name>
                  <description>Selects the output of the HFCLK_SEL0 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL0</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL0</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IHO</name>
                  <description>Internal High-speed Oscillator (IHO).</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR</name>
                  <description>clk_pwr: used for PPU and related components</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL0</name>
              <description>Selects a clock path to use in fast clock output #0 logic.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL0</name>
              <description>Selects a HFCLK tree for use in fast clock output #0</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_SEL1</name>
              <description>Select signal for fast clock output #1</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL1 and HFCLK_SEL1.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL1</name>
                  <description>Selects the clock path chosen by PATH_SEL1 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL1</name>
                  <description>Selects the output of the HFCLK_SEL1 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL1</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL1</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IHO</name>
                  <description>Internal High-speed Oscillator (IHO).</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR</name>
                  <description>clk_pwr: used for PPU and related components</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL1</name>
              <description>Selects a clock path to use in fast clock output #1 logic.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL1</name>
              <description>Selects a HFCLK tree for use in fast clock output #1 logic</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_SLOW</name>
          <description>Slow Clock Output Select Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SLOW_SEL0</name>
              <description>Select signal for slow clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>Internal Low Speed Oscillator (ILO1), if present on the product.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO Prescaler (ECO_PRESCALER)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>LPECO Prescaler (LPECO_PRESCALER)</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MFO</name>
                  <description>Medium Frequency Oscillator (MFO)</description>
                  <value>13</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLOW_SEL1</name>
              <description>Select signal for slow clock output #1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>Internal Low Speed Oscillator (ILO1), if present on the product.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO Prescaler (ECO_PRESCALER)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>LPECO Prescaler (LPECO_PRESCALER)</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MFO</name>
                  <description>Medium Frequency Oscillator (MFO)</description>
                  <value>13</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT1</name>
          <description>Clock Calibration Counter 1</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xE0FFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER1</name>
              <description>Down-counter clocked on fast clock output #0 (see CLK_OUTPUT_FAST). This register always reads as zero.  Counting starts internally when this register is written with a nonzero value.  CAL_COUNTER_DONE goes immediately low to indicate that the counter has started and will be asserted when the counters are done.  Do not write this field unless CAL_COUNTER_DONE==1.  Both clocks must be running or the measurement will not complete, and this case can be recovered using CAL_RESET.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_RESET</name>
              <description>Reset clock calibration logic for window mode.  This can be used to recover from unexpected conditions, such as no clock present on counter #1.
Set this bit only when CLK_CAL_TEST.CAL_WINDOW_SEL=1 (window mode).  It takes 3 clock cycles for reset to propagate.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_CLK1_PRESENT</name>
              <description>Status bit indicating that a posedge was detected by counter #1.  If this bit never asserts, there is no clock on counter #1 and CAL_COUNTER_DONE will stay low indefinitely.  This can be recovered with CAL_RESET.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CAL_COUNTER_DONE</name>
              <description>Status bit indicating that the internal counter #1 is finished counting and CLK_CAL_CNT2.COUNTER stopped counting up</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT2</name>
          <description>Clock Calibration Counter 2</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER2</name>
              <description>Up-counter clocked on fast clock output  #1 (see CLK_OUTPUT_FAST). When CLK_CAL_CNT1.CAL_COUNTER_DONE==1, the counter is stopped and can be read by SW.  Do not read this value unless CAL_COUNTER_DONE==1.  The expected final value is related to the ratio of clock frequencies used for the two counters and the value loaded into counter 1: CLK_CAL_CNT2.COUNTER=(F_cnt2/F_cnt1)*(CLK_CAL_CNT1.COUNTER)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000021</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>WDT Interrupt Request.  This bit is set each time WDT_COUNTR==WDT_MATCH.  W1C also feeds the watch dog.  Missing 2 interrupts in a row will generate a reset.  Due to internal synchronization, it takes 2 SYSCLK cycles to update after a W1C.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Clock calibration counter is done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AINTR</name>
              <description>See additional interrupts in SRSS_AINTR.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x21</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Set interrupt for low voltage detector WDT_MATCH</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Set interrupt for clock calibration counter done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x21</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Mask for watchdog timer.  Clearing this bit will not forward the interrupt to the CPU.  It will not, however, disable the WDT reset generation on 2 missed interrupts.  When WDT resets the chip, it also internally pends an interrupt that survives the reset.  To prevent unintended ISR execution, clear SRSS_INTR.WDT_MATCH before setting this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Mask for clock calibration done</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASKED</name>
          <description>SRSS Interrupt Masked Register</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000021</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AINTR</name>
              <description>See additional MASKED bits in SRSS_AINTR_MASKED.ADDITIONAL</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_AINTR</name>
          <description>SRSS Additional Interrupt Register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Interrupt for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_AINTR_SET</name>
          <description>SRSS Additional Interrupt Set Register</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Set interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Set interrupt for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_AINTR_MASK</name>
          <description>SRSS Additional Interrupt Mask Register</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Mask for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Mask for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_AINTR_MASKED</name>
          <description>SRSS Additional Interrupt Masked Register</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOT_DLM_CTL</name>
          <description>Debug Control Register</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE000000F</resetMask>
          <fields>
            <field>
              <name>REQUEST</name>
              <description>A request to ROM_BOOT FW to execute particular code.
This field survives some resets, including a system reset:
* 0 - No request (default).
* 1 - ROM_BOOT to wait for DLM app (PC=0).
* 2 - ROM_BOOT to wait for an OEM debug token.
* 3 - ROM_BOOT to wait for a PROT_FW debug token.
* 4, 5 - ignored by ROM_BOOT.
* 6 - ROM_BOOT to launch DLM app which has been downloaded by DFU.
* 7 - ROM_BOOT to respond to DFU with DLM app status.
Other: ignored by ROM_BOOT.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INPUT_AVAIL</name>
              <description>Notify RAM application that input parameters are valid for processing:
       0 - the input parameters are not available.
       1 - the input parameters are available (ready) for processing.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Request the device reset after RAM application complete input parameters processing. This bit is analyzed with APP_INPUT_AVAIL so to take effect write both.
       0 - No action, the device waits for input parameters.
       1 - Reset the device after input parameters processing complete.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WFA</name>
              <description>Wait for Action.  Set by BootROM when it waits for application or debug certificate to be loaded into the RAM. The bit must be cleared to continue BootROM operation. It is used by the Sys-AP.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOT_DLM_CTL2</name>
          <description>Debug Control Register 2</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APP_CTL</name>
              <description>Address of application descriptor or debug certificate depends on DEBUG_TST_CTL.REQUEST. The application descriptor provides info about RAM application and its parameters layout in the staging area to BootROM and RAM application itself</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOT_DLM_STATUS</name>
          <description>Debug Status Register</description>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_STATUS</name>
              <description>RAM application execution status. This status can be read by the debugger using Sys-AP or user application when RAM application completes with system reset. This field survives some resets, including a system reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_SOFT_CTL</name>
          <description>Soft Reset Trigger Register</description>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TRIGGER_SOFT</name>
              <description>Triggers a soft reset.  The reset clears this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOT_STATUS</name>
          <description>Boot Execution Status Register</description>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_STATUS</name>
              <description>Boot execution status. This status register can be used for communication between ROM_BOOT and User Application. This status can be read by the debugger using Sys-AP or User Application. This field survives some resets, including a system reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOT_ENTRY</name>
          <description>Warm Boot Entry Address</description>
          <addressOffset>0x430</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WARM_BOOT_ENTRY</name>
              <description>Warm boot entry point. This status register can be used for communication between 2 software application before/after DS-RAM or soft reset. This field survives low voltage resets, including a system reset.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>PWR_HIB_DATA[%s]</name>
          <description>HIBERNATE Data Register</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_DATA</name>
              <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIB_WAKE_CTL</name>
          <description>Hibernate Wakeup Mask Register</description>
          <addressOffset>0x8A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0FFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_WAKE_SRC</name>
              <description>When set, HIBERNATE will wakeup for the assigned source.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_CSV_BAK</name>
              <description>When set, HIBERNATE will wakeup for CSV_BAK detection.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_RTC</name>
              <description>When set, HIBERNATE will wakeup for a pending RTC interrupt.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_WDT</name>
              <description>When set, HIBERNATE will wakeup for a pending WDT interrupt.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIB_WAKE_CTL2</name>
          <description>Hibernate Wakeup Polarity Register</description>
          <addressOffset>0x8A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_WAKE_SRC</name>
              <description>Each bit selects the polarity for the corresponding HIBERNATE wakeup source.  0: Wakes when unmasked input is 0.
1: Wakes when unmasked input is 1.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIB_WAKE_CAUSE</name>
          <description>Hibernate Wakeup Cause Register</description>
          <addressOffset>0x8AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0FFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_WAKE_SRC</name>
              <description>Each bit indicates a HIBERNATE wakeup cause.  For each bit, writing a 1 clears the cause flag.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_CSV_BAK</name>
              <description>Indicates CSV_BAK wakeup cause.  The related fault must be handled before this bit can be cleared.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_RTC</name>
              <description>Indicates RTC wakeup cause.  The RTC interrupt must be cleared before this bit can be cleared.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_WAKE_WDT</name>
              <description>Indicates WDT wakeup cause.  The WDT interrupt must be cleared before this bit can be cleared.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CTL</name>
          <description>Power Mode Control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>System is resetting.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>At least one CPU is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>No CPUs are running.  Peripherals may be running.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEPSLEEP</name>
                  <description>Main high-frequency clock is off; low speed clocks are available.  Communication interface clocks may be present.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active.  Power modes behave differently to keep the debug session active, and current consumption may be higher than datasheet specification.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether certain low power functions are ready.  The low current circuits take longer to startup after XRES, HIBERNATE wakeup, or supply supervision reset wakeup than the normal mode circuits.  HIBERNATE mode may be entered regardless of this bit.
0: If a low power circuit operation is requested, it will stay in its normal operating mode until it is ready.  If DEEPSLEEP is requested by all processors WFI/WFE, the device will instead enter SLEEP.  When low power circuits are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DEEPSLEEP and low power circuits operate as requested in other registers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CTL2</name>
          <description>Power Mode Control 2</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xDF331117</resetMask>
          <fields>
            <field>
              <name>LINREG_DIS</name>
              <description>Explicitly disable the linear Core Regulator.  Write zero for Traveo II devices.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Linear Core Regulator is not explicitly disabled.  Hardware disables it automatically for internal sequences, including for DEEPSLEEP, HIBERNATE, and XRES low power modes.
1: Linear Core Regulator is explicitly disabled.  Only use this for special cases when another source supplies vccd during ACTIVE and SLEEP modes.  This setting is only legal when another source supplies vccd, but there is no special hardware protection for this case.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINREG_OK</name>
              <description>Status of the linear Core Regulator.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LINREG_LPMODE</name>
              <description>Control the power mode of the Linear Regulator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Linear Regulator operates in normal mode.
1: Linear Regulator operates in low power mode.  Load current capability is reduced, and firmware must ensure the current is kept within the limit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REG_DIS</name>
              <description>Explicity disable the DeepSleep regulator, including circuits shared with the Active Regulator.  This register must not be set except as part of an Infineon-provided sequence or API.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: DeepSleep Regulator is not explicitly disabled.  This is the normal setting, and hardware automatically controls the DeepSleep regulator for most sequences, including for HIBERNATE and XRES low power modes.  This setting must be used if the Active Linear Regulator is used, because some circuitry is shared.
1: DeepSleep Regulator is explicitly disabled.  Only use this for special cases as part of an Infineon-provided handoff to another supply source.  For example, this setting may be used when another source supplies vccdpslp during DEEPSLEEP mode and the Active Linear Regulator is not usedfor ACTIVE/SLEEP modes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_REG_DIS</name>
              <description>Explicitly disable the Retention regulator.  This field should normally be zero, except for special sequences provided by Infineon to use a different regulator.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Retention Regulator is not explicitly disabled.  Hardware disables it automatically for internal sequences, including for HIBERNATE and XRES low power modes.  Hardware keeps the Retention Regulator enabled during ACTIVE/SLEEP modes, so it is ready to enter DEEPSLEEP at any time.
1: Retention Regulator is explicitly disabled.  Only use this for special cases when another source supplies vccret during DEEPSLEEP mode.  This setting is only legal when another source supplies vccret, but there is no special hardware protection for this case.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NWELL_REG_DIS</name>
              <description>Explicitly disable the Nwell regulator.  This register should normally be zero, except for special sequences provided by Infineon to use a different regulator.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Nwell Regulator is on.  Hardware disables it automatically for internal sequences, including for HIBERNATE and XRES low power modes.  Hardware keeps the Nwell Regulator enabled during ACTIVE/SLEEP modes, so it is ready to enter DEEPSLEEP at any time.
1: Nwell Regulator is explicitly disabled.  Only use this for special cases when another source supplies vnwell during DEEPSLEEP mode.  This setting is only legal when another source supplies vnwell, but there is no special hardware protection for this case.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFV_DIS</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFV_OK</name>
              <description>Indicates that the normal mode of the voltage reference is ready.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFVBUF_DIS</name>
              <description>Disable the voltage reference buffer.  Firmware should only disable the buffer when there is no connected circuit that is using it.  SRSS circuits that require it are the PLL and ECO.  A particular product may have circuits outside the SRSS that use the buffer.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFVBUF_OK</name>
              <description>Indicates that the voltage reference buffer is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting REFVBUF_DIS=1.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFI_DIS</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFI_OK</name>
              <description>Indicates that the current reference is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting REFI_DIS=1.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFI_LPMODE</name>
              <description>Control the power mode of the reference current generator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Current reference generator operates in normal mode.
1: Current reference generator operates in low power mode.  Response time is reduced to save current.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORBOD_LPMODE</name>
              <description>Control the power mode of the POR/BOD circuits.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: POR/BOD circuits operate in normal mode.
1: POR/BOD circuits operate in low power mode.  Response time is reduced to save current.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BGREF_LPMODE</name>
              <description>Control the circuit-level power mode of the Bandgap Reference circuits for higher operating modes than DEEPSLEEP.   This selects a second set of bandgap voltage and current generation circuits that are optimized for low current consumption.  The low current circuits are automatically used in DEEPSLEEP mode regardless of this bit.  The value in this register is ignored and higher-current mode is used until LPM_READY==1.   After this bit is set, the Active Reference circuit can be disabled to reduce current (ACT_REF_DIS=0).    Firmware is responsible to enable the Active Reference and ensure ACT_REF_OK==1 before changing back to higher current mode.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: Bandgap Reference uses the normal settings.
1: Bandgap Reference uses the low power DeepSleep circuits.  Power supply rejection is reduced to save current.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE_DPSLP</name>
              <description>Controls whether mode and state of GPIOs and SIOs in the system are frozen.  This is intended to be used as part of the DEEPSLEEP-RAM and DEEPSLEEP-OFF entry and exit sequences.  It is set by HW while entering DEEPSLEEP-RAM and DEEPSLEEP-OFF modes.   Writing a 1 clears freeze and GPIOs and SIOs resume normal operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LS_BYPASS</name>
              <description>Bypass level shifter inside the PLL.  Unused, if no PLL is present in the product. Note that this only applies to PLL200M.
0: Do not bypass the level shifter.  This setting is ok for all operational modes and vccd target voltage.
1: Bypass the level shifter.  This may reduce jitter on the PLL output clock, but can only be used when vccd is targeted to 1.1V nominal.  Otherwise, it can result in clock degradation and static current.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIBERNATE</name>
          <description>HIBERNATE Mode Register</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xEFFEFFFF</resetMask>
          <fields>
            <field>
              <name>TOKEN</name>
              <description>Contains a 8-bit token that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware to differentiate WAKEUP from a general RESET event.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for FREEZE or HIBERNATE fields to operate.  Any other value in this register will cause FREEZE/HIBERNATE to have no effect, except as noted in the FREEZE description.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>Controls whether mode and state of GPIOs and SIOs in the system are frozen.  This is intended to be used as part of the HIBERNATE entry and exit sequences.  When entering HIBERNATE mode, the first write instructs DEEPSLEEP peripherals that they cannot ignore the upcoming freeze command.  This occurs even in the illegal condition where UNLOCK is not set.  If UNLOCK and HIBERNATE are properly set, the IOs actually freeze on the second write.  Supply supervision is disabled during HIBERNATE mode.  HIBERNATE peripherals ignore resets (excluding XRES) while FREEZE==1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBALARM</name>
              <description>N/A</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBWDT</name>
              <description>N/A</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY_HIBPIN</name>
              <description>N/A</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBPIN</name>
              <description>N/A</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SENSE_MODE</name>
              <description>Power mode when wakeups are sensitive.  The default of this field is 0 for software compatibility with other products.  It is recommended to set this field to 1 for new/updated software.
0: Wakeups are sensitive only during HIBERNATE mode.  A wakeup pulse that comes just before HIBERNATE entry may be missed.  Backward compatible.
1: Wakeups are sensitive in HIBERNATE and higher modes.  Before entering HIBERNATE, software must clear all unmasked, pending wakeups in PWR_HIB_WAKE_CAUSE register.  An unmasked, pending wakeup causes HIBERNATE wakeup, even if it was pending from before HIBERNATE entry.  This prevents missed wakeups.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE_DISABLE</name>
              <description>Hibernate disable bit.
0: Normal operation, HIBERNATE works as described
1: Further writes to this register are ignored
Note: This bit is a write-once bit until the next reset.  Avoid changing any other bits in this register while disabling HIBERNATE mode.  Also, it is recommended to clear the UNLOCK code, if it was previously written..</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE</name>
              <description>Firmware sets this bit to enter HIBERNATE mode.  The system will enter HIBERNATE mode immediately after writing to this bit and will wakeup only in response to XRES or WAKEUP.  Both UNLOCK and FREEZE must have been set correctly in a previous write operations.  Otherwise, it will not enter HIBERNATE.  External supplies must have been stable for 250us before entering HIBERNATE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL</name>
          <description>Buck Control Register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT1_SEL</name>
              <description>Voltage output selection for vccbuck1 output.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 0.85V
1: 0.875V
2: 0.90V
3: 1.0V (SISO-MC), 0.95V (SISO-LC, SIMO-LC)
4: 1.05V
5: 1.10V
6: 1.15V
7: 1.20V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_EN</name>
              <description>Master enable for buck converter.    This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT1_EN</name>
              <description>Enable for vccbuck1 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.    This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.  The TRM specifies the required sequence when transitioning vccd from the LDO to SIMO Buck output #1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL2</name>
          <description>Buck Control Register 2</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT2_SEL</name>
              <description>Voltage output selection for vccbuck2 output.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 1.15V
1: 1.20V
2: 1.25V
3: 1.30V
4: 1.35V
5: 1.40V
6: 1.45V
7: 1.50V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_HW_SEL</name>
              <description>Hardware control for vccbuck2 output.  When this bit is set, the value in BUCK_OUT2_EN is ignored and a hardware signal is used instead.  If the product has supporting hardware, it can directly control the enable signal for vccbuck2.  The same charging time in BUCK_OUT2_EN applies.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_EN</name>
              <description>Enable for vccbuck2 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_CTL</name>
          <description>Supply Supervision Control Register</description>
          <addressOffset>0x1018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8080808</resetValue>
          <resetMask>0x9D909D9</resetMask>
          <fields>
            <field>
              <name>BODVDDD_VSEL</name>
              <description>Selects the voltage threshold for BOD on vddd.  The BOD does not reliably monitor the supply during the transition.
0: vddd&lt;2.7V
1: vddd&lt;3.0V</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDD_ENABLE</name>
              <description>Enable for BOD on vddd.  This cannot be disabled during normal operation.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDA_VSEL</name>
              <description>Selects the voltage threshold for BOD on vdda.  Ensure BODVDDA_ENABLE==0 before changing this setting to prevent false triggers.
0: vdda&lt;2.7V
1: vdda&lt;3.0V</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDA_ACTION</name>
              <description>Action taken when the BOD on vdda triggers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>No action</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset the chip</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BODVDDA_ENABLE</name>
              <description>Enable for BOD on vdda.  BODVDDA_ACTION will be triggered when the BOD is disabled.  If no action is desired when disabling, firmware must first write BODVDDA_ACTION=NOTHING in a separate write cycle.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVCCD_ENABLE</name>
              <description>Enable for BOD on vccd.  This cannot be disabled during normal operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDD_VSEL</name>
              <description>Selects the voltage threshold for OVD on vddd.  The OVD does not reliably monitor the supply during the transition.
0: vddd&gt;5.5V
1: vddd&gt;5.0V</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDD_ENABLE</name>
              <description>Enable for OVD on vddd.  This cannot be disabled during normal operation.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDA_VSEL</name>
              <description>Selects the voltage threshold for OVD on vdda.  Ensure OVDVDDA_ENABLE==0 before changing this setting to prevent false triggers
0: vddd&gt;5.5V
1: vddd&gt;5.0V</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDA_ACTION</name>
              <description>Action taken when the OVD on vdda triggers.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>No action</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset the chip</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVDVDDA_ENABLE</name>
              <description>Enable for OVD on vdda.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVCCD_ENABLE</name>
              <description>Enable for OVD on vccd.  This cannot be disabled during normal operation.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_STATUS</name>
          <description>Supply Supervision Status Register</description>
          <addressOffset>0x101C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x30505</resetValue>
          <resetMask>0x30707</resetMask>
          <fields>
            <field>
              <name>BODVDDD_OK</name>
              <description>BOD indicates vddd is ok.  This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVDDA_OK</name>
              <description>BOD indicates vdda is ok.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVCCD_OK</name>
              <description>BOD indicates vccd is ok.  This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVDDD_OK</name>
              <description>OVD indicates vddd is ok.  This will always read 1, because a detected over-voltage condition will reset the chip.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVDDA_OK</name>
              <description>OVD indicates vdda is ok.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVCCD_OK</name>
              <description>OVD indicates vccd is ok.    This will always read 1, because a detected over-over-voltage condition will reset the chip.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OCD_ACT_LINREG_OK</name>
              <description>OCD indicates the current drawn from the linear Active Regulator is ok.  This will always read 1, because a detected over-current condition will reset the chip.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OCD_DPSLP_REG_OK</name>
              <description>OCD indicates the current drawn from the linear DeepSleep Regulator is ok.    This will always read 1, because a detected over-current condition will reset the chip.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Configuration Register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7DFFF</resetMask>
          <fields>
            <field>
              <name>HVLVD1_TRIPSEL</name>
              <description>Threshold selection for HVLVD1.  Disable the detector (HVLVD1_EN=0) before changing the threshold.
0: rise=1.225V (nom), fall=1.2V (nom)
1: rise=1.425V (nom), fall=1.4V (nom)
2: rise=1.625V (nom), fall=1.6V (nom)
3: rise=1.825V (nom), fall=1.8V (nom)
4: rise=2.025V (nom), fall=2V (nom)
5: rise=2.125V (nom), fall=2.1V (nom)
6: rise=2.225V (nom), fall=2.2V (nom)
7: rise=2.325V (nom), fall=2.3V (nom)
8: rise=2.425V (nom), fall=2.4V (nom)
9: rise=2.525V (nom), fall=2.5V (nom)
10: rise=2.625V (nom), fall=2.6V (nom)
11: rise=2.725V (nom), fall=2.7V (nom)
12: rise=2.825V (nom), fall=2.8V (nom)
13: rise=2.925V (nom), fall=2.9V (nom)
14: rise=3.025V (nom), fall=3.0V (nom)
15: rise=3.125V (nom), fall=3.1V (nom)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_SRCSEL</name>
              <description>Source selection for HVLVD1</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VDDD</name>
                  <description>Select VDDD</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSA</name>
                  <description>Select AMUXBUSA (VDDD branch)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDIO</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSB</name>
                  <description>Select AMUXBUSB (VDDD branch)</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_EN</name>
              <description>Enable HVLVD1 voltage monitor.  HVLVD1 does not function during DEEPSLEEP, but it automatically returns to its configured setting after DEEPSLEEP wakeup.  Do not change other HVLVD1 settings when enabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_TRIPSEL_HT</name>
              <description>N/A</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_DPSLP_EN_HT</name>
              <description>Keep HVLVD1 voltage monitor enabled during DEEPSLEEP mode.  This field is only used when HVLVD1_EN_HT==1.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_EN_HT</name>
              <description>Enable HVLVD1 voltage monitor.  This detector monitors vddd only.  Do not change other HVLVD1 settings when enabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an action when the threshold is crossed.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_ACTION</name>
              <description>Action taken when the threshold is crossed in the programmed directions(s)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INTERRUPT</name>
                  <description>Generate an interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL2</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Configuration Register #2</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7DF00</resetMask>
          <fields>
            <field>
              <name>HVLVD2_TRIPSEL_HT</name>
              <description>N/A</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_DPSLP_EN_HT</name>
              <description>Keep HVLVD2 voltage monitor enabled during DEEPSLEEP mode.  This field is only used when HVLVD1_EN_HT==1.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_EN_HT</name>
              <description>Enable HVLVD2 voltage monitor.  This detector monitors vddd only.  Do not change other HVLVD2 settings when enabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an action when the threshold is crossed.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD2_ACTION</name>
              <description>Action taken when the threshold is crossed in the programmed directions(s)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INTERRUPT</name>
                  <description>Generate an interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_REGHC_CTL</name>
          <description>REGHC Control Register</description>
          <addressOffset>0x1028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000104</resetValue>
          <resetMask>0xFFFF7DFD</resetMask>
          <fields>
            <field>
              <name>REGHC_MODE</name>
              <description>REGHC control mode:
0: external transistor connected,
1: external PMIC connected</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_DRV_VOUT</name>
              <description>Setting for DRV_VOUT pin for PMIC mode.  See REGHC_VADJ for calculation of vadj.
2'b00: DRV_VOUT=vccd*0.9/vadj;
2'b01: DRV_VOUT=vccd*0.8/vadj;
2'b10: DRV_VOUT=vccd*0.6/vadj;
2'b11: DRV_VOUT=vccd</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_VADJ</name>
              <description>Regulator output trim according to the formula vadj=(1.020V + REGHC_VADJ*0.005V).  The default is 1.1V.  For transistor mode, REGHC will dynamically adjust DRV_VOUT so the supply targets the vadj voltage.  For PMIC mode, see REGHC_PMIC_DRV_VOUT.</description>
              <bitRange>[8:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_USE_LINREG</name>
              <description>For REGHC external PMIC mode, controls whether hardware sequencer keeps the internal Active Linear Regulator enabled to improve supply supervision of vccd.  When using this feature, if the PMIC fails to keep vccd above the internal regulator target, then the internal regulator will attempt to recover vccd.  If the regulator current is too high, the regulator triggers an over-current detector (OCD) reset.
0: Internal Active Linear Regulator disabled after PMIC enabled.  OCD is disabled.;
1: Internal Active Linear Regulator kept enabled.  See datasheet for minimum PMIC vccd input to prevent OCD.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_USE_RADJ</name>
              <description>Controls whether hardware sequencer enables reset voltage adjustment circuit when enabling a PMIC.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_RADJ</name>
              <description>Reset voltage adjustment for PMIC as a factor (Vfbk/Vref) where Vfbk is the feedback voltage and Vref is the PMIC internal reference.  The reset voltage adjustment circuit is enabled by the hardware sequencer if REGHC_PMIC_USE_RADJ=1.  PMIC have Vref of 0.8V or 0.9V, and the resulting reset voltage (Vreset) are precalculated in the table below:
3'b000: Vfbk/Vref=1.0000, Vreset=.800V@(Vref=0.8V), .900V@(Vref=0.9V);
3'b001: Vfbk/Vref=1.0556, Vreset=.844V@(Vref=0.8V), .950V@(Vref=0.9V);
3'b010: Vfbk/Vref=1.1111, Vreset=.889V@(Vref=0.8V), 1.000V@(Vref=0.9V);
3'b011: Vfbk/Vref=1.1250, Vreset=.900V@(Vref=0.8V), 1.013V@(Vref=0.9V);
3'b100: Vfbk/Vref=1.1667, Vreset=.933V@(Vref=0.8V), 1.050V@(Vref=0.9V);
3'b101: Vfbk/Vref=1.1875, Vreset=.950V@(Vref=0.8V), 1.069V@(Vref=0.9V);
3'b110: Vfbk/Vref=1.2500, Vreset=1.000V@(Vref=0.8V), 1.125V@(Vref=0.9V);
3'b111: Vfbk/Vref=1.3125, Vreset=1.050V@(Vref=0.8V), 1.181V@(Vref=0.9V);</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_CTL_OUTEN</name>
              <description>Output enable for PMIC enable pin.  Set this bit high to enable the driver on this pin.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_CTL_POLARITY</name>
              <description>Polarity used to enable the PMIC.  The sequencer uses REGHC_PMIC_CTL_POLARITY to enable the PMIC, and it uses the complement to disable the PMIC.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_INEN</name>
              <description>Input buffer enable for PMIC status input.  Set this bit high to enable the input receiver.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_POLARITY</name>
              <description>The polarity used to trigger a reset action based on the PMIC status input.  The reset system triggers a reset when the unmasked PMIC status matches this value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_WAIT</name>
              <description>Wait count in 4us steps after PMIC status ok.  This is used by the hardware sequencer to allow additional settling time before disabling the internal regulator.  The LSB is 32 IMO periods which results in a nominal LSB step of 4us.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_TRANS_USE_OCD</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_CONFIGURED</name>
              <description>Indicates the REGHC has been configured.  This is used to know if REGHC should be enabled in response to a debug power up request.  Do not change REGHC settings after this bit is set high.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_REGHC_STATUS</name>
          <description>REGHC Status Register</description>
          <addressOffset>0x102C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80001307</resetMask>
          <fields>
            <field>
              <name>REGHC_ENABLED</name>
              <description>Indicates the state of the REGHC enable/disable sequencer.  This bit is only valid when REGHC_SEQ_BUSY==0.
0: REGHC sequencer indicates REGHC is disabled.
1: REGHC sequencer indicates REGHC is enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_OCD_OK</name>
              <description>Indicates the over-current detector is operating and the current drawn from REGHC is within limits.  OCD is only a choice for transistor mode, and it is disabled for PMIC mode.
0: Current measurement exceeds limit or detector is OFF,
1: Current measurement within limit</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_CKT_OK</name>
              <description>Indicates the REGHC circuit is enabled and operating.  It does not indicate that the voltage and current are within required limits for robust operation.
0: REGHC circuit is not ready.  This can occur if the REGHC circuit is disabled or if it was recently enabled.
1: REGHC circuit is enabled and operating.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_UV_OUT</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_OV_OUT</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_PMIC_STATUS_OK</name>
              <description>Indicates the PMIC status is ok.  This includes polarity adjustment according to REGHC_PMIC_STATUS_POLARITY.
0: PMIC status is not ok or PMIC input buffer is disabled (REGHC_PMIC_STATUS_INEN==0);
1: PMIC status input buffer is enabled and indicates ok</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REGHC_SEQ_BUSY</name>
              <description>Indicates the REGHC enable/disable sequencer is busy transitioning to/from REGHC.
0: Sequencer is not busy;
1: Sequencer is busy either enabling or disabling REGHC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_REGHC_CTL2</name>
          <description>REGHC Control Register 2</description>
          <addressOffset>0x1030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>REGHC_PMIC_STATUS_TIMEOUT</name>
              <description>Timeout while waiting for REGHC_PMIC_STATUS_OK==1 when switching to PMIC.
0: disables timeout.
&gt;0: enables timeout of REGHC_PMIC_STATUS_TIMEOUT*128us (nominal, clocked by IMO).  Timeout expiration triggers reset.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REGHC_EN</name>
              <description>Enable REGHC.  This bit will not set if REGHC_CONFIGURED==0.  Use PWR_REGHC_STATUS.ENABLED to know the actual status of REGHC.  It will differ from this bit in the following cases:
A) Do not enter DEEPSLEEP while the sequencer is busy (see PWR_REGHC_STATUS.REGHC_SEQ_BUSY).  The hardware sequencer disables REGHC during DEEPSLEEP entry and enables it upon wakeup.
B) The debugger requests the chip remain powered up.  Hardware prevents REGHC from disabling when this bit is cleared.  Hardware does not automatically enable REGHC in response to debugger power up request.  If this bit is low when the debugger deasserts the power up request, the hardware sequencer will disable REGHC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_CTL</name>
          <description>PMIC Control Register</description>
          <addressOffset>0x10C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x104</resetValue>
          <resetMask>0xBFFF85FC</resetMask>
          <fields>
            <field>
              <name>PMIC_VREF</name>
              <description>PMIC reference voltage setting.  This selects the scaling factor used to generate the output voltage (vout) given the feedback voltage (vfb) for the chosen PMIC.  For a PMIC that compares vfb to an internal reference voltage (vref) according to the formula vout=vref/vfb, select that vref below.  For a PMIC that contains an internal resistor divider and expects an unscaled feedback voltage, use the 'No scaling' choice.
2'b00: Scale for vref=0.9V, use PMIC_VADJ to set the vccd target;
2'b01: Scale for vref=0.8V, use PMIC_VADJ to set the vccd target;
2'b10: Scale for vref=0.6V, use PMIC_VADJ to set the vccd target;
2'b11: No scaling, PMIC_VADJ has no effect</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_VADJ</name>
              <description>Voltage adjustment output setting.  The lookup table in this field requires the proper setting in PMIC_VREF for the chosen PMIC.  This field has no effect when PMIC_VREF selects no scaling.  The feedback tap point is at a vccd pad inside the chip, so the voltage may be a little higher at the PMIC output.
0x03: 1.040V, 0x04: 1.049V,
0x05: 1.057V, 0x06: 1.066V,
0x07: 1.074V, 0x08: 1.083V,
0x09: 1.091V, 0x0A: 1.099V,
0x0B: 1.108V, 0x0C: 1.116V,
0x0D: 1.125V, 0x0E: 1.133V,
0x0F: 1.142V, 0x10: 1.150V,
0x11: 1.158V, 0x12: 1.167V,
0x13: 1.175V, 0x14: 1.184V,
0x15: 1.192V, 0x16: 1.201V,
0x17: 1.209V, 0x18: 1.218V,
0x19: 1.226V, 0x1A: 1.234V,
0x1B: 1.243V, 0x1C: 1.251V,
others: Illegal.  Behavior is undefined.</description>
              <bitRange>[8:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_USE_LINREG</name>
              <description>Controls whether hardware sequencer keeps the internal Active Linear Regulator enabled to improve supply supervision of vccd.  When using this feature, if the PMIC fails to keep vccd above the internal regulator target, then the internal regulator will attempt to recover vccd.  If the regulator current is too high, the regulator triggers an over-current detector (OCD) reset.
0: Internal Active Linear Regulator disabled after PMIC enabled.  OCD is disabled.;
1: Internal Active Linear Regulator kept enabled.  See datasheet for minimum PMIC vccd input to prevent OCD.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_VADJ_BUF_EN</name>
              <description>Analog buffer enable on voltage adjust output.  Write this bit depending on the type of PMIC connected:
0: Bypass buffer.  This connects the resistor divider directly to the output pin.  Use this setting for a PMIC with a high-impedance feedback input, such as those that support a resistor divider on the PCB.  This setting can also be used with a low-impedance PMIC with PMIC_VREF=2'b11 (no scaling).
1: Use analog buffer.  This enables an analog buffer between the resistor divider output and the pin.  The buffer can drive a resistor divider on the PCB that feeds into the PMIC feedback input.  This allows targeting a different PMIC reference voltage from PMIC_VREF choices, while still supporting voltage adjustment using the internal divider.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_CTL_OUTEN</name>
              <description>Output enable for PMIC enable pin.  Set this bit high to enable the driver on this pin.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_CTL_POLARITY</name>
              <description>Polarity used to enable the PMIC.  The sequencer uses PMIC_CTL_POLARITY to enable the PMIC, and it uses the complement to disable the PMIC.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_STATUS_INEN</name>
              <description>Input buffer enable for PMIC status input.  Set this bit high to enable the input receiver.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_STATUS_POLARITY</name>
              <description>The polarity used to trigger a reset action based on the PMIC status input.  The reset system triggers a reset when the unmasked PMIC status matches this value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_STATUS_WAIT</name>
              <description>Wait count in 4us steps after PMIC status ok.  This is used by the hardware sequencer to allow additional settling time before disabling the internal regulator.  The LSB is 32 IMO periods which results in a nominal LSB step of 4us.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_CONFIGURED</name>
              <description>Indicates the PMIC has been configured.  This is used to know if PMIC should be enabled in response to a debug power up request.  Do not change PMIC settings after this bit is set high.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_STATUS</name>
          <description>PMIC Status Register</description>
          <addressOffset>0x10C4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80001001</resetMask>
          <fields>
            <field>
              <name>PMIC_ENABLED</name>
              <description>Indicates the state of the PMIC enable/disable sequencer.  This bit is only valid when PMIC_SEQ_BUSY==0.
0: PMIC sequencer indicates PMIC is disabled.
1: PMIC sequencer indicates PMIC is enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_STATUS_OK</name>
              <description>Indicates the PMIC status is ok.  This includes polarity adjustment according to PMIC_STATUS_POLARITY.
0: PMIC status is not ok or PMIC input buffer is disabled (PMIC_STATUS_INEN==0);
1: PMIC status input buffer is enabled and indicates ok</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_SEQ_BUSY</name>
              <description>Indicates the PMIC enable/disable sequencer is busy transitioning to/from PMIC.
0: Sequencer is not busy;
1: Sequencer is busy either enabling or disabling PMIC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_CTL2</name>
          <description>PMIC Control Register 2</description>
          <addressOffset>0x10C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>PMIC_STATUS_TIMEOUT</name>
              <description>Timeout while waiting for PMIC_STATUS_OK==1 when switching to PMIC.
0: disables timeout.  Do not change this register after setting PWR_PMIC_CTL.PMIC_CONFIGURED.
&gt;0: enables timeout of PMIC_STATUS_TIMEOUT*128us (nominal, clocked by IMO).  Timeout expiration triggers reset.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN</name>
              <description>Enable PMIC.  This bit will not set if PMIC_CONFIGURED==0.  Use PWR_PMIC_STATUS.ENABLED to know the actual status of PMIC.  It will differ from this bit in the following cases:
A) Do not enter DEEPSLEEP while the sequencer is busy (see PWR_PMIC_STATUS.PMIC_SEQ_BUSY).  The hardware sequencer disables PMIC during DEEPSLEEP entry and enables it upon wakeup.
B) The debugger requests the chip remain powered up.  Hardware prevents PMIC from disabling when this bit is cleared.  Hardware does not automatically enable PMIC in response to debugger power up request.  If this bit is low when the debugger deasserts the power up request, the hardware sequencer will disable PMIC.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PMIC_CTL4</name>
          <description>PMIC Control Register 4</description>
          <addressOffset>0x10D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>PMIC_VADJ_DIS</name>
              <description>Disables the VADJ circuitry.  This can be used to decrease current consumption if the entire feedback network is outside the device.
0: Device generates VADJ when PMIC is enabled.  This allows the feedback loop to compensate for voltage drops in the PCB and package.
1: Device does not generate VADJ, and it must not be part of the PMIC feedback loop.  This reduces current by turning off the internal resistor divider that generates VADJ.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_DPSLP</name>
              <description>Configures PMIC behavior during DEEPSLEEP.
0: Device operates from internal regulators during DEEPSLEEP.  If PMIC is enabled at the beginning of the DEEPSLEEP transition, hardware changes to the internal regulators and disables the PMIC.
1: DEEPSLEEP transition does not change PMIC enable.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PATH_SELECT[%s]</name>
          <description>Clock Path Select Register</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PATH_MUX</name>
              <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_MUX</name>
                  <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO - Low-Power External-Crystal Oscillator</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IHO</name>
                  <description>IHO - Internal High-speed Oscillator</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_ROOT_SELECT[%s]</name>
          <description>Clock Root Select Register</description>
          <addressOffset>0x1240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000F3F</resetMask>
          <fields>
            <field>
              <name>ROOT_MUX</name>
              <description>Selects a clock path for HFCLK&lt;k&gt; and SRSS DSI input &lt;k&gt;.  The output of this mux goes to the direct mux (see CLK_DIRECT_SELECT).  Use CLK_SELECT_PATH[i] to configure the desired path.  The number of clock paths is product-specific, and selecting an unimplemented path is not supported.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PATH0</name>
                  <description>Select PATH0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH1</name>
                  <description>Select PATH1</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH2</name>
                  <description>Select PATH2</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH3</name>
                  <description>Select PATH3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH4</name>
                  <description>Select PATH4</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH5</name>
                  <description>Select PATH5</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH6</name>
                  <description>Select PATH6</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH7</name>
                  <description>Select PATH7</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH8</name>
                  <description>Select PATH8</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH9</name>
                  <description>Select PATH9</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH10</name>
                  <description>Select PATH10</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH11</name>
                  <description>Select PATH11</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH12</name>
                  <description>Select PATH12</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH13</name>
                  <description>Select PATH13</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH14</name>
                  <description>Select PATH14</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH15</name>
                  <description>Select PATH15</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROOT_DIV</name>
              <description>Obsolete.  Do not use in new designs.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROOT_DIV_INT</name>
              <description>Selects predivider value for this clock root and DSI input.  This divider is after DIRECT_MUX.  For products with DSI, the output of this mux is routed to DSI for use as a signal.  For products with clock supervision, the output of this mux is the monitored clock for CSV_HF&lt;k&gt;.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_3</name>
                  <description>Divide selected clock source by 3</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_5</name>
                  <description>Divide selected clock source by 5</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_6</name>
                  <description>Divide selected clock source by 6</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_7</name>
                  <description>Divide selected clock source by 7</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_9</name>
                  <description>Divide selected clock source by 9</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_10</name>
                  <description>Divide selected clock source by 10</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_11</name>
                  <description>Divide selected clock source by 11</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_12</name>
                  <description>Divide selected clock source by 12</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_13</name>
                  <description>Divide selected clock source by 13</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_14</name>
                  <description>Divide selected clock source by 14</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_15</name>
                  <description>Divide selected clock source by 15</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_16</name>
                  <description>Divide selected clock source by 16</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_DIRECT_SELECT[%s]</name>
          <description>Clock Root Direct Select Register</description>
          <addressOffset>0x1280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x100</resetMask>
          <fields>
            <field>
              <name>DIRECT_MUX</name>
              <description>Direct selection mux that allows IMO to bypass most of the clock mux structure.    For products with multiple regulators, this mux can be used to reduce current without requiring significant reconfiguration of the clocking network.  The default value of HFCLK&lt;0&gt;==ROOT_MUX, and the default value for other clock trees is product-specific.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Select IMO</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ROOT_MUX</name>
                  <description>Select ROOT_MUX selection</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <name>CSV_HF</name>
          <description>Clock Supervisor (CSV) registers for Root clocks</description>
          <headerStructName>CSV_HF</headerStructName>
          <addressOffset>0x00001400</addressOffset>
          <cluster>
            <dim>7</dim>
            <dimIncrement>16</dimIncrement>
            <name>CSV[%s]</name>
            <description>Active domain Clock Supervisor (CSV) registers</description>
            <headerStructName>CSV_HF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC000FFFF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable or DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_ACTION</name>
                  <description>Specifies the action taken when an anomaly is detected on the monitored clock.  CSV in DeepSleep domain always do a Fault report (which also wakes up the system).</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>Generate a fault</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RESET</name>
                      <description>Cause a power reset. This should only be used for clk_hf0.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.

A CSV error detection is reported to the Fault structure, or instead it can generate a power reset.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens.
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock selection register</description>
          <addressOffset>0x1500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF07</resetMask>
          <fields>
            <field>
              <name>LFCLK_SEL</name>
              <description>Select source for LFCLK.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator.  Requires Backup domain to be present and properly configured (including external watch crystal, if used).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock.  Capability is product-specific</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO, if present.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>ILO1 - Internal Low-speed Oscillator #1, if present.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO_PRESCALER - External-Crystal Oscillator after prescaling, if present.  Does not work in DEEPSLEEP or HIBERNATE modes.  Intended for applications that operate in ACTIVE/SLEEP modes only.  This option is only valid when ECO is present in the product. Not compatible with an clk_sys frequency &lt;48MHz.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>LPECO_PRESCALER - Low-Power External-Crystal Oscillator after prescaling, if present.  This choice works in ACTIVE/SLEEP/DEEPSLEEP modes.  This option is only valid when LPECO is present in the product.</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock PATH&lt;k&gt;, where k=PUMP_SEL.  The output of this mux goes to the PUMP_DIV to make PUMPCLK  Each product has a specific number of available clock paths.  Selecting a path that is not implemented on a product will result in undefined behavior.  Note that this is not a glitch free mux.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP_DIV</name>
              <description>Division ratio for PUMPCLK.  Uses selected PUMP_SEL clock as the source.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_16</name>
                  <description>Divide selected clock source by 16</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_ENABLE</name>
              <description>Enable the pump clock.  PUMP_ENABLE and the PUMP_SEL mux are not glitch-free to minimize side-effects, avoid changing the PUMP_SEL and PUMP_DIV while changing PUMP_ENABLE.  To change the settings, do the following:
1) If the pump clock is enabled, write PUMP_ENABLE=0 without changing PUMP_SEL and PUMP_DIV.
2) Change PUMP_SEL and PUMP_DIV to desired settings with PUMP_ENABLE=0.
3) Write PUMP_ENABLE=1 without changing PUMP_SEL and PUMP_DIV.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO0_CONFIG</name>
          <description>ILO0 Configuration</description>
          <addressOffset>0x1508</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xC0000001</resetMask>
          <fields>
            <field>
              <name>ILO0_BACKUP</name>
              <description>This register indicates that ILO0 should stay enabled during XRES and HIBERNATE modes.  If backup voltage domain is implemented on the product, this bit also indicates if ILO0 should stay enabled through power-related resets on other supplies, e.g.. BOD on VDDD/VCCD.  Writes to this field are ignored unless the WDT is unlocked.  This register is reset when the backup logic resets.
0: ILO0 turns off during XRES, HIBERNATE, and power-related resets.  ILO0 configuration and trims are reset by these events.
1: ILO0 stays enabled, as described above.  ILO0 configuration and trims are not reset by these events.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO0_MON_ENABLE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.

HT-variant: This register will not clear unless PWR_CTL2.BGREF_LPMODE==0. After enabling, the first ILO0 cycle occurs within 12us and is +/-10 percent accuracy.  Thereafter, ILO0 is +/-5 percent accurate.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO1_CONFIG</name>
          <description>ILO1 Configuration</description>
          <addressOffset>0x150C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>ILO1_MON_ENABLE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO1.

HT-variant: After enabling, the first ILO1 cycle occurs within 12us and is +/-10 percent accuracy.  Thereafter, ILO1 is +/-5 percent accurate.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration</description>
          <addressOffset>0x1518</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>DPSLP_ENABLE</name>
              <description>Enable for IMO during DEEPSLEEP.  This bit configures IMO behavior during DEEPSLEEP:
0: IMO is automatically disabled during DEEPSLEEP and enables upon wakeup;
1: IMO is kept enabled throughout DEEPSLEEP</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  This bit must be high at all times for all functions to work properly.  Hardware will automatically disable the IMO during HIBERNATE and XRES.  It will automatically disable during DEEPSLEEP if DPSLP_ENABLE==0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG</name>
          <description>ECO Configuration Register</description>
          <addressOffset>0x151C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x98000002</resetMask>
          <fields>
            <field>
              <name>AGC_EN</name>
              <description>Automatic Gain Control (AGC) enable.  When set, the oscillation amplitude is controlled to the level selected by CLK_ECO_CONFIG2.ATRIM.  When low, the amplitude is not explicitly controlled and can be as high as the vddd supply.  WARNING: use care when disabling AGC because driving a crystal beyond its rated limit can permanently damage the crystal.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_DIV_DISABLE</name>
              <description>ECO prescaler disable command (mutually exclusive with ECO_DIV_ENABLE). SW sets this field to '1' and HW sets this field to '0'.

HW sets ECO_DIV_DISABLE field to '0' immediately and HW sets CLK_ECO_PRESCALE.ECO_DIV_EN field to '0' immediately.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_DIV_ENABLE</name>
              <description>ECO prescaler enable command (mutually exclusive with ECO_DIV_DISABLE). ECO Prescaler only works in ACTIVE and SLEEP modes.  SW sets this field to '1' to enable the divider and HW sets this field to '0' to indicate that divider enabling has completed. When the divider is enabled, its integer and fractional counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the ECO_DIV_DISABLE field.
1: Configure CLK_ECO_PRESCALE registers.
2: Enable the divider using the ECO_DIV_ENABLE field.

HW sets the ECO_DIV_ENABLE field to '0' when the enabling is performed and HW set CLK_ECO_PRESCALER.ENABLED to '1' when the enabling is performed.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_EN</name>
              <description>Master enable for ECO oscillator.  Configure the settings in CLK_ECO_CONFIG2 to work with the selected crystal, before enabling ECO.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_PRESCALE</name>
          <description>ECO Prescaler Configuration Register</description>
          <addressOffset>0x1520</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFF01</resetMask>
          <fields>
            <field>
              <name>ECO_DIV_ENABLED</name>
              <description>ECO prescaler enabled. HW sets this field to '1' as a result of an CLK_ECO_CONFIG.ECO_DIV_ENABLE command. HW sets this field to '0' as a result on a CLK_ECO_CONFIG.ECO_DIV_DISABLE command.  ECO prescaler is incompatible with DEEPSLEEP modes, and firmware must disable it before entering DEEPSLEEP.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_FRAC_DIV</name>
              <description>8-bit fractional value, sufficient to get prescaler output within the +/-65ppm calibration range.  Do not change this setting when ECO Prescaler is enabled.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_INT_DIV</name>
              <description>10-bit integer value allows for ECO frequencies up to 33.55MHz.  Subtract one from the desired divide value when writing this field.  For example, to divide by 1, write ECO_INT_DIV=0.  Do not change this setting when ECO Prescaler is enabled.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_STATUS</name>
          <description>ECO Status Register</description>
          <addressOffset>0x1524</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ECO_OK</name>
              <description>Indicates the ECO internal oscillator circuit has sufficient amplitude.  It may not meet the PPM accuracy or duty cycle spec.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_READY</name>
              <description>Indicates the ECO internal oscillator circuit has had enough time to fully stabilize.  This is the output of a counter since ECO was enabled, and it does not check the ECO output.  It is recommended to also confirm ECO_OK==1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_PILO_CONFIG</name>
          <description>Precision ILO Configuration Register</description>
          <addressOffset>0x1528</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000</resetValue>
          <resetMask>0x80010001</resetMask>
          <fields>
            <field>
              <name>PILO_BACKUP</name>
              <description>If backup domain is present on this product, this register indicates that PILO should stay enabled for use by backup domain during XRES, and HIBERNATE mode.    If backup voltage domain is implemented on the product, PILO should stay enabled through power-related resets on other supplies, e.g.. BOD on VDDD/VCCD.   If the PILO is the selected source for WDT, writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.
0: PILO turns off at XRES/BOD events.  (unless backup voltage domain is implemented on the product)
1: PILO remains on if backup domain is present and powered even for XRES/BOD or HIBERNATE entry.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_TCSC_EN</name>
              <description>PILO second order temperature curvature correction enable.  If the PILO is the selected source for WDT, writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.
0: Disable second order temperature curvature correction.
1: Enable second order temperature curvature correction.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_EN</name>
              <description>Enable PILO.  If the PILO is the selected source for WDT, writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG</name>
          <description>FLL Configuration Register</description>
          <addressOffset>0x1530</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x8103FFFF</resetMask>
          <fields>
            <field>
              <name>FLL_MULT</name>
              <description>Multiplier to determine CCO frequency in multiples of the frequency of the selected reference clock (Fref).

Ffll = (FLL_MULT)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV+1)</description>
              <bitRange>[17:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: no division
1: divide by 2</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_ENABLE</name>
              <description>Master enable for FLL.  The FLL requires firmware sequencing when enabling and disabling.  Hardware handles sequencing automatically when entering/exiting DEEPSLEEP.

To enable the FLL, use the following sequence:
1) Configure FLL and CCO settings.  Do not modify CLK_FLL_CONFIG3.BYPASS_SEL (must be AUTO) or CLK_FLL_CONFIG.FLL_ENABLE (must be 0).
2) Enable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=1
3) Wait until CLK_FLL_STATUS.CCO_READY==1.
4) Ensure the reference clock has stabilized.
5) Write FLL_ENABLE=1.
6) Optionally wait until CLK_FLL_STATUS.LOCKED==1.  The hardware automatically changes to the FLL output when LOCKED==1.

To disable the FLL, use the following sequence:
1) Write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF.
2) Read CLK_FLL_CONFIG3.BYPASS_SEL to ensure the write completes (read is not optional).
3) Wait at least ten cycles of either FLL reference clock or FLL output clock, whichever is slower.
4) Disable FLL with FLL_ENABLE=0.
5) Disable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=0.
6) Write CLK_FLL_CONFIG3.BYPASS_SEL=AUTO.
7) Read CLK_FLL_CONFIG3.BYPASS_SEL to ensure the write completes (read is not optional).
8) Wait three cycles of FLL reference clock.

0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG2</name>
          <description>FLL Configuration Register 2</description>
          <addressOffset>0x1534</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20001</resetValue>
          <resetMask>0xFFFF1FFF</resetMask>
          <fields>
            <field>
              <name>FLL_REF_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
8191: divide by 8191</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_TOL</name>
              <description>Lock tolerance sets the error threshold for when the FLL output is considered locked to the reference input.  A high tolerance can be used to lock more quickly or allow less accuracy.  The tolerance is the allowed difference between the count value for the ideal formula and the measured value.
0: tolerate error of 1 count value
1: tolerate error of 2 count values
...
255: tolerate error of 256 count values</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPDATE_TOL</name>
              <description>Update tolerance sets the error threshold for when the FLL will update the CCO frequency settings.  The update tolerance is the allowed difference between the count value for the ideal formula and the measured value. UPDATE_TOL should be less than LOCK_TOL.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG3</name>
          <description>FLL Configuration Register 3</description>
          <addressOffset>0x1538</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2800</resetValue>
          <resetMask>0x301FFFFF</resetMask>
          <fields>
            <field>
              <name>FLL_LF_IGAIN</name>
              <description>FLL Loop Filter Gain Setting #1.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_LF_PGAIN</name>
              <description>FLL Loop Filter Gain Setting #2.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SETTLING_COUNT</name>
              <description>Number of undivided reference clock cycles to wait after changing the CCO trim until the loop measurement restarts.  A delay allows the CCO output to settle and gives a more accurate measurement.  The default is tuned to an 8MHz reference clock since the IMO is expected to be the most common use case.
0: no settling time
1: wait one reference clock cycle
...
8191: wait 8191 reference clock cycles</description>
              <bitRange>[20:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after FLL output.  This register can be written while the FLL is enabled.  When changing BYPASS_SEL, do not turn off the reference clock or CCO clock for five cycles (whichever is slower).  Whenever BYPASS_SEL is changed, it is required to read CLK_FLL_CONFIG3 to ensure the change takes effect.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects FLL reference input (bypass mode).  When locked, automatically selects FLL output.  This can allow some processing to occur while the FLL is locking, such as after DEEPSLEEP wakeup.  It is incompatible with clock supervision, because the frequency changes based on the lock signal.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOCKED_OR_NOTHING</name>
                  <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_REF</name>
                  <description>Select FLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_OUT</name>
                  <description>Select FLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG4</name>
          <description>FLL Configuration Register 4</description>
          <addressOffset>0x153C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xC1FF07FF</resetMask>
          <fields>
            <field>
              <name>CCO_LIMIT</name>
              <description>Maximum CCO offset allowed (used to prevent FLL dynamics from selecting an CCO frequency that the logic cannot support)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_RANGE</name>
              <description>Frequency range of CCO</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RANGE0</name>
                  <description>Target frequency is in range [48, 64) MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE1</name>
                  <description>Target frequency is in range [64, 85) MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE2</name>
                  <description>Target frequency is in range [85, 113) MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE3</name>
                  <description>Target frequency is in range [113, 150) MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE4</name>
                  <description>Target frequency is in range [150, 200] MHz</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCO_FREQ</name>
              <description>CCO frequency code.  This is updated by HW when the FLL is enabled.  It can be manually updated to use the CCO in an open loop configuration.  The meaning of each frequency code depends on the range.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_HW_UPDATE_DIS</name>
              <description>Disable CCO frequency update by FLL hardware
0: Hardware update of CCO settings is allowed.  Use this setting for normal FLL operation.
1: Hardware update of CCO settings is disabled.  Use this setting for open-loop FLL operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_ENABLE</name>
              <description>Enable the CCO.  It is required to enable the CCO before using the FLL.
0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_STATUS</name>
          <description>FLL Status Register</description>
          <addressOffset>0x1540</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>FLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the FLL is enabled and goes out of lock.  This bit stays set until cleared by firmware.
Note: When exiting Deep Sleep with FLL enabled, UNLOCK_OCCURRED will set. Therefore, after FLL successfully locks, FW should clear UNLOCK_OCCURRED flag to prevent a false positive that would indicate that FLL erroneously unlocked.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_READY</name>
              <description>This indicates that the CCO is internally settled and ready to use.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG2</name>
          <description>ECO Configuration Register 2</description>
          <addressOffset>0x1544</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x7FF7</resetMask>
          <fields>
            <field>
              <name>WDTRIM</name>
              <description>Watch Dog Trim -  Delta voltage below steady state level
0x0 - 50mV
0x1 - 75mV
0x2 - 100mV
0x3 - 125mV
0x4 - 150mV
0x5 - 175mV
0x6 - 200mV
0x7 - 225mV</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATRIM</name>
              <description>Amplitude trim to set the crystal drive level when ECO_CONFIG.AGC_EN=1.  WARNING: use care when setting this field because driving a crystal beyond its rated limit can permanently damage the crystal.
0x0 - 150mV
0x1 - 175mV
0x2 - 200mV
0x3 - 225mV
0x4 - 250mV
0x5 - 275mV
0x6 - 300mV
0x7 - 325mV
0x8 - 350mV
0x9 - 375mV
0xA - 400mV
0xB - 425mV
0xC - 450mV
0xD - 475mV
0xE - 500mV
0xF - 525mV</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FTRIM</name>
              <description>Filter Trim - 3rd harmonic oscillation</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTRIM</name>
              <description>Feedback resistor Trim</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GTRIM</name>
              <description>Gain Trim - Startup time.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration</description>
          <addressOffset>0x1548</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>ILO_BACKUP</name>
              <description>If backup domain is present on this product, this register indicates that ILO should stay enabled for use by backup domain during XRES, HIBERNATE mode, and through power-related resets like BOD on VDDD/VCCD.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.
0: ILO turns off at XRES/BOD event or HIBERNATE entry.
1: ILO remains on if backup domain is present and powered even for XRES/BOD or HIBERNATE entry.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  After enabling, it takes at most two cycles to reach the accuracy spec.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO_CTL</name>
          <description>ILO Trim Register</description>
          <addressOffset>0x154C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2C</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>ILO_FTRIM</name>
              <description>IL0 frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO0_CTL</name>
          <description>ILO0 Trim Register</description>
          <addressOffset>0x1550</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x52C</resetValue>
          <resetMask>0xF3F</resetMask>
          <fields>
            <field>
              <name>ILO0_FTRIM</name>
              <description>ILO0 frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO0_MONTRIM</name>
              <description>ILO0 internal monitor trim.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_MF_SELECT</name>
          <description>Medium Frequency Clock Select Register</description>
          <addressOffset>0x1554</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FF07</resetMask>
          <fields>
            <field>
              <name>MFCLK_SEL</name>
              <description>Select source for MFCLK (clk_mf).  Note that not all products support all clock sources.  Selecting a clock source that is not supported results in undefined behavior.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MFO</name>
                  <description>MFO - Medium Frequency Oscillator.  DEEPSLEEP compatibility is product-specific.  See CLK_MFO_CONFIG for capability of this product.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator, if present.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock.  Capability is product-specific</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO, if present.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>ILO1 - Internal Low-speed Oscillator #1, if present.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO_PRESCALER - External-Crystal Oscillator, if present, after prescaling in CLK_ECO_PRESCALE.  Intended for applications that operate in ACTIVE/SLEEP modes only.  Does not work in DEEPSLEEP mode.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>LPECO - Low Power External Crystal Oscillator, if present.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MFCLK_DIV</name>
              <description>Divide selected clock source by (1+MFCLK_DIV).  The output of this divider is MFCLK (clk_mf).  Allows for integer divisions in the range [1, 256].  Do not change this setting while ENABLE==1.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for MFCLK (clk_mf).  When disabling clk_mf, do not disable the source until after 5 clk_mf periods.  clk_mf continues to operate in DEEPSLEEP for compatible sources.  Firmware must disable clk_mf before entering DEEPSLEEP if the source is not compatible with DEEPSLEEP mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_MFO_CONFIG</name>
          <description>MFO Configuration Register</description>
          <addressOffset>0x1558</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>DPSLP_ENABLE</name>
              <description>Enable for MFO during DEEPSLEEP.  This bit is ignored when ENABLE==0.  When ENABLE==1:
0: MFO is automatically disabled during DEEPSLEEP and enables upon wakeup;
1: MFO is kept enabled throughout DEEPSLEEP</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for Medium Frequency Oscillator (MFO) to generate clk_mf.  It is product-specific whether this is a separate component or implemented as a divided version of another clock (eg. IMO).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IHO_CONFIG</name>
          <description>IHO Configuration Register</description>
          <addressOffset>0x1560</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Enable for Internal High-speed Oscillator (IHO) to generate clk_iho.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ALTHF_CTL</name>
          <description>Alternate High Frequency Clock Control Register</description>
          <addressOffset>0x1564</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>ALTHF_ENABLED</name>
              <description>Indicates that ALTHF is actually enabled.  The delay between a transition on ALTHF_ENABLE and ALTHF_ENABLED is product specific.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ALTHF_ENABLE</name>
              <description>Enable for ALTHF clock when used by SRSS.  There may be independent control of ALTHF by another subsystem, and this bit prevents ALTHF from being disabled when SRSS needs it.  SRSS automatically removes its enable request during DEEPSLEEP and lower modes.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_CONFIG[%s]</name>
          <description>PLL Configuration Register</description>
          <addressOffset>0x1600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20116</resetValue>
          <resetMask>0xBE1F1F7F</resetMask>
          <fields>
            <field>
              <name>FEEDBACK_DIV</name>
              <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0-21: illegal (undefined behavior)
22: divide by 22
...
112: divide by 112
&gt;112: illegal (undefined behavior)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFERENCE_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
20: divide by 20
others: illegal (undefined behavior)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: illegal (undefined behavior)
2: divide by 2.  Suitable for direct usage as HFCLK source.
...
16: divide by 16.  Suitable for direct usage as HFCLK source.
&gt;16: illegal (undefined behavior)</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_DELAY</name>
              <description>N/A</description>
              <bitRange>[26:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LF_MODE</name>
              <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
0: VCO frequency is [200MHz, 400MHz]
1: VCO frequency is [170MHz, 200MHz)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.  When changing BYPASS_SEL, do not turn off the reference clock or PLL clock for five cycles (whichever is slower).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.  If ENABLE=0, automatically selects PLL reference input.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOCKED_OR_NOTHING</name>
                  <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.  If ENABLE=0, no clock is output.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_REF</name>
                  <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_OUT</name>
                  <description>Select PLL output.  Ignores lock indicator.  If ENABLE=0, no clock is output.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.

Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)

0: Block is disabled.  When the PLL disables, hardware controls the bypass mux as described in BYPASS_SEL, before disabling the PLL circuit.
1: Block is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_STATUS[%s]</name>
          <description>PLL Status Register</description>
          <addressOffset>0x1640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>PLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSV_REF_SEL</name>
          <description>Select CSV Reference clock for Active domain</description>
          <addressOffset>0x1700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>REF_MUX</name>
              <description>Selects a source for clock clk_ref_hf.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.   It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IHO</name>
                  <description>IHO - Internal High-speed Oscillator</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <name>CSV_REF</name>
          <description>CSV registers for the CSV Reference clock</description>
          <headerStructName>CSV_REF</headerStructName>
          <addressOffset>0x00001710</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>Active domain Clock Supervisor (CSV) registers for CSV Reference clock</description>
            <headerStructName>CSV_REF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC000FFFF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable or DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_ACTION</name>
                  <description>Specifies the action taken when an anomaly is detected on the monitored clock.  CSV in DeepSleep domain always do a Fault report (which also wakes up the system).</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>Generate a fault</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RESET</name>
                      <description>Cause a power reset. This should only be used for clk_hf0.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.

A CSV error detection is reported to the Fault structure, or instead it can generate a power reset.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens.
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>CSV_LF</name>
          <description>CSV registers for LF clock</description>
          <headerStructName>CSV_LF</headerStructName>
          <addressOffset>0x00001720</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>LF clock Clock Supervisor registers</description>
            <headerStructName>CSV_LF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x800000FF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.
CSV in Backup domain: Clock supervision operates during Hibernate mode, can be configured to wake from Hibernate, and continues operating during reboot.

A CSV error detection is reported to the Fault structure.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF00FF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens.
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>CSV_ILO</name>
          <description>CSV registers for ILO clock</description>
          <headerStructName>CSV_ILO</headerStructName>
          <addressOffset>0x00001730</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>HVILO clock DeepSleep domain Clock Supervisor registers</description>
            <headerStructName>CSV_ILO_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x800000FF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.
CSV in Backup domain: Clock supervision operates during Hibernate mode, can be configured to wake from Hibernate, and continues operating during reboot.

A CSV error detection is reported to the Fault structure.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF00FF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens.
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionally margin must be added for accuracy of both clocks.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A basic WatchDog Timer (WDT) reset has occurred since last power cycle.  ULP products: This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).

For products that support high-voltage cause detection, this bit blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ACT_FAULT</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_DPSLP_FAULT</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_TC_DBGRESET</name>
              <description>Test controller or debugger asserted reset. Only resets debug domain.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>A CPU requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT0</name>
              <description>Multi-Counter Watchdog timer reset #0.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above). This bit is only valid when parameter NUM_MCWDT&gt;0</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT1</name>
              <description>Multi-Counter Watchdog timer reset #1.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above). This bit is only valid when parameter NUM_MCWDT&gt;1</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT2</name>
              <description>Multi-Counter Watchdog timer reset #2.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above). This bit is only valid when parameter NUM_MCWDT&gt;2</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT3</name>
              <description>Multi-Counter Watchdog timer reset #3.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above). This bit is only valid when parameter NUM_MCWDT&gt;3</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE2</name>
          <description>Reset Cause Observation Register 2</description>
          <addressOffset>0x1804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FFFF</resetMask>
          <fields>
            <field>
              <name>RESET_CSV_HF</name>
              <description>Clock supervision logic requested a reset due to loss or frequency violation of a high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.  Each bit is only valid when the corresponding bit in parameter MASK_HFCSV is 1 and CSV_PRESENT is set.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CSV_REF</name>
              <description>Clock supervision logic requested a reset due to loss or frequency violation of the reference clock source that is used to monitor the other HF clock sources.  This bit is only valid when parameter CSV_PRESENT is set.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE_EXTEND</name>
          <description>Extended Reset Cause Observation Register</description>
          <addressOffset>0x1808</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x77FF0000</resetMask>
          <fields>
            <field>
              <name>RESET_XRES</name>
              <description>External XRES pin was asserted.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVDDD</name>
              <description>External VDDD supply crossed brown-out limit.  Note that this cause will only be observable as long as the VDDD supply does not go below the POR (power on reset) detection limit.  Below this limit it is not possible to reliably retain information in the device.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVDDA</name>
              <description>External VDDA supply crossed the brown-out limit.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVCCD</name>
              <description>Internal VCCD core supply crossed the brown-out limit.  Note that this detector will detect gross issues with the internal core supply, but may not catch all brown-out conditions.  Functional and timing supervision (CSV, WDT) is provided to create fully failsafe internal crash detection.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVDDD</name>
              <description>Overvoltage detection on the external VDDD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVDDA</name>
              <description>Overvoltage detection on the external VDDA supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVCCD</name>
              <description>Overvoltage detection on the internal core VCCD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_ACT_LINREG</name>
              <description>Overcurrent detection on the internal VCCD supply when supplied by the ACTIVE power mode linear regulator.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_DPSLP_LINREG</name>
              <description>Overcurrent detection on the internal VCCD supply when supplied by the DEEPSLEEP power mode linear regulator.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_REGHC</name>
              <description>Overcurrent detection from REGHC (if present).  If REGHC is not present, hardware will never set this bit.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PMIC</name>
              <description>PMIC status triggered a reset.  If PMIC control is not present, hardware will never set this bit.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PXRES</name>
              <description>PXRES triggered.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_STRUCT_XRES</name>
              <description>Structural reset was asserted.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PORVDDD</name>
              <description>Indicator that a POR occurred.  This is a high-voltage cause bit, and hardware clears the other bits when this one is set.  It does not block further recording of other high-voltage causes.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_PXRES_CTL</name>
          <description>Programmable XRES Control Register</description>
          <addressOffset>0x1814</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>PXRES_TRIGGER</name>
              <description>Triggers PXRES.  This causes a full-scope reset and reboot.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>32</dimIncrement>
          <name>CLK_DPLL_LP[%s]</name>
          <description>DPLL LP Configuration Register</description>
          <headerStructName>CLK_DPLL_LP</headerStructName>
          <addressOffset>0x00001A00</addressOffset>
          <register>
            <name>CONFIG</name>
            <description>DPLL_LP Configuration Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x20116</resetValue>
            <resetMask>0xB81F1FFF</resetMask>
            <fields>
              <field>
                <name>FEEDBACK_DIV</name>
                <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0-15: illegal (undefined behavior)
16: divide by 16
...
125: divide by 125
&gt;125: illegal (undefined behavior)</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REFERENCE_DIV</name>
                <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
16: divide by 16
others: illegal (undefined behavior)</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUTPUT_DIV</name>
                <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1.  Suitable for direct usage as HFCLK source.
2: divide by 2.  Suitable for direct usage as HFCLK source.
...
16: divide by 16.  Suitable for direct usage as HFCLK source.
&gt;16: illegal (undefined behavior)</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_DCO_CODE_MULT</name>
                <description>DCO code coefficient during SAR operation; this trim bit is Fpfd frequency dependent
0: multilply by 16, Fpfd &lt;= 8MHZ
1: mulitply by 28, Fpfd &gt; 8MHz</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS_SEL</name>
                <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.  When changing BYPASS_SEL, do not turn off the reference clock or PLL clock for five cycles (whichever is slower).</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>AUTO</name>
                    <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.  If ENABLE=0, automatically selects PLL reference input.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LOCKED_OR_NOTHING</name>
                    <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.  If ENABLE=0, no clock is output.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PLL_BYPASS</name>
                    <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PLL_OUT</name>
                    <description>Select PLL output.  Ignores lock indicator.  If ENABLE=0, no clock is output.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.

fOUT = (FEEDBACK_DIV + FRAC_EN*FRAC_DIV/2^24)  * (fREF / REFERENCE_DIV) / (OUTPUT_DIV)

0: Block is disabled.  When the PLL disables, hardware controls the bypass mux as described in BYPASS_SEL, before disabling the PLL circuit.
1: Block is enabled</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG2</name>
            <description>DPLL_LP Configuration Register 2</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF0FFFFFF</resetMask>
            <fields>
              <field>
                <name>FRAC_DIV</name>
                <description>Control bits for fractional divider.  This value is interpreted as a fraction of the PFD frequency, i.e. fPFD * (FRAC_DIV/2^24).  This field can be dynamically updated within the 1000ppm control limit. It takes up to 115 AHB cycles to transfer the setting to the PLL, and writes that occur faster may be silently ignored and require the application to write again after the previous update has finished.  Reading the register returns the accepted value.  The PLL will start targeting the new value, but it may take significant time (milliseconds) to stabilize at the new average value.  Do not change the FRAC_DIV setting while the PLL is initially locking.</description>
                <bitRange>[23:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAC_DITHER_EN</name>
                <description>N/A</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAC_EN</name>
                <description>Enables fractional division mode.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG3</name>
            <description>DPLL_LP Configuration Register 3</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x910703FF</resetMask>
            <fields>
              <field>
                <name>SSCG_DEPTH</name>
                <description>N/A</description>
                <bitRange>[9:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_RATE</name>
                <description>N/A</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_DITHER_EN</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_MODE</name>
                <description>N/A</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SSCG_EN</name>
                <description>Enables spreading mode.
When SSCG mode is enabled, DPLL_LP_TEST4.PLL_DIS_FAST_LOCK should be set to 1 to disable fast re-lock.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG4</name>
            <description>DPLL_LP Configuration Register 4</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x5000F</resetValue>
            <resetMask>0x13F07FF</resetMask>
            <fields>
              <field>
                <name>DCO_CODE</name>
                <description>Initial DCO code.  It is recommended to leave this at the default setting. This setting only has effect in open loop mode.  See DPLL BROS regarding test modes.</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACC_MODE</name>
                <description>N/A</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TDC_MODE</name>
                <description>N/A</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_TG</name>
                <description>This value is a number of PFD clocks in relation to the DCO count.  Can change the number of counts, set by p_div in integer mode, by the values of -1, +1, or +2.
0: 0
1: -1
2: +1
3: +2

In integer and SSCG mode, PLL_TG must be set to 0.
If in fractional mode, PLL_TG must be 0 if frac_ratio &lt;= 0.5 (pll_frac &lt;= 2^23), PLL_TG must be 2 if frac_ratio &gt; 0.5 (pll_frac &gt; 2^23).</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACC_CNT_LOCK</name>
                <description>Control signal for switching to stable filter coefficients (PLL_KP_TRIM/PLL_KI_TRIM)
0: PLL_ACC_PHASE_CNT_DONE
1: PLL_LOCK</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG5</name>
            <description>DPLL_LP Configuration Register 5</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1A231C24</resetValue>
            <resetMask>0x7F7F7F7F</resetMask>
            <fields>
              <field>
                <name>KI_INT</name>
                <description>Gain of P/I loop filter integrator path for INT operation.  Gain coefficient is 2^KI, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KP_INT</name>
                <description>Gain of P/I loop filter integrator path for INT operation.  Gain coefficient is 2^KP, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[14:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KI_ACC_INT</name>
                <description>Gain of P/I loop filter integrator path during cold start for INT operation.  Gain coefficient is 2^KI, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KP_ACC_INT</name>
                <description>Gain of P/I loop filter integrator path during cold start for INT operation.  Gain coefficient is 2^KP, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[30:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG6</name>
            <description>DPLL_LP Configuration Register 6</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1A232024</resetValue>
            <resetMask>0x7F7F7F7F</resetMask>
            <fields>
              <field>
                <name>KI_FRACT</name>
                <description>Gain of P/I loop filter proportional path for FRACT operation.  Gain coefficient is 2^KI, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KP_FRACT</name>
                <description>Gain of P/I loop filter proportional path for FRACT operation.  Gain coefficient is 2^KP, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[14:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KI_ACC_FRACT</name>
                <description>Gain of P/I loop filter integrator path during cold start for FRACT operation.  Gain coefficient is 2^KI, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KP_ACC_FRACT</name>
                <description>Gain of P/I loop filter integrator path during cold start for FRACT operation.  Gain coefficient is 2^KP, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[30:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG7</name>
            <description>DPLL_LP Configuration Register 7</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x14161818</resetValue>
            <resetMask>0x7F7F7F7F</resetMask>
            <fields>
              <field>
                <name>KI_SSCG</name>
                <description>Gain of P/I loop filter proportional path for SSCG operation.  Gain coefficient is 2^KI, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KP_SSCG</name>
                <description>Gain of P/I loop filter proportional path for SSCG operation.  Gain coefficient is 2^KP, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[14:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KI_ACC_SSCG</name>
                <description>Gain of P/I loop filter integrator path during cold start for SSCG operation.  Gain coefficient is 2^KI, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KP_ACC_SSCG</name>
                <description>Gain of P/I loop filter integrator path during cold start for SSCG operation.  Gain coefficient is 2^KP, eg. 0=&gt;1, 15=&gt;32768.</description>
                <bitRange>[30:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>DPLL_LP Status Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>LOCKED</name>
                <description>PLL Lock Indicator</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>UNLOCK_OCCURRED</name>
                <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.
Note: When disabling DPLL via register write, UNLOCK_OCCURRED will set. Therefore, after enabling DPLL and DPLL successfully locks, FW should clear UNLOCK_OCCURRED flag to prevent a false positive that would indicate that DPLL erroneously unlocked.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>PWR_CBUCK_CTL</name>
          <description>Core Buck Control Register</description>
          <addressOffset>0x1C00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1114</resetValue>
          <resetMask>0x1F1F</resetMask>
          <fields>
            <field>
              <name>CBUCK_VSEL</name>
              <description>Voltage output selection.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.   The actual CBUCK voltage is the maximum of this setting, the settings for all enabled step-down regulators (see PWR_SDR*_CTL), and the minimum DEEPSLEEP setting (which is not user configurable).  These settings follow the formula (0.76+0.02*CBUCK_VSEL).
0: 0.76V, 1: 0.78V, 2: 0.80V, 3: 0.82V, 4: 0.84V, 5: 0.86V, 6: 0.88V, 7: 0.90V, 8: 0.92V, 9: 0.94V, 10: 0.96V, 11: 0.98V, 12: 1.00V, 13: 1.02V, 14: 1.04V, 15: 1.06V, 16: 1.08V, 17: 1.10V, 18: 1.12V, 19: 1.14V, 20: 1.16V, 21: 1.18V, 22: 1.20V, 23: 1.22V, 24: 1.24V, 25: 1.26V, 26: 1.28V, 27: 1.30V, 28: 1.32V, 29: 1.34V, 30: 1.36V, 31: 1.38V.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBUCK_MODE</name>
              <description>CBUCK mode.  Low ripple (high power) modes are intended for analog that needs low ripple.  Low power mode is suitable for digital processing.
The CBUCK mode is defined as = {mode*_sr_mode, mode*_sr_hp_submode[1:0], mode*_sr_lp_submode[1:0]}
The actual CBUCK mode is the maximum of this setting and the settings of all enabled step-down regulators.
0x11: HP, PFM Auto, High-Low (default Active)
0x01: LP, PFM Auto, High-Low (DeepSleep)
See s40power BROS for other settings</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CBUCK_CTL2</name>
          <description>Core Buck Control Register 2</description>
          <addressOffset>0x1C04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>CBUCK_OVERRIDE</name>
              <description>Forces the CBUCK to use the settings in PWR_CBUCK_CTL register, ignoring the other hardware requests.  This can be used as part of a firmware algorithm to change the voltage of an enabled stepdown regulator.  This bit is cleared by any reset.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBUCK_PAUSE</name>
              <description>Pauses new dynamic CBUCK transitions.  An already started transition will complete, but new dynamic transitions are paused.  This can be used as part of a firmware sequence to change the voltage setting of an enabled stepdown regulator.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBUCK_COPY_SETTINGS</name>
              <description>Copies the current CBUCK composite state to the fields in  PWR_CBUCK_CTL register (CBUCK_VSEL and CBUCK_MODE).  It is recommended to pause transitions using CBUCK_PAUSE to ensure the state does not change near the copy.  After it is copied, the CBUCK_OVERRIDE bit can be used to hold the CBUCK in the current state.  Note, reading this bit always returns 0.
0: no change
1: copy settings.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBUCK_USE_SETTINGS</name>
              <description>Causes the settings in  PWR_CBUCK_CTL register to be included in the CBUCK setting decision.  Can be used to override the normal hardware voltage behavior.  Regardless of this bit, the extra settings in  PWR_CBUCK_CTL register are not used during DEEPSLEEP.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CBUCK_CTL3</name>
          <description>Core Buck Control Register 3</description>
          <addressOffset>0x1C08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CBUCK_INRUSH_SEL</name>
              <description>CBUCK inrush limit selection.
0: 10mA limit.
1: 100mA limit.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CBUCK_STATUS</name>
          <description>Core Buck Status Register</description>
          <addressOffset>0x1C0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>PMU_DONE</name>
              <description>Indicates the power management unit is finished with a transition.
0: PMU busy
1: PMU done</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SDR0_CTL</name>
          <description>Step Down Regulator 0 Control Register</description>
          <addressOffset>0x1C10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8A09E34</resetValue>
          <resetMask>0xBCFFFFFF</resetMask>
          <fields>
            <field>
              <name>SDR0_CBUCK_VSEL</name>
              <description>Minimum voltage selection of CBUCK when using this SDR0 (see PWR_CBUCK_CTL for voltage table).  The voltage must be 60mV higher than the SDR output or the regulator output may bypass.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_CBUCK_MODE</name>
              <description>Minimum CBUCK mode when using SDR0 (see PWR_CBUCK_CTL for mode table).
Default Active</description>
              <bitRange>[9:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_CBUCK_DPSLP_VSEL</name>
              <description>DeepSleep voltage selection of CBUCK (see PWR_CBUCK_CTL for voltage table).  The voltage must be 60mV higher than the SDR output or the regulator output may bypass.</description>
              <bitRange>[14:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_CBUCK_DPSLP_MODE</name>
              <description>DeepSleep CBUCK mode when using SDR0 (see PWR_CBUCK_CTL for mode table).
Default DeepSleep</description>
              <bitRange>[19:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_VSEL</name>
              <description>SDR0 output voltage.
0: 0.850V, 1: 0.875V, 2: 0.900V, 3: 0.925V, 4: 0.950V, 5: 0.975V, 6: 1.000V, 7: 1.025V, 8: 1.050V, 9: 1.075V, 10: 1.100V, 11: 1.125V, 12: 1.150V, 13: 1.175V, 14: 1.200V, 15: 1.225V</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_DPSLP_VSEL</name>
              <description>SDR0 output voltage during DeepSleep.  (See SDR0_VSEL for voltage table).</description>
              <bitRange>[29:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR0_ALLOW_BYPASS</name>
              <description>SDR0 bypass control.
0: Force SDR0 to regulate.
1: Allow SDR0 to bypass if the actual CBUCK voltage matches SDR0_CBUCK_VSEL.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SDR1_CTL</name>
          <description>Step Down Regulator 1 Control Register</description>
          <addressOffset>0x1C14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x400A1114</resetValue>
          <resetMask>0xC00F1F1F</resetMask>
          <fields>
            <field>
              <name>SDR1_CBUCK_VSEL</name>
              <description>Minimum voltage selection of CBUCK when using this SDR1 (see PWR_CBUCK_CTL for voltage table).  The voltage must be 60mV higher than the SDR output or the regulator output may bypass.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR1_CBUCK_MODE</name>
              <description>Minimum CBUCK mode when using SDR1 (see PWR_CBUCK_CTL for mode table).</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR1_VSEL</name>
              <description>SDR1 output voltage.
0: 0.850V, 1: 0.875V, 2: 0.900V, 3: 0.925V, 4: 0.950V, 5: 0.975V, 6: 1.000V, 7: 1.025V, 8: 1.050V, 9: 1.075V, 10: 1.100V, 11: 1.125V, 12: 1.150V, 13: 1.175V, 14: 1.200V, 15: 1.225V</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR1_HW_SEL</name>
              <description>Selects hardware control for SDR1.
0: SDR1_ENABLE controls SDR1.  Hardware controls are ignored.
1: SDR1_ENABLE is ignored and a hardware signal is used instead.  Selecting this on products that don't have supporting hardware will disable SDR1.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDR1_ENABLE</name>
              <description>Enable for SDR1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HVLDO0_CTL</name>
          <description>HVLDO0 Control Register</description>
          <addressOffset>0x1C30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000007</resetValue>
          <resetMask>0xC000000F</resetMask>
          <fields>
            <field>
              <name>HVLDO0_VSEL</name>
              <description>HVLDO0 output voltage.
0: 1.8V, 1: 1.9V, 2: 2.0V, 3: 2.1V, 4: 2.2V, 5: 2.3V, 6: 2.4V, 7: 2.5V, 8: 2.6V, 9: 2.7V, 10: 2.8V, 11: 2.9V, 12: 3.0V, 13: 3.1V, 14: 3.2V, 15: 3.3V</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLDO0_HW_SEL</name>
              <description>Selects hardware control for HVLDO0.
0: HVLDO0_ENABLE controls SDR1.  Hardware controls are ignored.
1: HVLDO0_ENABLE is ignored and a hardware signal is used instead.  Selecting this on products that don't have supporting hardware will disable HVLDO0.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLDO0_ENABLE</name>
              <description>HVLDO0 enable</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_XRES_SECURE</name>
          <description>SECURE TEST and FIRMWARE TEST Key control register</description>
          <addressOffset>0x2054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE00F0FFF</resetMask>
          <fields>
            <field>
              <name>DATA8</name>
              <description>Data byte to be set into either SECURE TEST or FIRMWARE TEST key.  Must not be changed in the same write that is toggling any of the *_WR bits below,</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_WR</name>
              <description>Latch enables for each of the 4 bytes in the 32-bit FIRMWARE TEST key.  Must be toggled high and then low while keeping DATA8 to the correct value.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SECURE_WR</name>
              <description>Latch enables for each of the 4 bytes in the 32-bit SECURE TEST key.  Must be toggled high and then low while keeping DATA8 to the correct value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_KEY_OK</name>
              <description>Indicates that the 32-bit FIRMWARE TEST key is observing the correct key.  Firmware key is reset by (A)XRES and STRUCT_XRES.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SECURE_KEY_OK</name>
              <description>Indicates that the 32-bit SECURE TEST key is observing the correct key.  Secure key is not reset, but it will establish low after a deep power cycle that causes it to lose its written state.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SECURE_DISABLE</name>
              <description>Disables the SECURE TEST key entry capability until next reset.   Must not be set in the same write when any of the above *_WR bits are set or toggling.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_CBUCK_CTL</name>
          <description>CBUCK Trim Register</description>
          <addressOffset>0x20AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x1F1F</resetMask>
          <fields>
            <field>
              <name>CBUCK_DPSLP_VSEL</name>
              <description>The CBUCK voltage setting to use during DEEPSLEEP.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CBUCK_DPSLP_MODE</name>
              <description>The CBUCK mode setting to use during DEEPSLEEP.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_PWRSYS_CTL</name>
          <description>Power System Trim Register</description>
          <addressOffset>0x20E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x14</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>ACT_REG_TRIM</name>
              <description>Trim for the Active-Regulator.  This sets the output voltage level.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.  The nominal output voltage is vccd=850mV + ACT_REG_TRIM*12.5mV.  The actual output voltage will vary depending on conditions and load.  The following settings are explicitly shown for convenience, and other values may be calculated using the formula:
5'h04: 900mV (nominal)
5'h0C: 1000mV (nominal)
5'h14: 1100mV (nominal)
5'h1C: 1200mV (nominal)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REG_BOOST</name>
              <description>Controls the tradeoff between output current and internal operating current for the Active Regulator.  The maximum output current depends on the silicon implementation, but an application may limit its maximum current to less than that.  This may allow a reduction in the internal operating current of the regulator.  The regulator internal operating current depends on the boost setting:
2'b00: 50uA
2'b01: 100uA
2'b10: 150uA
2'b11: 200uA

The allowed setting is a lookup table based on the chip-specific maximum (set in factory) and an application-specific maximum (set by customer).  The defaults are set assuming the application consumes the maximum allowed by the chip.
50mA chip: 2'b00 (default);
100mA chip: 2'b00 (default);
150mA chip: 50..100mA app =&gt; 2'b00, 150mA app =&gt; 2'b01 (default);
200mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200mA app =&gt; 2'b10 (default);
250mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200..250mA app =&gt; 2'b10 (default);
300mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01, 200..250mA app =&gt; 2'b10, 300mA app =&gt; 2'b11 (default);

This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_PWRSYS_CTL2</name>
          <description>Power System Trim Register 2</description>
          <addressOffset>0x20E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3005200</resetValue>
          <resetMask>0x7777700</resetMask>
          <fields>
            <field>
              <name>DPSLP_REG_TRIM</name>
              <description>Trim for the DeepSleep-Regulator applied during DEEPSLEEP mode.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.
0: 0.825V
1: 0.850V
2: 0.875V
3: 0.900V
4: 0.925V
5: 1.050V
6: 1.100V
7: 1.150V</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_REG_TRIM</name>
              <description>Trim for the Retention-Regulator (if present) applied during DEEPSLEEP mode.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NWELL_REG_TRIM</name>
              <description>Trim for the Nwell-Regulator (if present) applied during DEEPSLEEP mode.  Nwell trim is always forced to zero during (LP)ACTIVE/(LP)SLEEP modes.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REG_ACT_TRIM</name>
              <description>Trim for the DeepSleep-Regulator applied during (LP)ACTIVE/(LP)SLEEP modes.  These are expected to be constant but provided as registers for risk mitigation.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_REG_ACT_TRIM</name>
              <description>Trim for the Retention-Regulator (if present) applied during (LP)ACTIVE/(LP)SLEEP modes.  These are expected to be constant but provided as registers for risk mitigation.  This register is only reset by XRES, HIBERNATE wakeup, or supply supervision reset.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ECO_CTL</name>
          <description>ECO Trim Register</description>
          <addressOffset>0x301C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F0000</resetValue>
          <resetMask>0x3F0000</resetMask>
          <fields>
            <field>
              <name>ITRIM</name>
              <description>Current Trim</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO1_CTL</name>
          <description>ILO1 Trim Register</description>
          <addressOffset>0x3220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x52C</resetValue>
          <resetMask>0xF3F</resetMask>
          <fields>
            <field>
              <name>ILO1_FTRIM</name>
              <description>ILO1 frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO1_MONTRIM</name>
              <description>ILO1 internal monitor trim.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>RAM_TRIM</name>
          <description>SRAM Trim registers</description>
          <headerStructName>RAM_TRIM</headerStructName>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>TRIM_RAM_CTL</name>
            <description>Trim Register for RAM Type 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIM</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRIM_ROM_CTL</name>
            <description>Trim Register for ROM</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIM</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>32</dimIncrement>
          <name>CLK_TRIM_DPLL_LP[%s]</name>
          <description>DPLL LP Trims</description>
          <headerStructName>CLK_TRIM_DPLL_LP</headerStructName>
          <addressOffset>0x00004200</addressOffset>
          <register>
            <name>DPLL_LP_CTL</name>
            <description>DPLL LP Trim Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x87000230</resetValue>
            <resetMask>0xBFFB73F0</resetMask>
            <fields>
              <field>
                <name>SAR_CYCLE_STOP</name>
                <description>Successive Approximation Register (SAR) configuration.  Ignored when SAR_DIS==1.
0x1...0xB: Number of cycles until SAR stops.
others: illegal
Note: For initial lock, default should be left at 0x3. After successful lock with code write = 0, FW should set to 0x1 to improve recovery time for successive locks.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SAR_DIS</name>
                <description>Disable Successive Approximation Register during locking.
0: Use SAR.
1: Disable SAR.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_SAR_FSM_EN</name>
                <description>SAR FSM enable. Always set to 1 for functional mode. This register was kept in the design (and moved to hidden trim register) to increase coverage on the hard IP, and could be removed once the hard IP input is removed.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LDO_DCO_TRIM</name>
                <description>Trim for PLL local regulator for DCO
0 0.906V
1 0.786V
2 0.846V
3 0.876V
4 0.936V
5 0.966V</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_DCO_SD_SEL</name>
                <description>00': disable, '01' first order SigmaDelta enabled;'10' third order SigmaDelta enabled;'11' RSVD</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LDO_PERI_TRIM</name>
                <description>pll ldo peripheri voltage trim (scan mode - can be '0' or '1' - not High Z)</description>
                <bitRange>[21:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_FRAC_ORDER</name>
                <description>Order of the delta-sigma modulator used for fractional mode.
If DPLL_LP_STRUCT_Regs.CONFIG4.ACC_MODE = 00b:
0: 4th order
1: 3rd order
If DPLL_LP_STRUCT_Regs.CONFIG4.ACC_MODE = 01b:
0: 2nd order
1: 1st order</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ISOLATE_N</name>
                <description>Manual isolation control for PLL .  This field is ignored when ENABLE_CNT==1.  When controlling manually, de-assert &gt;= 3us after ENABLE=1.  Assertion can happen in cycle just before ENABLE=0.
0: Isolate outputs
1: Do not isolate outputs</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ISOLATE_CNT</name>
                <description>Terminal count for the stabilization counter handles PLL_ISOLATE_N</description>
                <bitRange>[29:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_CNT</name>
                <description>Enable for the PLL hardware sequencer.
0: Disables the hardware sequencer.  Before enabling the DPLL manually make sure to have DPLL_LP_STRUCT_Regs-&gt;CONFIG-&gt;BYPASS_SEL at default value to avoid unwanted glitch on clock HF root.  When disabling the PLL, first deselect it using .BYPASS_SEL=PLL_REF, wait at least six PLL clock cycles, and then disable it with .ENABLE=0.  Before entering DEEPSLEEP, firmware must switch to another clock source and disable the PLL.
1: Enables the hardware sequencer.  The sequencer handles all PLL enable/disable transitions, including around DEEPSLEEP entry/exit.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DPLL_LP_CTL3</name>
            <description>DPLL LP Trim Register 3</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1007F</resetValue>
            <resetMask>0x3FF03FF</resetMask>
            <fields>
              <field>
                <name>PHASE_ACC_CNT</name>
                <description>counter for phase accelerate cycles during PLL wakeup for INT and FRAC modes
Optimal settings:
4 --&gt; 5 MHz: 127
5--&gt;6 MHz: 157
6--&gt;7 MHz: 187
7--&gt;8 MHz: 217
8--&gt;9 MHz: 255
9--&gt;10 MHz: 286
10--&gt;11 MHz: 317
11--&gt;12 MHz: 348
12--&gt;13 MHz: 379
13--&gt;14 MHz: 410
14--&gt;15 MHz: 441
15--&gt;16 MHz: 472
16 MHz: 	511</description>
                <bitRange>[9:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PHASE_ACC_CNT_SSCG</name>
                <description>counter for phase accelerate cycles during PLL wakeup SSCG mode
Optimal settings:
4 --&gt; 5 MHz: 127
5--&gt;6 MHz: 157
6--&gt;7 MHz: 187
7--&gt;8 MHz: 217
8--&gt;9 MHz: 255
9--&gt;10 MHz: 286
10--&gt;11 MHz: 317
11--&gt;12 MHz: 348
12--&gt;13 MHz: 379
13--&gt;14 MHz: 410
14--&gt;15 MHz: 441
15--&gt;16 MHz: 472
16 MHz: 	511</description>
                <bitRange>[25:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DPLL_LP_CTL4</name>
            <description>DPLL LP Trim Register 4</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xA50</resetValue>
            <resetMask>0x3FF3</resetMask>
            <fields>
              <field>
                <name>LOCK_WAIT_FALL</name>
                <description>Wait time from when static phase error is within the lock window until lock signal asserts.
0: 0 PFD clocks
1: 2 PFD clocks
2: 3 PFD clocks
3: 4 PFD clocks</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK_WAIT_RISE</name>
                <description>Wait time from when static phase error is within the lock window until lock signal asserts.
0: Illegal
1: 1 PFD clocks
2: 2 PFD clocks
...
1023: 1023 PFD clocks
Optimal settings
f, MHz         With Code Write                    Without Code Write
---------      ------------------------------------      ------------------------------------
 4--&gt;5                      6                                         33
 5--&gt;6                      6                                         40
 6--&gt;7                      6                                         49
 7--&gt;8                      8                                         60
 8--&gt;9                      8                                         85
 9--&gt;10                   11                                        95
10--&gt;11                  12                                       105
11--&gt;12                  14                                       115
12--&gt;13                  15                                       125
13--&gt;14                  17                                       135
14--&gt;15                  18                                       145
15--&gt;16                  20                                       155
        16                  21                                       165
Notes:
1. For initial DPLL locking or when DPLL Fast Lock is disabled (PLL_DIS_FAST_LOCK=1), user must program DPLL_CTL4.LOCK_WAIT_RISE using appropriate value for 'Without Code Write' for corresponding frequency range.
2. After initial DPLL locking, when DPLL Fast Lock is enabled (PLL_DIS_FAST_LOCK=0), before DEEPSLEEP entry, FW must poll the DPLL_LP.STATUS.LOCKED bit to acknowledge successful DPLL lock, then must program DPLL_LP_CTL4.LOCK_WAIT_RISE using appropriate value for 'With Code Write' for corresponding frequency range.</description>
                <bitRange>[13:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DPLL_LP_TEST4</name>
            <description>DPLL LP Test Register 4</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8100000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>PLL_USER_DCO_CODE</name>
                <description>FW can read the code saved by the DPLL before deepsleep.Use PLL_READ_EN to get updated DCO_CODE from the DPLL: To read properly please refer to PLL_USER_DCO_CODE_RD_EN/PLL_READ_EN.
Before any read, FW should check first that PLL_READ_EN is 0.
To account for Clock Domain Crossings, FW should wait at least 3 CLK_IMO cycles (3*125ns=375ns) between SW write and SW read operation.</description>
                <bitRange>[13:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_DIS_FAST_LOCK</name>
                <description>0: Enables DPLL Fast Lock
1: Disables DPLL Fast Lock

When PLL_DIS_FAST_LOCK=0, if DPLL successfully locks prior to a DEEPSLEEP entry:
- HW will read the DCO code before DEEPSLEEP entry, then write the DCO code upon DEEPSLEEP exit, to reduce DPLL lock time.
- FW must follow the procedure described under DPLL_LP_CTL4.LOCK_WAIT_RISE Notes: 2</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_READ_EN</name>
                <description>This bit is a self clear bit. The FW writes 1 to get an updated value in PLL_USER_DCO_CODE.HW will self clear this bit to indicate that the PLL_USER_DCO_CODE be read.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PHASE_ACC_USER_WRITE_INT</name>
                <description>Reduce KI,KP coefficient during PLL deepsleep wakeup integer.</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PHASE_ACC_USER_WRITE_FRACT</name>
                <description>reduce KI,KP coefficient during PLL deepsleep wakeup fract.</description>
                <bitRange>[29:23]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>WDT_CTL</name>
          <description>Watchdog Counter Control Register (Type A)</description>
          <addressOffset>0xC000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC0000031</resetMask>
          <fields>
            <field>
              <name>WDT_EN</name>
              <description>Enable this watchdog timer.  This field is retained during DEEPSLEEP and HIBERNATE modes.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_CLK_SEL</name>
              <description>Select source for WDT.  Not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  Writes to this field are ignored unless the WDT is unlock using WDT_LOCK register.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO. If present, if present</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>BAK - Selected clk_bak source, if present.  See BACKUP_CTL.  This choice is not recommended for applications that rely upon the watchdog timer for safety or security, unless the product supports clock supervision of clk_bak (CSV_BAK).  Generation of clk_bak is not protected by WDT_LOCK and is in a different memory region with potentially different security attributes.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WDT_LOCK</name>
              <description>Prohibits writing to WDT_*, CLK_ILO_CONFIG, CLK_SELECT.LFCLK_SEL, and CLK_TRIM_ILO_CTL registers when not equal 0.  Requires at least two different writes to unlock.  A change in WDT_LOCK takes effect beginning with the next write cycle.
Note that this field is 2 bits to force multiple writes only.  It represents only a single write protect signal protecting all those registers at the same time.  WDT will lock on any reset.  This field is not retained during DEEPSLEEP or HIBERNATE mode, so the WDT will be locked after wakeup from these modes.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_CHG</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR0</name>
                  <description>Clears bit 0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR1</name>
                  <description>Clears bit 1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET01</name>
                  <description>Sets both bits 0 and 1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CNT</name>
          <description>Watchdog Counter Count Register (Type A)</description>
          <addressOffset>0xC004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Current value of WDT Counter.  The write feature of this register is for engineering use (DfV), have no synchronization, and can only be applied when the WDT is fully off.  When writing, the value is updated immediately in the WDT counter, but it will read back as the old value until this register resynchronizes just after the negedge of ILO.  Writes will be ignored if they occur when the WDT is enabled.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH</name>
          <description>Watchdog Counter Match Register (Type A)</description>
          <addressOffset>0xC008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Match value for Watchdog counter.  Every time WDT_COUNTER reaches MATCH an interrupt is generated.  Two unserviced interrupts will lead to a system reset (i.e. at the third match).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH2</name>
          <description>Watchdog Counter Match Register 2 (Type A)</description>
          <addressOffset>0xC00C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>IGNORE_BITS_ABOVE</name>
              <description>The bit index to be considered the MSB for matching.  Bit indices above this setting are NOT checked against MATCH.  This value provides control over the time-to-reset of the watchdog (which happens after 3 successive matches).  The four LSBs cannot be ignored for matching.  Settings &lt;3 behave like a setting of 3.  If the setting is higher than the number of bits in the WDT counter, all actual bits in the counter are matched.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>MCWDT_STRUCT</name>
          <description>Multi-Counter Watchdog Timer (Type A)</description>
          <headerStructName>MCWDT_STRUCT</headerStructName>
          <addressOffset>0x0000D000</addressOffset>
          <register>
            <name>MCWDT_CNTLOW</name>
            <description>Multi-Counter Watchdog Sub-counters 0/1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_CTR0</name>
                <description>Current value of sub-counter 0 for this MCWDT.  Software writes are ignored when the sub-counter is enabled.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CTR1</name>
                <description>Current value of sub-counter 1 for this MCWDT.  Software writes are ignored when the sub-counter is enabled</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CNTHIGH</name>
            <description>Multi-Counter Watchdog Sub-counter 2</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_CTR2</name>
                <description>Current value of sub-counter 2 for this MCWDT.  Software writes are ignored when the sub-counter is enabled</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_MATCH</name>
            <description>Multi-Counter Watchdog Counter Match Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_MATCH0</name>
                <description>Match value for sub-counter 0 of this MCWDT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MATCH1</name>
                <description>Match value for sub-counter 1 of this MCWDT</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CONFIG</name>
            <description>Multi-Counter Watchdog Counter Configuration</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F01FFFF</resetMask>
            <fields>
              <field>
                <name>WDT_MODE0</name>
                <description>Watchdog Counter Action on Match.  Action is taken on the next increment after the values match (WDT_CTR0=WDT_MATCH0).</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT_THEN_RESET</name>
                    <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CLEAR0</name>
                <description>Clear Watchdog Counter when WDT_CTR0=WDT_MATCH0. In other words WDT_CTR0 divides LFCLK by (WDT_MATCH0+1).
0: Free running counter
1: Clear on match.  In this mode, the minimum legal setting of WDT_MATCH0 is 1.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CASCADE0_1</name>
                <description>Cascade Watchdog Counters 0,1.  Counter 1 increments the cycle after WDT_CTR0=WDT_MATCH0.
0: Independent counters
1: Cascaded counters</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_LOWER_MODE0</name>
                <description>Watchdog Counter Action on service before lower limit.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CARRY0_1</name>
                <description>Carry out behavior that applies when WDT_CASCADE0_1==1.  This bit is not used when WDT_CASCADE0_1==0.
0: carry out on counter 0 match.
1: carry out on counter 0 roll-over.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MATCH0_1</name>
                <description>Specifies matching behavior when WDT_CASCADE0_1==1.  When WDT_CASCADE0_1==0, this bit is not used and match is based on counter 1 alone.
0: Match based on counter 1 alone.
1: Match based on counter 1 and counter 0 matching simultaneously.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MODE1</name>
                <description>Watchdog Counter Action on Match.  Action is taken on the next increment after the values match (WDT_CTR1=WDT_MATCH1).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT_THEN_RESET</name>
                    <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CLEAR1</name>
                <description>Clear Watchdog Counter when WDT_CTR1==WDT_MATCH1. In other words WDT_CTR1 divides LFCLK by (WDT_MATCH1+1).
0: Free running counter
1: Clear on match.  In this mode, the minimum legal setting of WDT_MATCH1 is 1.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CASCADE1_2</name>
                <description>Cascade Watchdog Counters 1,2.  Counter 2 increments the cycle after WDT_CTR1=WDT_MATCH1.  It is allowed to cascade all three WDT counters.
0: Independent counters
1: Cascaded counters.  When cascading all three counters, WDT_CLEAR1 must be 1.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_LOWER_MODE1</name>
                <description>Watchdog Counter Action on service before lower limit.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CARRY1_2</name>
                <description>Carry out behavior that applies when WDT_CASCADE1_2==1.  This bit is not used when WDT_CASCADE1_2==0.
0: carry out on counter 1 match.
1: carry out on counter 1 roll-over.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MATCH1_2</name>
                <description>Specifies matching behavior when WDT_CASCADE1_2==1.  When WDT_CASCADE1_2==0, this bit is not used and match is based on counter 2 alone.
0: Match based on counter 2 alone.
1: Match based on counter 2 and counter 1 matching simultaneously.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MODE2</name>
                <description>Watchdog Counter 2 Mode.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Free running counter with no interrupt requests</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Free running counter with interrupt request that occurs one LFCLK cycle after the specified bit in CTR2 toggles (see WDT_BITS2).</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_BITS2</name>
                <description>Bit to observe for WDT_INT2:
0: Assert after bit0 of WDT_CTR2 toggles (one int every tick)
...
31: Assert after bit31 of WDT_CTR2 toggles (one int every 2^31 ticks)</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CTL</name>
            <description>Multi-Counter Watchdog Counter Control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xB0B0B</resetMask>
            <fields>
              <field>
                <name>WDT_ENABLE0</name>
                <description>Enable subcounter 0.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED0</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE0 by up to two LFCLK cycles.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET0</name>
                <description>Resets counter 0 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLE1</name>
                <description>Enable subcounter 1.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED1</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE1 by up to two LFCLK cycles.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET1</name>
                <description>Resets counter 1 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLE2</name>
                <description>Enable subcounter 2.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED2</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE2 by up to two LFCLK cycles.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET2</name>
                <description>Resets counter 2 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR</name>
            <description>Multi-Counter Watchdog Counter Interrupt Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>MCWDT Interrupt Request for sub-counter 0.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE0=3.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>MCWDT Interrupt Request for sub-counter 1.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE1=3.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>MCWDT Interrupt Request for sub-counter 2.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE2=3.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_SET</name>
            <description>Multi-Counter Watchdog Counter Interrupt Set Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Set interrupt for MCWDT_INT0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Set interrupt for MCWDT_INT1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Set interrupt for MCWDT_INT2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_MASK</name>
            <description>Multi-Counter Watchdog Counter Interrupt Mask Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Mask for sub-counter 0. This controls if the interrupt is forwarded to the CPU.
0: Interrupt is masked (not forwarded).
1: Interrupt is forwarded.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Mask for sub-counter 1. This controls if the interrupt is forwarded to the CPU.
0: Interrupt is masked (not forwarded).
1: Interrupt is forwarded.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Mask for sub-counter 2. This controls if the interrupt is forwarded to the CPU.
0: Interrupt is masked (not forwarded).
1: Interrupt is forwarded.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_MASKED</name>
            <description>Multi-Counter Watchdog Counter Interrupt Masked Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_LOCK</name>
            <description>Multi-Counter Watchdog Counter Lock Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC0000000</resetMask>
            <fields>
              <field>
                <name>MCWDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this MCWDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  Each MCWDT has a separate local lock.  LFCLK settings are locked by the global WDT_LOCK register, and this register has no effect on that.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_LOWER_LIMIT</name>
            <description>Multi-Counter Watchdog Counter Lower Limit Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_LOWER_LIMIT0</name>
                <description>Lower limit for sub-counter 0 of this MCWDT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_LOWER_LIMIT1</name>
                <description>Lower limit for sub-counter 1 of this MCWDT</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWRMODE</name>
      <description>SRSS Power Mode Control Registers</description>
      <baseAddress>0x42210000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>16</dimIncrement>
          <name>PD[%s]</name>
          <description>Power Domain Dependency Sense Register</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PD_SENSE</name>
            <description>Dependency Sense Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PD_ON</name>
                <description>Each bit &lt;i&gt; indicates whether PD&lt;j&gt; is directly kept on when PD&lt;i&gt; is on.  Indirect dependency is still possible if multiple direct dependencies work together to create a transitive relationship.  For example, if PD1 depends upon PD2; and PD2 dpends upon PD3; then PD1 indirectly depends upon PD3 regardless of whether there is a direct dependency from PD3 to PD1.  Some bits are implemented as constants, and some bits are implemented as user-configurable registers.  Refer to PD_SPT register to see how each bit is implemented.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PD_SPT</name>
            <description>Dependency Support Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PD_FORCE_ON</name>
                <description>Each bit &lt;i&gt; indicates whether PD&lt;j&gt; is always kept on when PD&lt;i&gt; is on for sense bits that are not configurable.  For configurable bits, this indicates the reset value of the configurable bit.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PD_CONFIG_ON</name>
                <description>Each bit &lt;i&gt; indicates whether PD&lt;j&gt; can be configured on when PD&lt;i&gt; is on.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>PPU_MAIN</name>
          <description>Power Policy Unit for Active Domain</description>
          <addressOffset>0x00001000</addressOffset>
          <cluster>
            <name>PPU</name>
            <description>Power Policy Unit Registers for the main power domain (VCCACT_PD)</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>PWPR</name>
              <description>Power Policy Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x108</resetValue>
              <resetMask>0x10F110F</resetMask>
              <fields>
                <field>
                  <name>PWR_POLICY</name>
                  <description>Power mode policy.  When static power mode transitions are enabled, PWR_DYN_EN is set to 0, this is the target power mode for the PPU.  When dynamic power mode transitions are enabled, PWR_DYN_EN is set to 1, this is the minimum power mode for the PPU.

This PPU supports the following modes: OFF(0), MEM_RET(2), FULL_RET(5), ON(8).  Do not use WARM_RST(9) or other unsupported modes.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWR_DYN_EN</name>
                  <description>Power mode dynamic transition enable.  For main PPU, keep this bit 1.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOCK_EN</name>
                  <description>N/A</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OP_POLICY</name>
                  <description>N/A</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OP_DYN_EN</name>
                  <description>N/A</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PMER</name>
              <description>Power Mode Emulation Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>EMU_EN</name>
                  <description>N/A</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PWSR</name>
              <description>Power Status Register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x10F110F</resetMask>
              <fields>
                <field>
                  <name>PWR_STATUS</name>
                  <description>Power mode status.  These bits reflect the current power mode of the PPU.  See PPU_PWPR.PWR_POLICY for power mode enumeration.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PWR_DYN_STATUS</name>
                  <description>Power mode dynamic transition status.  When set to 1 power mode dynamic transitions are enabled.  There might be a delay in dynamic transitions becoming active or inactive if the PPU is transitioning when PWR_DYN_EN is programmed.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LOCK_STATUS</name>
                  <description>N/A</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OP_STATUS</name>
                  <description>N/A</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OP_DYN_STATUS</name>
                  <description>N/A</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DISR</name>
              <description>Device Interface Input Current Status Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF0007FF</resetMask>
              <fields>
                <field>
                  <name>PWR_DEVACTIVE_STATUS</name>
                  <description>Status of the power mode DEVACTIVE inputs.

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 0 is for Q-channel device 0 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
                  <bitRange>[10:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OP_DEVACTIVE_STATUS</name>
                  <description>N/A</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MISR</name>
              <description>Miscellaneous Input Current Status Register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF01</resetMask>
              <fields>
                <field>
                  <name>PCSMPACCEPT_STATUS</name>
                  <description>The status of the PCSMPACCEPT input.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DEVACCEPT_STATUS</name>
                  <description>Status of the device interface DEVACCEPT inputs.

There is one bit for each device interface DEVQACCEPTn.  For example, bit 8 is for Q-Channel 0 DEVQACCEPTn and bit 9 for Q-Channel 1 DEVQACCEPTn.   Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DEVDENY_STATUS</name>
                  <description>Status of the device interface DEVDENY inputs.

There is one bit for each device interface DEVQDENY.  For example, bit 16 is for Q-Channel 0 DEVQDENY, and bit 17 for Q-Channel 1 DEVQDENY.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STSR</name>
              <description>Stored Status Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>STORED_DEVDENY</name>
                  <description>Status of the DEVDENY signals from the last device interface Q-Channel transition.  For Q-Channel:  There is one bit for each device interface DEVQDENY.  For example, bit 0 is for Q-Channel 0 DEVQDENY, and bit 1 for Q-Channel 1 DEVQDENY.  Refer to PPU_DISR.PWR_DEVACTIVE_STATUS for device enumeration.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>UNLK</name>
              <description>Unlock register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>UNLOCK</name>
                  <description>N/A</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PWCR</name>
              <description>Power Configuration Register</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x101</resetValue>
              <resetMask>0xFF07FFFF</resetMask>
              <fields>
                <field>
                  <name>DEVREQEN</name>
                  <description>When set to 1 enables the device interface handshake for transitions.  All available bits are reset to 1.

There is one bit for each device interface channel.  For example, bit 0 is for Q-Channel 0, and bit 1 is for Q-Channel 1.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWR_DEVACTIVEEN</name>
                  <description>These bits enable the power mode DEVACTIVE inputs.  When a bit is to 1 the related DEVACTIVE input is enabled, when set to 0 it is disabled.  All available bits are reset to 1.

There is one bit for each device interface Q-Channel DEVQACTIVE.  For example, bit 8 is for the Q-Channel 0 DEVQACTIVE, and bit 9 for the Q-Channel 1 DEVQACTIVE.  Refer to PPU_IDR0.DEVCHAN for device channel enumeration.</description>
                  <bitRange>[18:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OP_DEVACTIVEEN</name>
                  <description>N/A</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PTCR</name>
              <description>Power Mode Transition Configuration Register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>WARM_RST_DEVREQEN</name>
                  <description>Transition behavior between ON and WARM_RST.  This bit should not be modified when the PPU is in WARM_RST, or if the PPU is performing a transition, otherwise PPU behavior is UNPREDICTABLE.
0:  The PPU does not perform a device interface handshake when transitioning between ON and WARM_RST.
1:  The PPU performs a device interface handshake when transitioning between ON and WARM_RST.  This disables all Q-Channels for this transition.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBG_RECOV_PORST_EN</name>
                  <description>N/A</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IMR</name>
              <description>Interrupt Mask Register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x2</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>STA_POLICY_TRN_IRQ_MASK</name>
                  <description>Static full policy transition completion event mask.  For main PPU, this bit has no function because no static transitions are supported (see PWPR.PWR_DYN_EN).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_ACCEPT_IRQ_MASK</name>
                  <description>Static transition acceptance event mask.  For main PPU, keep this bit 1 to mask the event, otherwise the interrupt may trigger a wakeup.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_DENY_IRQ_MASK</name>
                  <description>Static transition denial event mask.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EMU_ACCEPT_IRQ_MASK</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EMU_DENY_IRQ_MASK</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOCKED_IRQ_MASK</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>AIMR</name>
              <description>Additional Interrupt Mask Register</description>
              <addressOffset>0x34</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>UNSPT_POLICY_IRQ_MASK</name>
                  <description>Unsupported Policy event mask.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DYN_ACCEPT_IRQ_MASK</name>
                  <description>Dynamic transition acceptance event mask.  For main PPU, keep this bit 1 to mask the event, otherwise the interrupt that occurs when entering a low power mode may trigger a wakeup.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DYN_DENY_IRQ_MASK</name>
                  <description>Dynamic transition denial event mask.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_POLICY_PWR_IRQ_MASK</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_POLICY_OP_IRQ_MASK</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ISR</name>
              <description>Interrupt Status Register</description>
              <addressOffset>0x38</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF07FFBF</resetMask>
              <fields>
                <field>
                  <name>STA_POLICY_TRN_IRQ</name>
                  <description>Static full policy transition completion event status.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_ACCEPT_IRQ</name>
                  <description>Static transition acceptance event status.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_DENY_IRQ</name>
                  <description>Static transition denial event status.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EMU_ACCEPT_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EMU_DENY_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOCKED_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OTHER_IRQ</name>
                  <description>Indicates there is an interrupt event pending in the Additional Interrupt Status Register (PPU_AISR).</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PWR_ACTIVE_EDGE_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[18:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>OP_ACTIVE_EDGE_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>AISR</name>
              <description>Additional Interrupt Status Register</description>
              <addressOffset>0x3C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>UNSPT_POLICY_IRQ</name>
                  <description>Unsupported Policy event status.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DYN_ACCEPT_IRQ</name>
                  <description>Dynamic transition acceptance event status.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DYN_DENY_IRQ</name>
                  <description>Dynamic transition denial event status.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_POLICY_PWR_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STA_POLICY_OP_IRQ</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IESR</name>
              <description>Input Edge Sensitivity Register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFF</resetMask>
              <fields>
                <field>
                  <name>DEVACTIVE00_EDGE</name>
                  <description>DEVACTIVE 0 edge sensitivity.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE01_EDGE</name>
                  <description>DEVACTIVE 1 edge sensitivity.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE02_EDGE</name>
                  <description>DEVACTIVE 2 edge sensitivity.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE03_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE04_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE05_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE06_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE07_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[15:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE08_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE09_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[19:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE10_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[21:20]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>OPSR</name>
              <description>Operating Mode Active Edge Sensitivity Register</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>DEVACTIVE16_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE17_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE18_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE19_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE20_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE21_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE22_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEVACTIVE23_EDGE</name>
                  <description>N/A</description>
                  <bitRange>[15:14]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>FUNRR</name>
              <description>Functional Retention RAM Configuration Register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>FUNC_RET_RAM_CFG</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>FULRR</name>
              <description>Full Retention RAM Configuration Register</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>FULL_RET_RAM_CFG</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MEMRR</name>
              <description>Memory Retention RAM Configuration Register</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>MEM_RET_RAM_CFG</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>EDTR0</name>
              <description>Power Mode Entry Delay Register 0</description>
              <addressOffset>0x160</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>OFF_DEL</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MEM_RET_DEL</name>
                  <description>N/A</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LOGIC_RET_DEL</name>
                  <description>N/A</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FULL_RET_DEL</name>
                  <description>N/A</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>EDTR1</name>
              <description>Power Mode Entry Delay Register 1</description>
              <addressOffset>0x164</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>MEM_OFF_DEL</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FUNC_RET_DEL</name>
                  <description>N/A</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DCDR0</name>
              <description>Device Control Delay Configuration Register 0</description>
              <addressOffset>0x170</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CLKEN_RST_DLY</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ISO_CLKEN_DLY</name>
                  <description>N/A</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RST_HWSTAT_DLY</name>
                  <description>N/A</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DCDR1</name>
              <description>Device Control Delay Configuration Register 1</description>
              <addressOffset>0x174</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>ISO_RST_DLY</name>
                  <description>N/A</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CLKEN_ISO_DLY</name>
                  <description>N/A</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IDR0</name>
              <description>PPU Identification Register 0</description>
              <addressOffset>0xFB0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x14534501</resetValue>
              <resetMask>0x3FF7FFFF</resetMask>
              <fields>
                <field>
                  <name>DEVCHAN</name>
                  <description>No. of Device Interface Channels.
0: This is a P-Channel PPU.  Refer to PPU_IDR1.OP_ACTIVE for the number of DEVPACTIVE inputs and their meaning.
non-zero: The value is the number of Q-Channels.

The device enumeration is:
Device 0: PDCM</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>NUM_OPMODE</name>
                  <description>No. of operating modes supported is NUM_OPMODE + 1.</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_OFF_SPT</name>
                  <description>OFF support.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_OFF_EMU_SPT</name>
                  <description>OFF_EMU support.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_MEM_RET_SPT</name>
                  <description>MEM_RET support.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_MEM_RET_EMU_SPT</name>
                  <description>MEM_RET_EMU support.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_LGC_RET_SPT</name>
                  <description>LOGIC_RET support.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_MEM_OFF_SPT</name>
                  <description>MEM_OFF support.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_FULL_RET_SPT</name>
                  <description>FULL_RET support.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_FUNC_RET_SPT</name>
                  <description>FUNC_RET support.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_ON_SPT</name>
                  <description>ON support.</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_WRM_RST_SPT</name>
                  <description>WARM_RST support.  Ignore this bit.  Do not use WARM_RST.</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_DBG_RECOV_SPT</name>
                  <description>DBG_RECOV support.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_OFF_SPT</name>
                  <description>Dynamic OFF support.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_OFF_EMU_SPT</name>
                  <description>Dynamic OFF_EMU support.</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_MEM_RET_SPT</name>
                  <description>Dynamic MEM_RET support.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_MEM_RET_EMU_SPT</name>
                  <description>Dynamic MEM_RET_EMU support</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_LGC_RET_SPT</name>
                  <description>Dynamic LOGIC_RET support.</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_MEM_OFF_SPT</name>
                  <description>Dynamic MEM_OFF support.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_FULL_RET_SPT</name>
                  <description>Dynamic FULL_RET support.</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_FUNC_RET_SPT</name>
                  <description>Dynamic FUNC_RET support.</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_ON_SPT</name>
                  <description>Dynamic ON support.</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DYN_WRM_RST_SPT</name>
                  <description>Dynamic WARM_RST support.</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IDR1</name>
              <description>PPU Identification Register 1</description>
              <addressOffset>0xFB4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1777</resetMask>
              <fields>
                <field>
                  <name>PWR_MODE_ENTRY_DEL_SPT</name>
                  <description>Power mode entry delay support.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SW_DEV_DEL_SPT</name>
                  <description>Software device delay control configuration support.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LOCK_SPT</name>
                  <description>Lock and the lock interrupt event are supported.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MEM_RET_RAM_REG</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FULL_RET_RAM_REG</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FUNC_RET_RAM_REG</name>
                  <description>N/A</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_POLICY_PWR_IRQ_SPT</name>
                  <description>Power policy transition completion event status.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STA_POLICY_OP_IRQ_SPT</name>
                  <description>Operating policy transition completion event status.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OP_ACTIVE</name>
                  <description>N/A</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>OFF_MEM_RET_TRANS</name>
                  <description>OFF to MEM_RET direct transition.  Indicates if direct transitions from OFF to MEM_RET and from OFF_EMU to MEM_RET_EMU are supported.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IIDR</name>
              <description>Implementation Identification Register</description>
              <addressOffset>0xFC8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0xB50043B</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>IMPLEMENTER</name>
                  <description>Implementer identification.  [11:8] The JEP106 continuation code of the implementer.  [7] Always 0.  [6:0] The JEP106 identity code of the implementer.  For an Arm implementation, bits [11:0] are 0x43B.</description>
                  <bitRange>[11:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REVISION</name>
                  <description>Minor revision of the product.</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>VARIANT</name>
                  <description>Major revision of the product.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PRODUCT_ID</name>
                  <description>PPU part identification.</description>
                  <bitRange>[31:20]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>AIDR</name>
              <description>Architecture Identification Register</description>
              <addressOffset>0xFCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x11</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>ARCH_REV_MINOR</name>
                  <description>N/A</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ARCH_REV_MAJOR</name>
                  <description>N/A</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock Selection for Power Mode Components</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>CLK_PWR_DIV</name>
              <description>clk_pwr is generated by dividing the CLK_PWR_MUX selection by (CLK_PWR_DIV+1).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PWR_MUX</name>
              <description>Selects a source for the clock used by power control components.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IHO</name>
                  <description>IHO - Internal High-speed Oscillator</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BACKUP</name>
      <description>SRSS Backup Registers</description>
      <baseAddress>0x42220000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0F3708</resetMask>
          <fields>
            <field>
              <name>WCO_EN</name>
              <description>Watch-crystal oscillator (WCO) enable.  If there is a write in progress when this bit is cleared, the WCO will be internally kept on until the write completes.
After enabling the WCO software must wait until STATUS.WCO_OK=1 before configuring any component that depends on clk_lf/clk_bak, like for example RTC or WDTs.  Follow the procedure in BACKUP_RTC_RW to access this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Clock select for RTC clock</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-crystal oscillator input, available in Active, DeepSleep, Hibernate, and XRES.  For products with an independent vbackup supply, it can continue operating in OFF w/Backup mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTBAK</name>
                  <description>This allows to use the LFCLK selection as an alternate backup domain clock. Note that LFCLK is only available in Active and DeepSleep power modes.
Note that LFCLK clock glitches can propagate into the backup logic when the clock is stopped.  For this reason, if the WCO or ILO is intended as the clock source then choose it directly instead of routing through LFCLK.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low frequency Oscillator, available in Active, DeepSleep, Hibernate, and XRES.  For products with an independent vbackup supply, it can continue operating in OFF w/Backup mode.
For Hibernate operation CLK_ILO0_CONFIG. ILO_BACKUP must be set.  If there are multiple ILO, this is ILO0.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO_PRESCALER</name>
                  <description>Low-power external crystal oscillator prescaler output, available in Active, DeepSleep, Hibernate, and XRES.  For products with an independent vbackup supply, it can continue operating in OFF w/Backup mode.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision internal low-speed oscillator, available in Active, DeepSleep, Hibernate, and XRES.  For products with an independent vbackup supply, it can continue operating in OFF w/Backup mode.</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRESCALER</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WCO_BYPASS</name>
              <description>Configures the WCO for different board-level connections to the WCO pins.  For example, this can be used to connect an external watch crystal oscillator instead of a watch crystal.   In all cases, the two related GPIO pins (WCO input and output pins) must be configured as analog connections using GPIO registers, and they must be hooked at the board level as described below.  Configure this field before enabling the WCO, and do not change this setting when WCO_EN=1.
0: Watch crystal.  Connect a 32.768 kHz watch crystal between WCO input and output pins.
1: Clock signal, either a square wave or sine wave.  See PRESCALER field for connection information.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDBAK_CTL</name>
              <description>Controls the behavior of the switch that generates vddbak from vbackup or vddd.
0: automatically select vddd if its brownout detector says it is valid.  If the brownout says its not valid, then use vmax which is the highest of vddd or vbackup.
1,2,3: force vddbak and vmax to select vbackup, regardless of its voltage.</description>
              <bitRange>[18:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBACKUP_MEAS</name>
              <description>Connect vbackup supply to the vbackup_meas output for measurement by an ADC attached to amuxbusa_adft_vddd.  The vbackup_meas signal is scaled to 10 percent of vbackup, so it is within the supply range of the ADC.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CHARGE_KEY</name>
              <description>When set to 3C, the supercap charger circuit is enabled.  Any other code disables the supercap charger.  THIS CHARGING CIRCUIT IS FOR A SUPERCAP ONLY AND CANNOT SAFELY CHARGE A BATTERY.  DO NOT WRITE THIS KEY WHEN VBACKUP IS CONNECTED TO A BATTERY. Enabling this supercap charger with a depleted supercap can cause a temporary IR drop on the power rail supplying the logic in the backup domain.  During cold boot, FW can determine that this condition could exist by seeing that any backup domain register has been reset. The charging time is 2.2*R*C, where R=100Kohm. So for a 100uF supercap, FW should wait for the charging time of 22seconds before issuing BACKUP.RESET and then enabling the WCO/PILO/ILO clock source and expecting data in BREGs to be retained.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_RW</name>
          <description>RTC Read Write register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>READ</name>
              <description>Read bit
When this bit is set the RTC registers will be copied to user registers and frozen so that a coherent RTC value can safely be read. The RTC will keep on running.
Do not set the read bit if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Write bit is set. Do not set the Read bit at the same time that the Write bit is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE</name>
              <description>Write bit
Only when this bit is set can the RTC registers be written to (otherwise writes are ignored). This bit cannot be set if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Read bit is set or getting set.
The user writes to the RTC user registers, when the Write bit is cleared by the user then the user registers content is copied to the actual RTC registers.
Only user RTC registers that were written to will get copied, others will not be affected.
When the SECONDS field is updated then TICKS will also be reset (WDT is not affected).
When the Write bit is cleared by a reset (brown out/DeepSleep) then the RTC update will be ignored/lost.
Do not set the Write bit if the RTC if the RTC is still busy with a previous update (see RTC_BUSY).  Do not set the Write bit at the same time that the Read bit is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_CTL</name>
          <description>Oscillator calibration for absolute frequency</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xB003007F</resetMask>
          <fields>
            <field>
              <name>CALIB_VAL</name>
              <description>Calibration value for absolute frequency (at a fixed temperature).  Each step causes 128 ticks to be added or removed each hour.  Effectively that means that each step is 1.085ppm (= 128/(60*60*32,768)) when CAL_COMP_PER_MIN is set at default value.
Positive values 0x01-0x3c (1..60) add pulses, negative values remove pulses, thus giving a range of +/-65.1 ppm (limited by 60 minutes per hour, not the range of this field) when CAL_COMP_PER_MIN is set at default value .

Calibration is performed hourly, starting at 59 minutes and 59 seconds, and applied as 64 ticks every 30 seconds until there have been 2*CALIB_VAL adjustments when CAL_COMP_PER_MIN is set at default value .</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CALIB_SIGN</name>
              <description>Calibration sign:
0= Negative sign: remove pulses (it takes more clock ticks to count one second)
1= Positive sign: add pulses (it takes less clock ticks to count one second)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_COMP_PER_MIN</name>
              <description>Select how many time calibration is performed per minute  per step of 64 , each time a 64 step is added or substracted one unit 2/4/8/16*CALIB_VAL is substracted.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>2</name>
                  <description>Calibration of 64 each is performed twice per minute for 2*CALIB_VAL per hour</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4</name>
                  <description>Calibration of 64 each is performed four times per minute for 4*CALIB_VAL per hour</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8</name>
                  <description>Calibration of 64 each is performed eight  times per minute for 8*CALIB_VAL per hour</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>16</name>
                  <description>Calibration of 64 each is performed sixteen times per minute for 16*CALIB_VAL per hour</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAL_SEL</name>
              <description>Select calibration wave output signal</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAL512</name>
                  <description>512Hz wave, not affected by calibration setting (not supported for 50/60Hz input clock: CTL.PRESCALER!=0)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAL2</name>
                  <description>2Hz wave, includes the effect of the calibration setting, (not supported for 50/60Hz input clock: CTL.PRESCALER!=0)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAL1</name>
                  <description>1Hz wave, includes the effect of the calibration setting (supported for all input clocks)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAL_OUT</name>
              <description>Output enable for wave signal for calibration and allow CALIB_VAL to be written.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x5</resetMask>
          <fields>
            <field>
              <name>RTC_BUSY</name>
              <description>Pending RTC write</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WCO_OK</name>
              <description>Obsolete.  Use WCO_STATUS.WCO_OK for future designs.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TIME</name>
          <description>Calendar Seconds, Minutes, Hours, Day of Week</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x75F3F3F</resetMask>
          <fields>
            <field>
              <name>RTC_SEC</name>
              <description>Calendar seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MIN</name>
              <description>Calendar minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_HOUR</name>
              <description>Calendar hours, value depending on 12/24HR mode
0=24HR: [20:16]=0-23
1=12HR: [20]:0=AM, 1=PM, [19:16]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL_12HR</name>
              <description>Select 12/24HR mode: 1=12HR, 0=24HR</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_DAY</name>
              <description>Calendar Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DATE</name>
          <description>Calendar Day of Month, Month,  Year</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x7F0F1F</resetMask>
          <fields>
            <field>
              <name>RTC_DATE</name>
              <description>Calendar Day of the Month, 1-31
Automatic Leap Year Correction</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MON</name>
              <description>Calendar Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_YEAR</name>
              <description>Calendar year, 0-99</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_TIME</name>
          <description>Alarm 1 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x879FBFBF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours, value depending on 12/24HR mode
24HR: [4:0]=0-23
12HR: [4]:0=AM, 1=PM, [3:0]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_DATE</name>
          <description>Alarm 1 Day of Month, Month</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80008F9F</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month, 1-31
Leap Year corrected</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 1.
0: Alarm 1 is disabled.  Fields for date and time are ignored.
1: Alarm 1 is enabled.  Alarm triggers whenever the new date and time matches all the enabled date and time fields, which can happen more than once depending on configuration.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_TIME</name>
          <description>Alarm 2 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x879FBFBF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours, value depending on 12/24HR mode
24HR: [4:0]=0-23
12HR: [4]:0=AM, 1=PM, [3:0]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_DATE</name>
          <description>Alarm 2 Day of Month, Month</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80008F9F</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month, 1-31
Leap Year corrected</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 2.
0: Alarm 2 is disabled.  Fields for date and time are ignored.
1: Alarm 2 is enabled.  Alarm triggers whenever the new date and time matches all the enabled date and time fields, which can happen more than once depending on configuration.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Alarm 1 Interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Alarm 2 Interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Century overflow interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_CTL</name>
          <description>PMIC control register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0010000</resetValue>
          <resetMask>0xE001FF00</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for PMIC to be disabled.  When the UNLOCK code is not present: writes to PMIC_EN field are ignored and the hardware ignores the value in PMIC_EN.  Do not change PMIC_EN in the same write cycle as setting/clearing the UNLOCK code; do these in separate write cycles.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN_OUTEN</name>
              <description>Output enable for the output driver in the PMIC_EN pad.
0: Output pad is tristate for PMIC_EN pin.  This can allow this pin to be used for another purpose. Tristate condition is kept only if the UNLOCK key (0x3A) is present
1: Output pad is enabled for PMIC_EN pin.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_ALWAYSEN</name>
              <description>Override normal PMIC controls to prevent accidentally turning off the PMIC by errant firmware.
0: Normal operation, PMIC_EN and PMIC_OUTEN work as described
1: PMIC_EN and PMIC_OUTEN are ignored and the output pad is forced enabled.
Note: This bit is a write-once bit until the next backup reset.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN</name>
              <description>Enable for external PMIC that supplies vddd (if present).  This bit will only clear if UNLOCK was written correctly in a previous write operation and PMIC_ALWAYSEN=0.  When PMIC_EN=0, the system functions normally until vddd is no longer present (OFF w/Backup mode).  Firmware can set this bit, if it does so before vddd is actually removed.  This bit is also set by any RTC alarm or PMIC pin wakeup event regardless of UNLOCK setting.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET</name>
          <description>Backup reset register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Writing 1 to this register resets the backup logic.  Hardware clears it when the reset is complete.  After setting this register, firmware should confirm it reads as 0 before attempting to write other backup registers.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WCO_STATUS</name>
          <description>WCO Status Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x4</resetMask>
          <fields>
            <field>
              <name>WCO_OK</name>
              <description>Indicates that output has transitioned.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG_SET0[%s]</name>
          <description>Backup register region 0</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG_SET1[%s]</name>
          <description>Backup register region 1</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG_SET2[%s]</name>
          <description>Backup register region 2</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>48</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG_SET3[%s]</name>
          <description>Backup register region 3</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRYPTOLITE</name>
      <description>N/A</description>
      <baseAddress>0x42230000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF00</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes any (including possible memory holes in the IP aperture) of the CRYPTO component registers; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All CRYPTO component master transactions use the P field for the user/privileged access control ('hprot[1]').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes  any (including possible memory holes in the IP aperture) of the CRYPTO component registers; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All CRYPTO component master transactions use the NS field for the secure/non-secure access control ('hprot[4]').</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>Protection context.

This field is set with the protection context of the transaction that writes any (including possible memory holes in the IP aperture) of the CRYPTO component registers; i.e. the context is inherited from the write transaction and not specified by the transaction write data.

All CRYPTO component master transactions use the PC field for the protection context.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>Master identifier of the cryptography IP. This is a design time configurable parameter.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Busy indication:
'0': IP not busy.
'1': IP busy (AES, SHA or VU functionality (TRNG functionality NOT included)).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_DESCR</name>
          <description>AES descriptor pointer</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>PTR</name>
              <description>AES descriptor pointer. The descriptor points to a structure with 32-bit words:
Word 0: Pointer to a 128-bit AES key.
Word 1: Pointer to a 128-bit source/plaintext.
Word 2: Pointer to a 128-bit destination/ciphertext.

A write to this register automatically starts a 128-bit AES encryption in ECB mode. The write ONLY takes effect when the IP is NOT busy (STATUS.BUSY is '0'). The write will be made pending/blocked as long as the IP is busy.

Note: the pointers must be 4B aligned.

Note: HW updates this field when the AES engine is busy.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_DESCR</name>
          <description>VU descriptor pointer</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>PTR</name>
              <description>VU descriptor pointer. The descriptor points to a structure with 32-bit words:
Word 0: Control word. Specifies operand size in 32-bit word multiples.
- WORD[7:0]: Source operand 0 32-bit words (minus 1).
- WORD[15:8]: Source operand 1 32-bit words (minus 1).
- WORD[24:16]: Destination operand 32-bit words (minus 1).
- WORD[31:28]: Opcode. '0': multiplication (MUL), '1': addition (ADD), '2': subtraction (SUB), '3': exclusive or (XOR), '4': binary multiplication (XMUL), '5': logical shift right by 1 (LSR1), '6': logical shift left by 1 (LSL1), '7': logical shift right (LSR), '8': conditional syubtraction (COND_SUB). '9': move (MOV).
Word 1: Pointer to source 0.
Word 2: Pointer to source 1.
Word 3: Pointer to destination.

A write to this register automatically starts a VU operation. The write ONLY takes effect when the IP is NOT busy (STATUS.BUSY is '0'). The write will be made pending/blocked as long as the IP is busy.

Note: the pointers must be 4B aligned.

Note: HW updates this field when the VU engine is busy.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SHA_DESCR</name>
          <description>SHA descriptor pointer</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>PTR</name>
              <description>SHA-256 descriptor pointer. The descriptor points to a structure with 32-bit words:
For message schedule function:
Word 0: Control word.
- WORD0[28]: '0' for message schedule function.
Word 1: Pointer to 512 b message chunk (input).
Word 2: Pointer to 64 * 32 b word message schedule array (output).
For process function:
Word 0: Control word.
- WORD0[28]: '1' for process function.
Word 1: Pointer to 8 * 32 b word current hash value (input) and new hash value (output).
Word 2: Pointer to 64 * 32 b word message schedule array (input).

A write to this register automatically starts a SHA-256 operation. The write ONLY takes effect when the IP is NOT busy (STATUS.BUSY is '0'). The write will be made pending/blocked as long as the IP is busy.

Note: the pointers must be 32-bit word aligned.

Note: HW updates this field when the SHA-256 engine is busy.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_ERROR</name>
          <description>Error interrupt</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BUS_ERROR</name>
              <description>AHB-Lite master interface bus error or ECC error. Note that the IP terminates its AES, SHA or VU functionality when it detects an error.

Note: The error is sticky. This allows SW to check for an error after a series of operations, rather than checking after every individual operation.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_ERROR_SET</name>
          <description>Error interrupt set</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BUS_ERROR</name>
              <description>Write this field with '1' to set corresponding INTR_ERROR field to '1' (a write of '0' has no effect).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_ERROR_MASK</name>
          <description>Error interrupt mask</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BUS_ERROR</name>
              <description>Mask for corresponding field in INTR_ERROR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_ERROR_MASKED</name>
          <description>Error interrupt masked</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BUS_ERROR</name>
              <description>Logical and of corresponding INTR_ERROR and INTR_ERROR_MASK fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_CTL0</name>
          <description>TRNG control 0</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x33030000</resetValue>
          <resetMask>0x33FFFFFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_CLOCK_DIV</name>
              <description>Specifies the clock divider that is used to sample oscillator data. This clock divider is wrt. The IP clock.
'0': sample clock is the IP clock.
'1': sample clock is the IP clock divided by 2.
...
'255': sample clock is the IP clock divided by 256.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RED_CLOCK_DIV</name>
              <description>Specifies the clock divider that is used to produce reduced bits.
'0': 1 reduced bit is produced for each sample.
'1': 1 reduced bit is produced for each 2 samples.
...
'255': 1 reduced bit is produced for each 256 samples.

The reduced bits are considered random bits and shifted into TRNG_RESULT.DATA.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_DELAY</name>
              <description>Specifies an initialization delay: number of removed/dropped samples before reduced bits are generated. This field should be programmed in the range [1, 255]. After starting the oscillators, at least the first 2 samples should be removed/dropped to clear the state of internal synchronizers. In addition, it is advised to drop at least the second 2 samples from the oscillators (to circumvent the semi-predictable oscillator startup behavior). This result in the default field value of '3'. Field encoding is as follows:
'0': 1 sample is dropped.
'1': 2 samples are dropped.
...
'255': 256 samples are dropped.

The INTR.INITIALIZED interrupt cause is set to '1', when the initialization delay is passed.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VON_NEUMANN_CORR</name>
              <description>Specifies if the 'von Neumann corrector' is disabled or enabled:
'0': disabled.
'1': enabled.
The 'von Neumann corrector' post-processes the reduced bits to remove a '0' or '1' bias. The corrector operates on reduced bit pairs ('oldest bit, newest bit'):
'00': no bit is produced.
'01': '0' bit is produced (oldest bit).
'10': '1' bit is produced (oldest bit).
'11': no bit is produced.
Note that the corrector produces bits at a random pace and at a frequency that is 1/4 of the reduced bit frequency (reduced bits are processed in pairs, and half of the pairs do NOT produce a bit).</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FEEDBACK_EN</name>
              <description>Specifies if the feedback of the reducution state is enabled:
'0': Disabled.
'1': Enabled.

Note: This field is added in the 'mxcryptolite' IP to address CDT#337111, in which it was observed that the reduction state feedback reduces  the effectiveness of the 'von Neumann corrector'. The default value is '1' to provide backward compatibility.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_ON_AP_DETECT</name>
              <description>Specifies if TRNG functionality is stopped on an adaptive proportion test detection (when HW sets INTR_ERROR.TRNG_AP_DETECT to '1'):
'0': Functionality is NOT stopped.
'1': Functionality is stopped (TRNG_CTL1 fields are set to '0' by HW). The DAS bitstream is set to '0'.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_ON_RC_DETECT</name>
              <description>Specifies if TRNG functionality is stopped on a repetition count test detection (when HW sets INTR_ERROR.TRNG_RC_DETECT to '1'):
'0': Functionality is NOT stopped.
'1': Functionality is stopped (TRNG_CTL1 fields are set to '0' by HW). The DAS bitstream is set to '0'.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_CTL1</name>
          <description>TRNG control 1</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>RO11_EN</name>
              <description>FW sets this field to '1' to enable the ring oscillator with 11 inverters.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RO15_EN</name>
              <description>FW sets this field to '1' to enable the ring oscillator with 15 inverters.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GARO15_EN</name>
              <description>FW sets this field to '1' to enable the fixed Galois ring oscillator with 15 inverters.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GARO31_EN</name>
              <description>FW sets this field to '1' to enable the programmable Galois ring oscillator with up to 31 inverters. The TRNG_GARO_CTL register specifies the programmable polynomial.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIRO15_EN</name>
              <description>FW sets this field to '1' to enable the fixed Fibonacci ring oscillator with 15 inverters.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIRO31_EN</name>
              <description>FW sets this field to '1' to enable the programmable Fibonacci ring oscillator with up to 31 inverters. The TRNG_FIRO_CTL register specifies the programmable polynomial.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_STATUS</name>
          <description>TRNG status</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INITIALIZED</name>
              <description>Reflects the state of the true random number generator:
'0': Not initialized (TRNG_CTL0.INIT_DELAY has NOT passed).
'1': Initialized (TRNG_CTL0.INIT_DELAY has passed).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_RESULT</name>
          <description>TRNG result</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Generated 32-bit true random number. The INTR.DATA_AVAILABLE interrupt cause is activated when the number is generated.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_GARO_CTL</name>
          <description>TRNG GARO control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x21F81910</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>Polynomial for programmable Galois ring oscillator. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned such that the more significant bits (bit 30 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's.

Note: Default value per GESC#113.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_FIRO_CTL</name>
          <description>TRNG FIRO control</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x696F0221</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>Polynomial for programmable Fibonacci ring oscillator. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned such that the more significant bits (bit 30 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's.

Note: Default value per GESC#113.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_MON_CTL</name>
          <description>TRNG monitor control</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x303</resetMask>
          <fields>
            <field>
              <name>BITSTREAM_SEL</name>
              <description>Selection of the bitstream:
'0': DAS bitstream.
'1': RED bitstream.
'2': TR bitstream.
'3': Undefined.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AP</name>
              <description>Adaptive proportion (AP) test enable:
'0': Disabled.
'1': Enabled.

On a AP detection, HW sets this field to '0' and sets INTR_ERROR.TRNG_AP_DETECT to '1.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RC</name>
              <description>Repetition count (RC) test enable:
'0': Disabled.
'1': Enabled.

On a RC detection, HW sets this field to '0' and sets INTR_ERROR.TRNG_RC_DETECT to '1.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_MON_RC_CTL</name>
          <description>TRNG monitor RC control</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CUTOFF_COUNT8</name>
              <description>Cutoff count (legal range is [1, 255]):
'0': Illegal.
'1': 1 repetition.
...
'255': 255 repetitions.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_MON_RC_STATUS0</name>
          <description>TRNG monitor RC status 0</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BIT</name>
              <description>Current active bit value:
'0': '0'.
'1': '1'.

This field is only valid when TRNG_MON_RC_STATUS1.REP_COUNT is NOT equal to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_MON_RC_STATUS1</name>
          <description>TRNG monitor RC status 1</description>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>REP_COUNT</name>
              <description>Number of repetitions of the current active bit counter:
'0': 0 repetitions.
...
'255': 255 repetitions.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_MON_AP_CTL</name>
          <description>TRNG monitor AP control</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CUTOFF_COUNT16</name>
              <description>Cutoff count (legal range is [1, 65535]).
'0': Illegal.
'1': 1 occurrence.
...
'65535': 65535 occurrences.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WINDOW_SIZE</name>
              <description>Window size (minus 1) :
'0': 1 bit.
...
'65535': 65536 bits.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_MON_AP_STATUS0</name>
          <description>TRNG monitor AP status 0</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BIT</name>
              <description>Current active bit value:
'0': '0'.
'1': '1'.

This field is only valid when TRNG_MON_AP_STATUS1.OCC_COUNT is NOT equal to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRNG_MON_AP_STATUS1</name>
          <description>TRNG monitor AP status 1</description>
          <addressOffset>0x16C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OCC_COUNT</name>
              <description>Number of occurrences of the current active bit counter:
'0': 0 occurrences
...
'65535': 65535 occurrences</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WINDOW_INDEX</name>
              <description>Counter to keep track of the current index in the window (counts from '0' to TRNG_MON_AP_CTL.WINDOW_SIZE to '0').</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TRNG</name>
          <description>TRNG interrupt</description>
          <addressOffset>0x1F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>INITIALIZED</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the TRNG is initialized.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_AVAILABLE</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when 32 bits of TRNG data becomes available in TRNG_RESULT.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AP_DETECT</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the TRNG monitor detects an 'adaptive proportion' error.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RC_DETECT</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the TRNG monitor detects an 'repetition count' error.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TRNG_SET</name>
          <description>TRNG Interrupt set</description>
          <addressOffset>0x1F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>INITIALIZED</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_AVAILABLE</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AP_DETECT</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RC_DETECT</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TRNG_MASK</name>
          <description>TRNG Interrupt mask</description>
          <addressOffset>0x1F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>INITIALIZED</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_AVAILABLE</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AP_DETECT</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RC_DETECT</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TRNG_MASKED</name>
          <description>TRNG Interrupt masked</description>
          <addressOffset>0x1FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>INITIALIZED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_AVAILABLE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>AP_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RC_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MXCORDIC_1_0</name>
      <description>N/A</description>
      <baseAddress>0x42240000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>N/A</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Enables/Disables IP</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID</name>
          <description>Module Identification Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xDCB2C001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MOD_REV</name>
              <description>Module Revision Number - MOD_REV</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MOD_TYPE</name>
              <description>Module Type - MOD_TYPE</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MOD_NUMBER</name>
              <description>Module Number Value - MOD_NUMBER</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt Cause Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC</resetMask>
          <fields>
            <field>
              <name>CDEOC</name>
              <description>CORDIC End of Calculation Event Flag - CDEOC</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CDERR</name>
              <description>CORDIC Error Event Flag - CDERR</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt Set Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC</resetMask>
          <fields>
            <field>
              <name>CDEOC</name>
              <description>CORDIC Event Flag Set - CDEOC</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CDERR</name>
              <description>CORDIC Error Event Flag Set - CDERR</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC</resetMask>
          <fields>
            <field>
              <name>CDEOC</name>
              <description>CORDIC End of Calculation Interrupt Mask- CDEOC</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CDERR</name>
              <description>CORDIC Error Interrupt Mask - CDERR</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt Masked Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC</resetMask>
          <fields>
            <field>
              <name>CDEOC</name>
              <description>CORDIC End of Calculation Interrupt Masked- CDEOC</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CDERR</name>
              <description>CORDIC Error Interrupt Masked - CDERR</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KEEP</name>
          <description>CORDIC Keep Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0</resetMask>
          <fields>
            <field>
              <name>KEEPX</name>
              <description>Last X Result as Initial Data for New Calculation - KEEPX</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KEEPY</name>
              <description>Last Y Result as Initial Data for New Calculation - KEEPY</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KEEPZ</name>
              <description>Last Z Result as Initial Data for New Calculation - KEEPZ</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CON</name>
          <description>CORDIC Control Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x62</resetValue>
          <resetMask>0x7FE</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>Operating Mode - MODE</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LINEAR</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CIRCULAR</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HYPERBOLIC</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROTVEC</name>
              <description>Rotation Vectoring Selection - ROTVEC</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VECTORING</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ROTATION</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ST_MODE</name>
              <description>Start Method - ST_MODE</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Operation starts with write into CORDZ register</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ST</name>
                  <description>Operation starts with write into START_CMD register</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>X_USIGN</name>
              <description>Result Data Format for X in Circular Vectoring Mode - X_USIGN</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MPS</name>
              <description>X and Y Magnitude Prescaler - MPS</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIVIDE_BY_1</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIVIDE_BY_2</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIVIDE_BY_4</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NO_CHANGE</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>N_ITER</name>
              <description>Number of CORDIC iterations divided by 4</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>N_ITER_4</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>N_ITER_8</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>N_ITER_12</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>N_ITER_16</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>N_ITER_20</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>N_ITER_24</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>N_ITER_28</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CORDX</name>
          <description>CORDIC X Data Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Initial X Parameter Data - DATA</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CORDY</name>
          <description>CORDIC Y Data Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Initial Y Parameter Data - DATA</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CORDZ</name>
          <description>CORDIC Z Data Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Initial Z Parameter Data - DATA</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CORRX</name>
          <description>CORDIC X Result Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>X Calculation Result - RESULT</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CORRY</name>
          <description>CORDIC Y Result Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>Y Calculation Result - RESULT</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CORRZ</name>
          <description>CORDIC Z Result Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>Z Calculation Result - RESULT</description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <description>CORDIC Status Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BSY</name>
              <description>Busy Indication - BSY</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>START_CMD</name>
          <description>CORDIC Start Command Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ST</name>
              <description>Start Calculation Set - ST</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DEBUG600</name>
      <description>N/A</description>
      <baseAddress>0x42250000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>VERSION</name>
          <description>IP Version Information</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>MINOR</name>
              <description>IP Minor Revision Number</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJOR</name>
              <description>IP Major Revision Number</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>IO Matrix (IOM)</description>
      <baseAddress>0x42400000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>10</dim>
          <dimIncrement>16</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL0</name>
            <description>Port selection 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>Selects connection for IO pin 0 route.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>GPIO controls 'out'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>GPIO controls 'out', DSI controls 'output enable'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controls 'out' and 'output enable'</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controls 'out', GPIO controls 'output enable'</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>Analog mux bus A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>Analog mux bus B</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA_DSI</name>
                    <description>Analog mux bus A, DSI control</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB_DSI</name>
                    <description>Analog mux bus B, DSI control</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Active functionality 0</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Active functionality 1</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Active functionality 2</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Active functionality 3</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_0</name>
                    <description>DeepSleep functionality 0</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_1</name>
                    <description>DeepSleep functionality 1</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>DeepSleep functionality 2</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>DeepSleep functionality 3</description>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_4</name>
                    <description>Active functionality 4</description>
                    <value>16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_5</name>
                    <description>Active functionality 5</description>
                    <value>17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_6</name>
                    <description>Active functionality 6</description>
                    <value>18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_7</name>
                    <description>Active functionality 7</description>
                    <value>19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_8</name>
                    <description>Active functionality 8</description>
                    <value>20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_9</name>
                    <description>Active functionality 9</description>
                    <value>21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_10</name>
                    <description>Active functionality 10</description>
                    <value>22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_11</name>
                    <description>Active functionality 11</description>
                    <value>23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_12</name>
                    <description>Active functionality 12</description>
                    <value>24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_13</name>
                    <description>Active functionality 13</description>
                    <value>25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_14</name>
                    <description>Active functionality 14</description>
                    <value>26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_15</name>
                    <description>Active functionality 15</description>
                    <value>27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_4</name>
                    <description>DeepSleep functionality 4</description>
                    <value>28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_5</name>
                    <description>DeepSleep functionality 5</description>
                    <value>29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_6</name>
                    <description>DeepSleep functionality 6</description>
                    <value>30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_7</name>
                    <description>DeepSleep functionality 7</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>Selects connection for IO pin 1 route.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>Selects connection for IO pin 2 route.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>Selects connection for IO pin 3 route.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT_SEL1</name>
            <description>Port selection 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO4_SEL</name>
                <description>Selects connection for IO pin 4 route.
See PORT_SEL0 for connection details.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>Selects connection for IO pin 5 route.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>Selects connection for IO pin 6 route.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>Selects connection for IO pin 7 route.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>10</dim>
          <dimIncrement>16</dimIncrement>
          <name>SECURE_PRT[%s]</name>
          <description>HSIOM secure attribute port registers</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>NONSECURE_MASK</name>
            <description>Non-Secure Mask</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFF</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>NONSECURE0</name>
                <description>Non-secure attribute for IO0.
0 - Allows Secure access only.
1 - Allows Non-secure access only.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NONSECURE1</name>
                <description>Non-secure attribute for IO1.
0 - Allows Secure access only.
1 - Allows Non-secure access only.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NONSECURE2</name>
                <description>Non-secure attribute for IO2.
0 - Allows Secure access only.
1 - Allows Non-secure access only.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NONSECURE3</name>
                <description>Non-secure attribute for IO3.
0 - Allows Secure access only.
1 - Allows Non-secure access only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NONSECURE4</name>
                <description>Non-secure attribute for IO4.
0 - Allows Secure access only.
1 - Allows Non-secure access only.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NONSECURE5</name>
                <description>Non-secure attribute for IO5.
0 - Allows Secure access only.
1 - Allows Non-secure access only.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NONSECURE6</name>
                <description>Non-secure attribute for IO6.
0 - Allows Secure access only.
1 - Allows Non-secure access only.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NONSECURE7</name>
                <description>Non-secure attribute for IO7.
0 - Allows Secure access only.
1 - Allows Non-secure access only.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_0</name>
          <description>Power/Ground Monitor cell control 0</description>
          <addressOffset>0x2200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_1</name>
          <description>Power/Ground Monitor cell control 1</description>
          <addressOffset>0x2204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_2</name>
          <description>Power/Ground Monitor cell control 2</description>
          <addressOffset>0x2208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_3</name>
          <description>Power/Ground Monitor cell control 3</description>
          <addressOffset>0x220C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>IO port control/configuration</description>
      <baseAddress>0x42410000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>10</dim>
          <dimIncrement>128</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>OUT</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO output data for pin 0
'0': Output state set to '0'
'1': Output state set to '1'</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO output data for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO output data for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO output data for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO output data for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO output data for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO output data for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO output data for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO clear output for pin 0:
'0': Output state not affected.
'1': Output state set to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO clear output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO clear output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO clear output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO clear output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO clear output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO clear output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO clear output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO set output for pin 0:
'0': Output state not affected.
'1': Output state set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO set output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO set output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO set output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO set output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO set output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO set output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO set output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO invert output for pin 0:
'0': Output state not affected.
'1': Output state inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO invert output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO invert output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO invert output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO invert output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO invert output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO invert output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO invert output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IN</name>
            <description>Port input state register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>IN0</name>
                <description>IO pin state for pin 0
'0': Low logic level present on pin.
'1': High logic level present on pin.
On reset assertion , IN register will get reset. The Pad value takes 2 clock cycles to be reflected into IN Register.  The default value is transient.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN</name>
                <description>Reads of this register return the logical state of the filtered pin as selected in the INTR_CFG.FLT_SEL register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detect for IO pin 0
'0': No edge was detected on pin.
'1': An edge was detected on pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detect for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detect for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detect for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detect for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detect for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detect for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detect for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_IN0</name>
                <description>IO pin state for pin 0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN_IN</name>
                <description>Filtered pin state for pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Port interrupt mask register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Masks edge interrupt on IO pin 0
'0': Pin interrupt forwarding disabled
'1': Pin interrupt forwarding enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Masks edge interrupt on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Masks edge interrupt on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Masks edge interrupt on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Masks edge interrupt on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Masks edge interrupt on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Masks edge interrupt on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Masks edge interrupt on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Masks edge interrupt on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Port interrupt masked status register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detected AND masked on IO pin 0
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detected and masked on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detected and masked on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detected and masked on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detected and masked on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detected and masked on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detected and masked on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detected and masked on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected and masked on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Port interrupt set register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Sets edge detect interrupt for IO pin 0
'0': Interrupt state not affected
'1': Interrupt set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Sets edge detect interrupt for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Sets edge detect interrupt for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Sets edge detect interrupt for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Sets edge detect interrupt for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Sets edge detect interrupt for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Sets edge detect interrupt for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Sets edge detect interrupt for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Sets edge detect interrupt for filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 0</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 1</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 2</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 3</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 4</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 5</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 6</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 7</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Sets which edge will trigger an IRQ for the glitch filtered pin (selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG</name>
            <description>Port configuration register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_MODE0</name>
                <description>The GPIO drive mode for IO pin 0. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Weak/resistive pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': Weak/resistive pull up
   D_OUT = '1': Weak/resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Weak/resistive pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': Weak/resistive pull down
   D_OUT = '1': Weak/resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': High Impedance
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': High Impedance
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = '0':
    GPIO_DSI_OUT = '0': Weak/resistive pull down
    GPIO_DSI_OUT = '1': Weak/resistive pull up
where 'GPIO_DSI_OUT' is a function of PORT_SEL, OUT &amp; DSI_DATA_OUT.

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
    D_OUT = '0': Weak/resistive pull down
    D_OUT = '1': Weak/resistive pull up</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN0</name>
                <description>Enables the input buffer for IO pin 0.  This bit should be cleared when analog signals are present on the pin to avoid crowbar currents.  The output buffer can be used to drive analog signals high or low without issue.
'0': Input buffer disabled
'1': Input buffer enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE1</name>
                <description>The GPIO drive mode for IO pin 1</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN1</name>
                <description>Enables the input buffer for IO pin 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE2</name>
                <description>The GPIO drive mode for IO pin 2</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN2</name>
                <description>Enables the input buffer for IO pin 2</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE3</name>
                <description>The GPIO drive mode for IO pin 3</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN3</name>
                <description>Enables the input buffer for IO pin 3</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE4</name>
                <description>The GPIO drive mode for IO pin4</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN4</name>
                <description>Enables the input buffer for IO pin 4</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE5</name>
                <description>The GPIO drive mode for IO pin 5</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN5</name>
                <description>Enables the input buffer for IO pin 5</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE6</name>
                <description>The GPIO drive mode for IO pin 6</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN6</name>
                <description>Enables the input buffer for IO pin 6</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE7</name>
                <description>The GPIO drive mode for IO pin 7</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN7</name>
                <description>Enables the input buffer for IO pin 7</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN</name>
            <description>Port input buffer configuration register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_0</name>
                <description>Configures the pin 0 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS</name>
                    <description>Input buffer compatible with CMOS and I2C interfaces</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TTL</name>
                    <description>Input buffer compatible with TTL and MediaLB interfaces</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_0</name>
                <description>Configures the pin 1 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_0</name>
                <description>Configures the pin 2 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_0</name>
                <description>Configures the pin 3 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_0</name>
                <description>Configures the pin 4 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_0</name>
                <description>Configures the pin 5 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_0</name>
                <description>Configures the pin 6 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_0</name>
                <description>Configures the pin 7 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_OUT</name>
            <description>Port output buffer configuration register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF00FF</resetMask>
            <fields>
              <field>
                <name>SLOW0</name>
                <description>Enables slow slew rate for IO pin 0
'0': Fast slew rate
'1': Slow slew rate</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW1</name>
                <description>Enables slow slew rate for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW2</name>
                <description>Enables slow slew rate for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW3</name>
                <description>Enables slow slew rate for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW4</name>
                <description>Enables slow slew rate for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW5</name>
                <description>Enables slow slew rate for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW6</name>
                <description>Enables slow slew rate for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW7</name>
                <description>Enables slow slew rate for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL0</name>
                <description>Sets the GPIO drive strength for IO pin 0</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ZERO</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ONE</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_TWO</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_THREE</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_SEL1</name>
                <description>Sets the GPIO drive strength for IO pin 1</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL2</name>
                <description>Sets the GPIO drive strength for IO pin 2</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL3</name>
                <description>Sets the GPIO drive strength for IO pin 3</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL4</name>
                <description>Sets the GPIO drive strength for IO pin 4</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL5</name>
                <description>Sets the GPIO drive strength for IO pin 5</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL6</name>
                <description>Sets the GPIO drive strength for IO pin 6</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL7</name>
                <description>Sets the GPIO drive strength for IO pin 7</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VREG_EN01</name>
                <description>The regulated output mode is selected ONLY if the CFG.DRIVE_MODE bits are set to the strong pull up (Z_1 = '5') mode If the CFG.DRIVE_MODE bits are set to any other mode the regulated output buffer will be disabled and the standard CMOS output buffer is used.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL01</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL01</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL01</name>
                <description>N/A</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL01</name>
                <description>Selects trip-point of input buffer. In single ended input buffer mode (IBUF01_SEL = '0'):
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.
In differential input buffer mode (IBUF01_SEL = '1'):                                                                  VTRIP_SEL=0:                                                                                                                                a) VREF_SEL=00, VOH_SEL=X -&gt; Trip point=50 percent of vddio
b) VREF_SEL=01, VOH_SEL=000 -&gt; Trip point=Vohref (buffered)
c) VREF_SEL=01, VOH_SEL=[1-7] -&gt; Input buffer functions as CMOS input buffer.
d) VREF_SEL=10/11, VOH_SEL=000 -&gt; Trip point=Amuxbus_a/b (buffered)
e) VREF_SEL=10/11, VOH_SEL=[1-7]  -&gt;  Input buffer functions as CMOS input buffer.                                                                                                                                             VTRIP_SEL=1:                                                                                                                                a) VREF_SEL=00, VOH_SEL=X -&gt; Trip point=40 percent of vddio
b) VREF_SEL=01, VOH_SEL=000 -&gt; Trip point=0.5*Vohref
c) VREF_SEL=01, VOH_SEL=[1-7] -&gt; Input buffer functions as LVTTL input buffer.                                                                                                                                            d) VREF_SEL=10/11, VOH_SEL=000 -&gt; Trip point=0.5*Amuxbus_a/b (buffered)
e) VREF_SEL=10/11, VOH_SEL=[1-7]  -&gt; Input buffer functions as LVTTL input buffer.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN23</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL23</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL23</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL23</name>
                <description>N/A</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL23</name>
                <description>N/A</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN45</name>
                <description>N/A</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL45</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL45</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL45</name>
                <description>N/A</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL45</name>
                <description>N/A</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN67</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL67</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL67</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL67</name>
                <description>N/A</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL67</name>
                <description>N/A</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN_AUTOLVL</name>
            <description>Port input buffer AUTOLVL configuration register for S40E GPIO</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_1</name>
                <description>Configures the input buffer mode (trip points and hysteresis) for S40E GPIO upper bit.  Lower bit is still selected by CFG_IN.VTRIP_SEL0_0 field.  This field is used along with CFG_IN.VTRIP_SEL0_0 field as below:
{CFG_IN_AUTOLVL.VTRIP_SEL0_1,CFG_IN.VTRIP_SEL0_0}:
0,0: CMOS
0,1: TTL
1,0: input buffer is compatible with automotive.
1,1: input buffer is compatible with MediaLB.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS_OR_TTL</name>
                    <description>Input buffer compatible with CMOS/TTL interfaces as described in CFG_IN.VTRIP_SEL0_0.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AUTO_OR_MediaLB</name>
                    <description>Input buffer compatible with AUTO/MediaLB (elevated Vil) interfaces when used along with CFG_IN.VTRIP_SEL0_0.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_OUT2</name>
            <description>Port output buffer configuration register 2</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>DS_TRIM0</name>
                <description>Sets the Drive Select Trim for  IO pin 0
0 - Default (50ohms)
1 - 120ohms
2 - 90ohms
3 - 60ohms
4 - 50ohms
5 - 30ohms
6 - 20ohms
7 - 15ohms</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DEFAULT</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_120OHM</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_90OHM</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_60OHM</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_50OHM</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_30OHM</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_20OHM</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_15OHM</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DS_TRIM1</name>
                <description>Sets the Drive Select Trim for IO pin 1</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM2</name>
                <description>Sets the Drive Select Trim for IO pin 2</description>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM3</name>
                <description>Sets the Drive Select Trim for IO pin 3</description>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM4</name>
                <description>Sets the Drive Select Trim for IO pin 4</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM5</name>
                <description>Sets the Drive Select Trim for IO pin 5</description>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM6</name>
                <description>Sets the Drive Select Trim for IO pin 6</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS_TRIM7</name>
                <description>Sets the Drive Select Trim for IO pin 7</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_SLEW_EXT</name>
            <description>Port output buffer slew extension configuration register</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x77777777</resetMask>
            <fields>
              <field>
                <name>SLEW0</name>
                <description>Enables slow slew rate for IO pin 0
'0': Fast slew rate
'1': Slow slew rate</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW1</name>
                <description>Slew rate for IO pin 1</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW2</name>
                <description>Slew rate for IO pin 2</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW3</name>
                <description>Slew rate for IO pin 3</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW4</name>
                <description>Slew rate for IO pin 4</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW5</name>
                <description>Slew rate for IO pin 5</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW6</name>
                <description>Slew rate for IO pin 6</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEW7</name>
                <description>Slew rate for IO pin 7</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_DRIVE_EXT0</name>
            <description>Port output buffer drive sel extension configuration register</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>DRIVE_SEL_EXT0</name>
                <description>Sets the GPIO drive strength for IO pin 0</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT1</name>
                <description>Sets the GPIO drive strength for IO pin 1</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT2</name>
                <description>Sets the GPIO drive strength for IO pin 2</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT3</name>
                <description>Sets the GPIO drive strength for IO pin 3</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_DRIVE_EXT1</name>
            <description>Port output buffer drive sel extension configuration register</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>DRIVE_SEL_EXT4</name>
                <description>Sets the GPIO drive strength for IO pin 4</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT5</name>
                <description>Sets the GPIO drive strength for IO pin 5</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT6</name>
                <description>Sets the GPIO drive strength for IO pin 6</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL_EXT7</name>
                <description>Sets the GPIO drive strength for IO pin 7</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>SEC_INTR_CAUSE0</name>
          <description>Secure Interrupt port cause register 0</description>
          <addressOffset>0x7000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PRT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE0</name>
          <description>Interrupt port cause register 0</description>
          <addressOffset>0x8000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PRT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_ACTIVE</name>
          <description>Extern power supply detection register</description>
          <addressOffset>0x8010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Indicates presence or absence of VDDIO supplies (i.e. other than VDDD, VDDA) on the device (supplies are numbered 0..n-1).  Note that VDDIO supplies have basic (crude) supply detectors only.  If separate, robust, brown-out detection is desired on IO supplies, on-chip or off-chip analog resources need to provide it.  For these bits to work reliable, the supply must be within valid spec range (per datasheet) or held at ground.  Any in-between voltage has an undefined result.
'0': Supply is not present
'1': Supply is present

When multiple VDDIO supplies are present, they will be assigned in alphanumeric ascending order to these bits during implementation.
For example 'vddusb, vddio_0, vddio_a, vbackup, vddio_r, vddio_1' are present then they will be assigned to these bits as below:
0: vbackup,
1: vddio_0,
2: vddio_1,
3: vddio_a,
4: vddio_r,
5: vddusb'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>This bit indicates presence of the VDDD supply.  This bit will always read-back 1.  The VDDD supply has robust brown-out protection monitoring and it is not possible to read back this register without a valid supply. (This bit is used in certain test-modes to observe the brown-out detector status.)</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR</name>
          <description>Supply detection interrupt register</description>
          <addressOffset>0x8014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply state change detected.
'0': No change to supply detected
'1': Change to supply detected</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>The VDDD supply is always present during operation so a supply transition can not occur. This bit will always read back '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASK</name>
          <description>Supply detection interrupt mask register</description>
          <addressOffset>0x8018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Masks supply interrupt on VDDIO.
'0': VDDIO interrupt forwarding disabled
'1': VDDIO interrupt forwarding enabled</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASKED</name>
          <description>Supply detection interrupt masked register</description>
          <addressOffset>0x801C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply transition detected AND masked
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_SET</name>
          <description>Supply detection interrupt set register</description>
          <addressOffset>0x8020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Sets supply interrupt.
'0': Interrupt state not affected
'1': Interrupt set</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMARTIO</name>
      <description>Programmable IO configuration</description>
      <baseAddress>0x42420000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>10</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>Programmable IO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2001400</resetValue>
            <resetMask>0x82001F00</resetMask>
            <fields>
              <field>
                <name>BYPASS</name>
                <description>Bypass of the programmable IO, one bit for each IO pin: BYPASS[i] is for IO pin i. When ENABLED is '1', this field is used. When ENABLED is '0', this field is NOT used and SMARTIO fabric is always bypassed.
'0': No bypass (programmable SMARTIO fabric is exposed).
'1': Bypass (programmable SMARTIOIO fabric is hidden).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOCK_SRC</name>
                <description>Clock ('clk_fabric') and reset ('rst_fabric_n') source selection:
'0': io_data_in[0]/'1'.
...
'7': io_data_in[7]/'1'.
'8': chip_data[0]/'1'.
...
'15': chip_data[7]/'1'.
'16': clk_smartio/rst_sys_act_n. Used for both Active functionality synchronous logic on 'clk_smartio'. This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'.
'17': clk_smartio/rst_sys_dpslp_n. Used for both DeepSleep functionality synchronous logic on 'clk_smartio' (note that 'clk_smartio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'.
'18': Same as '17'. Note that the M0S8 SMARTIO version used the Hibernate reset for this value, but the MXS40 SMARTIO version does not support Hibernate functionality.
'19': clk_lf/rst_lf_dpslp_n (note that 'clk_lf' is available in DeepSleep power mode). This selection is intended for synchronous operation on'clk_lf'. Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to other 'clk_lf' clocked elements.
'20'-'30': Clock source is constant '0'. Any of these clock sources should be selected when the IP is disabled to ensure low power consumption.
'31': asynchronous mode/'1'.  Select this when clockless operation is configured.

NOTE: Two positive edges of the selected clock are required for the block to be enabled (to deactivate reset).  In asynchronous (clockless) mode clk_sys is used to enable the block, but is not available for clocking.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HLD_OVR</name>
                <description>IO cell hold override functionality. In DeepSleep power mode, the HSIOM holds the IO cell output and output enable signals if Active functionality is connected to the IO pads. This is undesirable if the SMARTIO is supposed to deliver DeepSleep output functionality on these IO pads. This field is used to control the hold override functionality from the SMARTIO:
'0': The HSIOM controls the IO cell hold override functionality ('hsiom_hld_ovr').
'1': The SMARTIO controls the IO cel hold override functionality:
- In bypass mode (ENABLED is '0' or BYPASS[i] is '1'), the HSIOM control is used.
- In NON bypass mode (ENABLED is '1' and BYPASS[i] is '0'), the SMARTIO sets hold override to 'pwr_hld_ovr_hib' to enable SMARTIO functionality in DeepSleep power mode (but disables it in Hibernate or Stop power mode).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PIPELINE_EN</name>
                <description>Enable for pipeline register:
'0': Disabled (register is bypassed).
'1': Enabled.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Enable for programmable IO. Should only be set to '1' when the programmable IO is completely configured:
'0': Disabled (signals are bypassed; behavior as if BYPASS is 0xFF). When disabled, the fabric (data unit and LUTs) reset is activated.

If the IP is disabled:
- The PIPELINE_EN register field should be set to '1', to ensure low power consumption by preventing combinatorial loops.
- The CLOCK_SRC register field should be set to '20'-'30' (clock is constant '0'), to ensure low power consumption.

'1': Enabled. Once enabled, it takes 3 'clk_fabric' clock cycles till the fabric reset is de-activated and the fabric becomes fully functional. This ensures that the IO pins' input synchronizer states are flushed when the fabric is fully functional.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYNC_CTL</name>
            <description>Synchronization control register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>IO_SYNC_EN</name>
                <description>Synchronization of the IO pin input signals to 'clk_fabric', one bit for each IO pin: IO_SYNC_EN[i] is for IO pin i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHIP_SYNC_EN</name>
                <description>Synchronization of the chip input signals to 'clk_fabric', one bit for each input: CHIP_SYNC_EN[i] is for input i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_SEL[%s]</name>
            <description>LUT component input selection</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT_TR0_SEL</name>
                <description>LUT input signal 'tr0_in' source selection:
'0': Data unit output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR1_SEL</name>
                <description>LUT input signal 'tr1_in' source selection:
'0': LUT 0 output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR2_SEL</name>
                <description>LUT input signal 'tr2_in' source selection. Encoding is the same as for LUT_TR1_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_CTL[%s]</name>
            <description>LUT component control register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT</name>
                <description>LUT configuration. Depending on the LUT opcode LUT_OPC, the internal state lut_reg (captured in a flip-flop) and the LUT input signals tr0_in, tr1_in, tr2_in, the LUT configuration is used to determine the LUT output signal and the next sequential state (lut_reg).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_OPC</name>
                <description>LUT opcode specifies the LUT operation:
'0': Combinatoral output, no feedback.
   tr_out   = LUT[{tr2_in, tr1_in, tr0_in}].
'1': Combinatorial output, feedback.
   tr_out   = LUT[{lut_reg, tr1_in, tr0_in}].
On clock:
    lut_reg &lt;= tr_in2.
'2': Sequential output, no feedback.
   temp    = LUT[{tr2_in, tr1_in, tr0_in}].
   tr_out   = lut_reg.
On clock:
   lut_reg &lt;= temp.
'3': Register with asynchronous set and reset.
   tr_out           = lut_reg.
   enable          = (tr2_in ^ LUT[4]) | LUT[5].
   set               = enable &amp; (tr1_in ^ LUT[2]) &amp; LUT[3].
   clr                = enable &amp; (tr0_in ^ LUT[0]) &amp; LUT[1].
Asynchronously (no clock required):
   lut_reg         &lt;= if (clr) '0' else if (set) '1'</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_SEL</name>
            <description>Data unit component input selection</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_TR0_SEL</name>
                <description>Data unit input signal 'tr0_in' source selection:
'0': Constant '0'.
'1': Constant '1'.
'2': Data unit output.
'10-3': LUT 7 - 0 outputs.
Otherwise: Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR1_SEL</name>
                <description>Data unit input signal 'tr1_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR2_SEL</name>
                <description>Data unit input signal 'tr2_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA0_SEL</name>
                <description>Data unit input data 'data0_in' source selection:
'0': Constant '0'.
'1': chip_data[7:0].
'2': io_data_in[7:0].
'3': DATA.DATA MMIO register field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA1_SEL</name>
                <description>Data unit input data 'data1_in' source selection. Encoding is the same as for DU_DATA0_SEL.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_CTL</name>
            <description>Data unit component control register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_SIZE</name>
                <description>Size/width of the data unit data operands (in bits) is DU_SIZE+1. E.g., if DU_SIZE is 7, the width is 8 bits.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_OPC</name>
                <description>Data unit opcode specifies the data unit operation:
'1': INCR
'2': DECR
'3': INCR_WRAP
'4': DECR_WRAP
'5': INCR_DECR
'6': INCR_DECR_WRAP
'7': ROR
'8': SHR
'9': AND_OR
'10': SHR_MAJ3
'11': SHR_EQL.
Otherwise: Undefined.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA</name>
            <description>Data register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data unit input data source.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPCOMP</name>
      <description>Low Power Comparators</description>
      <baseAddress>0x42430000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>LPCOMP Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>LPREF_EN</name>
              <description>Enable the local reference generator circuit to generate the local Vref and Ibias. Ibias current is an  alternative to the reference current IREF generated by SRSS. This bit must be set for System Deep Sleep and System Hibernate operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: LPCOMP disabled (puts analog in power down, opens all switches, all clocks turned off)
- 1: LPCOMP enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>LPCOMP Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>OUT0</name>
              <description>Current output value of the comparator 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OUT1</name>
              <description>Current output value of the comparator 1.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>LPCOMP Interrupt request register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>LPCOMP Interrupt set register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>LPCOMP Interrupt request mask</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>LPCOMP Interrupt request masked</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP0_CTRL</name>
          <description>Comparator 0 control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCE3</resetMask>
          <fields>
            <field>
              <name>MODE0</name>
              <description>N/A</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra lowpower operating mode (uses less power, &lt; 300nA), must be used for DeepSleep or Hibernate. Only in this mode a local iref will be used.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LP</name>
                  <description>Low Power operating mode (uses more power, &lt;10uA @@@ TBD). In this mode the iref from SRSS will be used.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal, full speed power operating mode (uses &lt;150uA). In this mode the iref from SRSS will be used.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST0</name>
              <description>Add hysteresis to the comparator
0= Disable Hysteresis
1= Enable Hysteresis</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE0</name>
              <description>N/A</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_BYPASS0</name>
              <description>Asynchronous: bypass comparator output synchronization:
0=synchronize (level or pulse)
1=bypass (output async)
Note that in System Deep Sleep mode, this bit needs to be set to observe the output on the dedicated pin.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL0</name>
              <description>Synchronous comparator output (trigger):
0=pulse
1=level</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP0_SW</name>
          <description>Comparator 0 switch control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP0_IP0</name>
              <description>Comparator 0 positive terminal isolation switch to GPIO</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AP0</name>
              <description>Comparator 0 positive terminal  switch to amuxbusA</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BP0</name>
              <description>Comparator 0 positive terminal  switch to amuxbusB</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_IN0</name>
              <description>Comparator 0 negative terminal isolation switch to GPIO</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AN0</name>
              <description>Comparator 0 negative terminal  switch to amuxbusA</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BN0</name>
              <description>Comparator 0 negative terminal  switch to amuxbusB</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_VN0</name>
              <description>Comparator 0 negative terminal  switch to local Vref  (LPREF_EN must be set)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP0_SW_CLEAR</name>
          <description>Comparator 0 switch control clear</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP0_IP0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AP0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BP0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_IN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_VN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP1_CTRL</name>
          <description>Comparator 1 control Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCE3</resetMask>
          <fields>
            <field>
              <name>MODE1</name>
              <description>N/A</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra lowpower operating mode (uses less power, &lt; 300nA), must be used for DeepSleep or Hibernate. Only in this mode a local iref will be used.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LP</name>
                  <description>Low Power operating mode (uses more power, &lt;10uA @@@ TBD). In this mode the iref from SRSS will be used.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal, full speed power operating mode (uses &lt;150uA). In this mode the iref from SRSS will be used.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST1</name>
              <description>Add hysteresis to the comparator
0= Disable Hysteresis
1= Enable Hysteresis</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE1</name>
              <description>N/A</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_BYPASS1</name>
              <description>Asynchronous: bypass comparator output synchronization:
0=synchronize (level or pulse)
1=bypass (output async)
Note that in System Deep Sleep mode, this bit needs to be set to observe the output on the dedicated pin.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL1</name>
              <description>Synchronous comparator output (trigger):
0=pulse
1=level</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP1_SW</name>
          <description>Comparator 1 switch control</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP1_IP1</name>
              <description>Comparator 1 positive terminal isolation switch to GPIO</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AP1</name>
              <description>Comparator 1 positive terminal  switch to amuxbusA</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BP1</name>
              <description>Comparator 1 positive terminal  switch to amuxbusB</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_IN1</name>
              <description>Comparator 1 negative terminal isolation switch to GPIO</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AN1</name>
              <description>Comparator 1 negative terminal  switch to amuxbusA</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BN1</name>
              <description>Comparator 1 negative terminal  switch to amuxbusB</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_VN1</name>
              <description>Comparator 1 negative terminal  switch to local Vref  (LPREF_EN must be set)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP1_SW_CLEAR</name>
          <description>Comparator 1 switch control clear</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP1_IP1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AP1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BP1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_IN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_VN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EFUSE</name>
      <description>EFUSE MXS40 registers</description>
      <baseAddress>0x42610000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>512</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>LOCK_CC312_REGION</name>
              <description>CC312 lock - when set  locks 8 bytes beyond the end of the PROT_MASTER defined space for read access.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x800F1F71</resetMask>
          <fields>
            <field>
              <name>BIT_DATA</name>
              <description>Bit data. This field specifies the bit value that is to be programmed into the eFUSE macro array. The address of the bit is specified by the BIT_ADDR, BYTE_ADDR, and MACRO_ADDR fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ADDR</name>
              <description>Bit address. This field specifies a bit within a Byte.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_ADDR</name>
              <description>Byte address. This field specifies a Byte within a eFUSE macro (each macro has 32 B).</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MACRO_ADDR</name>
              <description>Macro address. This field specifies an eFUSE macro.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>FW sets this field to '1' to start a program operation. HW sets this field to '0' to indicate that the operation has completed.

Note: it is good practice to verify the result of a program operation by reading back a programmed eFUSE memory location. Programming can only change an eFUSE memory bit from '0' to '1'; i.e. a programming operation is a 'one-off' operation for each eFUSE memory bit: once a bit is changed to '1', it can NEVER be changed back to '0' as a hardware fuse is blown.

Programming a memory bit to '1' requires blowing a fuse and requires an eFUSE macro operation. Therefore, this programmiong operation takes time (as specified by the SEQ_PROGRAM_CTL reguisters). Programming amemory bit to '0' does not require an eFUSE macro operation (it is the default eFUSE macro state). Therefore, this programming operation is almost instantaneous.

Note: during a program operation, a read operation can not be performed. An AHB-Lite read transfer to the eFUSE memory during a program operation results in an AHB-Lite bus error.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_DEFAULT</name>
          <description>Sequencer Default value</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1D0000</resetValue>
          <resetMask>0x7F0000</resetMask>
          <fields>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_0</name>
          <description>Sequencer read control 0</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x150006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_1</name>
          <description>Sequencer read control 1</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x140001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_2</name>
          <description>Sequencer read control 2</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_3</name>
          <description>Sequencer read control 3</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_4</name>
          <description>Sequencer read control 4</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_5</name>
          <description>Sequencer read control 5</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x140001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_6</name>
          <description>Sequencer read control 6</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80150006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_7</name>
          <description>Sequencer read control 7</description>
          <addressOffset>0x15C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x801D0001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_0</name>
          <description>Sequencer program control 0</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x150006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_1</name>
          <description>Sequencer program control 1</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x35000B</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_2</name>
          <description>Sequencer program control 2</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x240001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_3</name>
          <description>Sequencer program control 3</description>
          <addressOffset>0x16C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x26001E</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_4</name>
          <description>Sequencer program control 4</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x240001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_5</name>
          <description>Sequencer program control 5</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x340001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_6</name>
          <description>Sequencer program control 6</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x350001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_7</name>
          <description>Sequencer program control 7</description>
          <addressOffset>0x17C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80150006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Program cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOTROW</name>
          <description>Content of Boot Row latches at power-on-reset</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BOOT_ROW_DATA</name>
              <description>Contains the Boot Row data held by the Boot Row latches.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CANFD0</name>
      <description>CAN Controller</description>
      <headerStructName>CANFD</headerStructName>
      <baseAddress>0x42800000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>512</dimIncrement>
          <name>CH[%s]</name>
          <description>FIFO wrapper around M_TTCAN 3PIP, to enable DMA</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <name>M_TTCAN</name>
            <description>TTCAN 3PIP, includes FD</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CREL</name>
              <description>Core Release Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x32380609</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DAY</name>
                  <description>Time Stamp Day
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MON</name>
                  <description>Time Stamp Month
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>YEAR</name>
                  <description>Time Stamp Year
One digit, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SUBSTEP</name>
                  <description>Sub-step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STEP</name>
                  <description>Step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REL</name>
                  <description>Core Release
One digit, BCD-coded.</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENDN</name>
              <description>Endian Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x87654321</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ETV</name>
                  <description>Endianness Test Value
The endianness test value is 0x87654321.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DBTP</name>
              <description>Data Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xA33</resetValue>
              <resetMask>0x9F1FFF</resetMask>
              <fields>
                <field>
                  <name>DSJW</name>
                  <description>Data (Re)Synchronization Jump Width
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG2</name>
                  <description>Data time segment after sample point
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG1</name>
                  <description>Data time segment before sample point
0x00-0x1F Valid values are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBRP</name>
                  <description>Data Bit Rate Prescaler
0x00-0x1F The value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDC</name>
                  <description>Transmitter Delay Compensation
0= Transmitter Delay Compensation disabled
1= Transmitter Delay Compensation enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TEST</name>
              <description>Test Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F</resetMask>
              <fields>
                <field>
                  <name>TAM</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Multiplexer Control
Controls output pin m_ttcan_ascm in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_ascm controlled by FSE
1= Level at pin m_ttcan_ascm = '1'</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TAT</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Transmit Control
Controls output pin m_ttcan_asct in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_asct controlled by FSE
1= Level at pin m_ttcan_asct = '1'</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAM</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Multiplexer Control
Monitors level at output pin m_ttcan_ascm.
0= Output pin m_ttcan_ascm = '0'
1= Output pin m_ttcan_ascm = '1'</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAT</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Transmit Control
Monitors level at output pin m_ttcan_asct.
0= Output pin m_ttcan_asct = '0'</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LBCK</name>
                  <description>Loop Back Mode
0= Reset value, Loop Back Mode is disabled
1= Loop Back Mode is enabled (see Section 3.1.9, Test Modes)</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX</name>
                  <description>Control of Transmit Pin
00 Reset value, m_ttcan_tx controlled by the CAN Core, updated at the end of the CAN bit time
01 Sample Point can be monitored at pin m_ttcan_tx
10 Dominant ('0') level at pin m_ttcan_tx
11 Recessive ('1') at pin m_ttcan_tx</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX</name>
                  <description>Receive Pin
Monitors the actual value of pin m_ttcan_rx
0= The CAN bus is dominant (m_ttcan_rx = '0')
1= The CAN bus is recessive (m_ttcan_rx = '1')</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RWD</name>
              <description>RAM Watchdog</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>WDC</name>
                  <description>Watchdog Configuration
Start value of the Message RAM Watchdog Counter. With the reset value of '00' the counter is
disabled.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDV</name>
                  <description>Watchdog Value
Actual Message RAM Watchdog Counter Value.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CCCR</name>
              <description>CC Control Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0xF3FF</resetMask>
              <fields>
                <field>
                  <name>INIT</name>
                  <description>Initialization
0= Normal Operation
1= Initialization is started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CCE</name>
                  <description>Configuration Change Enable
0= The CPU has no write access to the protected configuration registers
1= The CPU has write access to the protected configuration registers (while CCCR.INIT = '1')</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ASM</name>
                  <description>Restricted Operation Mode
Bit ASM can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time. For a description of the Restricted Operation Mode see Section 3.1.5.
0= Normal CAN operation
1= Restricted Operation Mode active</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSA</name>
                  <description>Clock Stop Acknowledge
0= No clock stop acknowledged
1= M_TTCAN may be set in power down by stopping m_ttcan_hclk and m_ttcan_cclk</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSR</name>
                  <description>Clock Stop Request, not supported by M_TTCAN use CTL.STOP_REQ at the group level instead.
0= No clock stop is requested
1= Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after
all pending transfer requests have been completed and the CAN bus reached idle.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MON_</name>
                  <description>Bus Monitoring Mode
Bit MON can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time.
0= Bus Monitoring Mode is disabled
1= Bus Monitoring Mode is enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAR</name>
                  <description>Disable Automatic Retransmission
0= Automatic retransmission of messages not transmitted successfully enabled
1= Automatic retransmission disabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEST</name>
                  <description>Test Mode Enable
0= Normal operation, register TEST holds reset values
1= Test Mode, write access to register TEST enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FDOE</name>
                  <description>FD Operation Enable
0= FD operation disabled
1= FD operation enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BRSE</name>
                  <description>Bit Rate Switch Enable
0= Bit rate switching for transmissions disabled
1= Bit rate switching for transmissions enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PXHD</name>
                  <description>Protocol Exception Handling Disable
0= Protocol exception handling enabled
1= Protocol exception handling disabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFBI</name>
                  <description>Edge Filtering during Bus Integration
0= Edge filtering disabled
1= Two consecutive dominant tq required to detect an edge for hard synchronization</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXP</name>
                  <description>Transmit Pause
If this bit is set, the M_TTCAN pauses for two CAN bit times before starting the next transmission
after itself has successfully transmitted a frame (see Section 3.5).
0= Transmit pause disabled
1= Transmit pause enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NISO</name>
                  <description>Non ISO Operation
If this bit is set, the M_TTCAN uses the CAN FD frame format as specified by the Bosch CAN FD
Specification V1.0.
0= CAN FD frame format according to ISO 11898-1:2015
1= CAN FD frame format according to Bosch CAN FD Specification V1.0 addressing the non-ISO CAN FD</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NBTP</name>
              <description>Nominal Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6000A03</resetValue>
              <resetMask>0xFFFFFF7F</resetMask>
              <fields>
                <field>
                  <name>NTSEG2</name>
                  <description>Nominal Time segment after sample point
0x01-0x7F Valid values are 1 to 127. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NTSEG1</name>
                  <description>Nominal Time segment before sample point
0x01-0xFF Valid values are 1 to 255. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NBRP</name>
                  <description>Nominal Bit Rate Prescaler
0x000-0x1FFThe value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[24:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NSJW</name>
                  <description>Nominal (Re)Synchronization Jump Width
0x00-0x7F Valid values are 0 to 127. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[31:25]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCC</name>
              <description>Timestamp Counter Configuration</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF0003</resetMask>
              <fields>
                <field>
                  <name>TSS</name>
                  <description>Timestamp Select, should always be set to external timestamp counter
00= Timestamp counter value always 0x0000
01= Timestamp counter value incremented according to TCP
10= External timestamp counter value used
11= Same as '00'</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCP</name>
                  <description>Timestamp Counter Prescaler (still used for TOCC)
0x0-0xF Configures the timestamp and timeout counters time unit in multiples of CAN bit times
[1...16]. The actual interpretation by the hardware of this value is such that one more
than the value programmed here is used.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCV</name>
              <description>Timestamp Counter Value</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TSC</name>
                  <description>Timestamp Counter, not used for M_TTCAN
The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx).
When TSCC.TSS = '01', the Timestamp Counter is incremented in multiples of CAN bit times
[1...16] depending on the configuration of TSCC.TCP. A wrap around sets interrupt flag IR.TSW.
Write access resets the counter to zero. When TSCC.TSS = '10', TSC reflects the external
Timestamp Counter value. A write access has no impact.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCC</name>
              <description>Timeout Counter Configuration</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF0000</resetValue>
              <resetMask>0xFFFF0007</resetMask>
              <fields>
                <field>
                  <name>ETOC</name>
                  <description>Enable Timeout Counter
0= Timeout Counter disabled
1= Timeout Counter enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOS</name>
                  <description>Timeout Select
When operating in Continuous mode, a write to TOCV presets the counter to the value configured
by TOCC.TOP and continues down-counting. When the Timeout Counter is controlled by one of the
FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting
is started when the first FIFO element is stored.
00= Continuous operation
01= Timeout controlled by Tx Event FIFO
10= Timeout controlled by Rx FIFO 0
11= Timeout controlled by Rx FIFO 1</description>
                  <bitRange>[2:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOP</name>
                  <description>Timeout Period
Start value of the Timeout Counter (down-counter). Configures the Timeout Period.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCV</name>
              <description>Timeout Counter Value</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TOC</name>
                  <description>Timeout Counter
The Timeout Counter is decremented in multiples of CAN bit times [1...16] depending on the
configuration of TSCC.TCP. When decremented to zero, interrupt flag IR.TOO is set and the
Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ECR</name>
              <description>Error Counter Register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TEC</name>
                  <description>Transmit Error Counter
Actual state of the Transmit Error Counter, values between 0 and 255</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REC</name>
                  <description>Receive Error Counter
Actual state of the Receive Error Counter, values between 0 and 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RP</name>
                  <description>Receive Error Passive
0= The Receive Error Counter is below the error passive level of 128
1= The Receive Error Counter has reached the error passive level of 128</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CEL</name>
                  <description>CAN Error Logging
The counter is incremented each time when a CAN protocol error causes the Transmit Error Counter
or the Receive Error Counter to be incremented. It is reset by read access to CEL. The counter stops
at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PSR</name>
              <description>Protocol Status Register</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x707</resetValue>
              <resetMask>0x7F7FFF</resetMask>
              <fields>
                <field>
                  <name>LEC</name>
                  <description>Last Error Code,
Set on Read0
The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0'
when a message has been transferred (reception or transmission) without error.

0= No Error: No error occurred since LEC has been reset by successful reception or transmission.
1= Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
2= Form Error: A fixed format part of a received frame has the wrong format.
3= AckError: The message transmitted by the M_TTCAN was not acknowledged by another node.
4= Bit1Error: During the transmission of a message (with the exception of the arbitration field),
the device wanted to send a recessive level (bit of logical value '1'), but the monitored bus
 value was dominant.
5= Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or
overload flag), the device wanted to send a dominant level (data or identifier bit logical value
0'), but the monitored bus value was recessive. During Bus_Off recovery this status is set
each time a sequence of 11 recessive bits has been monitored. This enables the CPU to
monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at
dominant or continuously disturbed).
6= CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming
message does not match with the CRC calculated from the received data.
7= NoChange: Any read access to the Protocol Status Register re-initializes the LEC to '7'.
When the LEC shows the value '7', no CAN bus event was detected since the last CPU read
access to the Protocol Status Register.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ACT</name>
                  <description>Activity
Monitors the module's CAN communication state.
00= Synchronizing - node is synchronizing on CAN communication
01= Idle - node is neither receiver nor transmitter
10= Receiver - node is operating as receiver
11= Transmitter - node is operating as transmitter</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP</name>
                  <description>Error Passive
0= The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected
1= The M_CAN is in the Error_Passive state</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EW</name>
                  <description>Warning Status
0= Both error counters are below the Error_Warning limit of 96
1= At least one of error counter has reached the Error_Warning limit of 96</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BO</name>
                  <description>Bus_Off Status
0= The M_CAN is not Bus_Off
1= The M_CAN is in Bus_Off state</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DLEC</name>
                  <description>Data Phase Last Error Code
, Set on Read
Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set. Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with its BRS flag set has been transferred (reception or transmission) without error.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESI</name>
                  <description>ESI flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its ESI flag set
1= Last received CAN FD message had its ESI flag set</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RBRS</name>
                  <description>BRS flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its BRS flag set
1= Last received CAN FD message had its BRS flag set</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RFDF</name>
                  <description>Received a CAN FD Message
, Reset on Read
This bit is set independent of acceptance filtering.
0= Since this bit was reset by the CPU, no CAN FD message has been received
1= Message in CAN FD format with FDF flag set has been received</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PXE</name>
                  <description>Protocol Exception Event
, Reset on Read
0= No protocol exception event occurred since last read access
1= Protocol exception event occurred</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TDCV</name>
                  <description>Transmitter Delay Compensation Value
0x00-0x7F Position of the secondary sample point, defined by the sum of the measured delay from m_can_tx to m_can_rx and TDCR.TDCO. The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TDCR</name>
              <description>Transmitter Delay Compensation Register</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F</resetMask>
              <fields>
                <field>
                  <name>TDCF</name>
                  <description>Transmitter Delay Compensation Filter Window Length
0x00-0x7F Defines the minimum value for the SSP position, dominant edges on m_ttcan_rx
that would result in an earlier SSP position are ignored for transmitter delay measurement.
The feature is enabled when TDCF is configured to a value greater than
TDCO. Valid values are 0 to 127 mtq</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDCO</name>
                  <description>Transmitter Delay Compensation Offset
0x00-0x7F Offset value defining the distance between the measured delay from m_ttcan_tx to
m_ttcan_rx and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IR</name>
              <description>Interrupt Register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0N</name>
                  <description>N/A</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0W</name>
                  <description>N/A</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0F</name>
                  <description>N/A</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0L_</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1N</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1W</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1F</name>
                  <description>N/A</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1L_</name>
                  <description>N/A</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPM</name>
                  <description>N/A</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TC</name>
                  <description>N/A</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCF</name>
                  <description>N/A</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFE</name>
                  <description>N/A</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFN</name>
                  <description>N/A</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFW</name>
                  <description>N/A</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFF</name>
                  <description>N/A</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFL_</name>
                  <description>N/A</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSW</name>
                  <description>N/A</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAF</name>
                  <description>N/A</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOO</name>
                  <description>N/A</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRX</name>
                  <description>N/A</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEC</name>
                  <description>Bit Error Corrected
This bit always reads as 0.</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEU</name>
                  <description>Bit Error Uncorrected
Message RAM bit error detected, uncorrected. The flag is set in the folloiwng cases.
- M_TTCAN detects uncorrectable ECC error from Message RAM when ECC is enabled and ECC error injection is disabled.
- M_TTCAN reads from an out of range Message RAM address.
Message RAM bit error sets CCCR.INIT to '1'. This is done to avoid transmission of corrupted data.
0= No bit error detected when reading from Message RAM
1= Bit error detected, uncorrected</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELO</name>
                  <description>N/A</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_</name>
                  <description>N/A</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EW_</name>
                  <description>N/A</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BO_</name>
                  <description>N/A</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDI</name>
                  <description>N/A</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEA</name>
                  <description>N/A</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PED</name>
                  <description>N/A</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARA</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IE</name>
              <description>Interrupt Enable</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NE</name>
                  <description>Rx FIFO 0 New Message Interrupt Enable

0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WE</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FE</name>
                  <description>Rx FIFO 0 Full Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LE</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NE</name>
                  <description>Rx FIFO 1 New Message Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WE</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FE</name>
                  <description>Rx FIFO 1 Full Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LE</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPME</name>
                  <description>High Priority Message Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCE</name>
                  <description>Transmission Completed Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFE</name>
                  <description>Transmission Cancellation Finished Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEE</name>
                  <description>Tx FIFO Empty Interrupt Enable
0= Interrupt Disabled
1= Interrupt EnabledTx FIFO Empty Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNE</name>
                  <description>Tx Event FIDO New Entry Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWE</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFE</name>
                  <description>Tx Event FIFO Full Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLE</name>
                  <description>Tx Event FIFO Event Lost Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWE</name>
                  <description>Timestamp Wraparound Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFE</name>
                  <description>Message RAM Access Failure Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOE</name>
                  <description>Timeout Occurred Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXE</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECE</name>
                  <description>Bit Error Corrected Interrupt Enable (not used in M_TTCAN)
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUE</name>
                  <description>Bit Error Uncorrected Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOE</name>
                  <description>Error Logging Overflow Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPE</name>
                  <description>Error Passive Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWE</name>
                  <description>Warning Status Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOE</name>
                  <description>Bus_Off Status Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIE</name>
                  <description>Watchdog Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAE</name>
                  <description>Protocol Error in Arbitration Phase Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDE</name>
                  <description>Protocol Error in Data Phase Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAE</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILS</name>
              <description>Interrupt Line Select</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NL</name>
                  <description>Rx FIFO 0 New Message Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WL</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FL</name>
                  <description>Rx FIFO 0 Full Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LL</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NL</name>
                  <description>Rx FIFO 1 New Message Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WL</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FL</name>
                  <description>Rx FIFO 1 Full Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LL</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPML</name>
                  <description>High Priority Message Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCL</name>
                  <description>Transmission Completed Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFL</name>
                  <description>Transmission Cancellation Finished Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEL</name>
                  <description>Tx FIFO Empty Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNL</name>
                  <description>Tx Event FIFO New Entry Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWL</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFL</name>
                  <description>Tx Event FIFO Full Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLL</name>
                  <description>Tx Event FIFO Event Lost Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWL</name>
                  <description>Timestamp Wraparound Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFL</name>
                  <description>Message RAM Access Failure Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOL</name>
                  <description>Timeout Occurred Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXL</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECL</name>
                  <description>Bit Error Corrected Interrupt Select  (not used in M_TTCAN)
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUL</name>
                  <description>Bit Error Uncorrected Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOL</name>
                  <description>Error Logging Overflow Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPL</name>
                  <description>Error Passive Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWL</name>
                  <description>Warning Status Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOL</name>
                  <description>Bus_Off Status Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIL</name>
                  <description>Watchdog Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAL</name>
                  <description>Protocol Error in Arbitration Phase Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDL</name>
                  <description>Protocol Error in Data Phase Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAL</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILE</name>
              <description>Interrupt Line Enable</description>
              <addressOffset>0x5C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>EINT0</name>
                  <description>Enable Interrupt Line 0
0= Interrupt line m_ttcan_int0 disabled
1= Interrupt line m_ttcan_int0 enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EINT1</name>
                  <description>Enable Interrupt Line 1
0= Interrupt line m_ttcan_int1 disabled
1= Interrupt line m_ttcan_int1 enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GFC</name>
              <description>Global Filter Configuration</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>RRFE</name>
                  <description>Reject Remote Frames Extended
0= Filter remote frames with 29-bit extended IDs
1= Reject all remote frames with 29-bit extended IDs</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RRFS</name>
                  <description>Reject Remote Frames Standard
0= Filter remote frames with 11-bit standard IDs
1= Reject all remote frames with 11-bit standard IDs</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFE</name>
                  <description>Accept Non-matching Frames Extended
Defines how received messages with 29-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFS</name>
                  <description>Accept Non-matching Frames Standard
Defines how received messages with 11-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SIDFC</name>
              <description>Standard ID Filter Configuration</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFC</resetMask>
              <fields>
                <field>
                  <name>FLSSA</name>
                  <description>Filter List Standard Start Address
Start address of standard Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSS</name>
                  <description>List Size Standard
0= No standard Message ID filter
1-128= Number of standard Message ID filter elements
128= Values greater than 128 are interpreted as 128</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDFC</name>
              <description>Extended ID Filter Configuration</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>FLESA</name>
                  <description>Filter List Extended Start Address
Start address of extended Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSE</name>
                  <description>List Size Extended
0= No extended Message ID filter
1-64= Number of extended Message ID filter elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDAM</name>
              <description>Extended ID AND Mask</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1FFFFFFF</resetValue>
              <resetMask>0x1FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EIDM</name>
                  <description>Extended ID Mask
For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message
ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all
bits set to one the mask is not active.</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HPMS</name>
              <description>High Priority Message Status</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BIDX</name>
                  <description>Buffer Index
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = '1'.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MSI</name>
                  <description>Message Storage Indicator
00= No FIFO selected
01= FIFO message lost
10= Message stored in FIFO 0
11= Message stored in FIFO 1</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIDX</name>
                  <description>Filter Index
Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLST</name>
                  <description>Filter List
Indicates the filter list of the matching filter element.
0= Standard Filter List
1= Extended Filter List</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT1</name>
              <description>New Data 1</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 0 to 31. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT2</name>
              <description>New Data 2</description>
              <addressOffset>0x9C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 32 to 63. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0C</name>
              <description>Rx FIFO 0 Configuration</description>
              <addressOffset>0xA0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F0SA</name>
                  <description>Rx FIFO 0 Start Address
Start address of Rx FIFO 0 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0S</name>
                  <description>Rx FIFO 0 Size
0= No Rx FIFO 0
1-64= Number of Rx FIFO 0 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 0 elements are indexed from 0 to F0S-1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0WM</name>
                  <description>Rx FIFO 0 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 0 watermark interrupt (IR.RF0W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0OM</name>
                  <description>FIFO 0 Operation Mode
FIFO 0 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 0 blocking mode
1= FIFO 0 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0S</name>
              <description>Rx FIFO 0 Status</description>
              <addressOffset>0xA4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F0FL</name>
                  <description>Rx FIFO 0 Fill Level
Number of elements stored in Rx FIFO 0, range 0 to 64.
When the software reading the value immediately after writing to RXF0A.F0AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0GI</name>
                  <description>Rx FIFO 0 Get Index
Rx FIFO 0 read index pointer, range 0 to 63.
This field is updated by the software writing to RXF0A.F0AI.
When the software reading the value immediately after writing to RXF0A.F0AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0PI</name>
                  <description>Rx FIFO 0 Put Index
Rx FIFO 0 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0F</name>
                  <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF0L</name>
                  <description>Rx FIFO 0 Message Lost
This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset.
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0A</name>
              <description>Rx FIFO 0 Acknowledge</description>
              <addressOffset>0xA8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F0AI</name>
                  <description>Rx FIFO 0 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the
 buffer index of the last element read from Rx FIFO 0 to F0AI. This will set the Rx FIFO 0 Get Index
 RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXBC</name>
              <description>Rx Buffer Configuration</description>
              <addressOffset>0xAC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFC</resetMask>
              <fields>
                <field>
                  <name>RBSA</name>
                  <description>Rx Buffer Start Address
Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address).
Also used to reference debug messages A,B,C.</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1C</name>
              <description>Rx FIFO 1 Configuration</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F1SA</name>
                  <description>Rx FIFO 1 Start Address
Start address of Rx FIFO 1 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1S</name>
                  <description>Rx FIFO 1 Size
0= No Rx FIFO 1
1-64= Number of Rx FIFO 1 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 1 elements are indexed from 0 to F1S - 1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1WM</name>
                  <description>Rx FIFO 1 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 1 watermark interrupt (IR.RF1W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1OM</name>
                  <description>FIFO 1 Operation Mode
FIFO 1 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 1 blocking mode
1= FIFO 1 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1S</name>
              <description>Rx FIFO 1 Status</description>
              <addressOffset>0xB4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F1FL</name>
                  <description>Rx FIFO 1 Fill Level
Number of elements stored in Rx FIFO 1, range 0 to 64.
When the software reading the value immediately after writing to RXF1A.F1AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1GI</name>
                  <description>Rx FIFO 1 Get Index
Rx FIFO 1 read index pointer, range 0 to 63.
This field is updated by the software writing to RXF1A.F1AI.
When the software reading the value immediately after writing to RXF1A.F1AI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1PI</name>
                  <description>Rx FIFO 1 Put Index
Rx FIFO 1 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1F</name>
                  <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF1L</name>
                  <description>Rx FIFO 1 Message Lost
This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset.
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DMS</name>
                  <description>Debug Message Status
00= Idle state, wait for reception of debug messages, DMA request is cleared
01= Debug message A received
10= Debug messages A, B received
11= Debug messages A, B, C received, DMA request is set</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1A</name>
              <description>Rx FIFO 1 Acknowledge</description>
              <addressOffset>0xB8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F1AI</name>
                  <description>Rx FIFO 1 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the
 buffer index of the last element read from Rx FIFO 1 to F1AI. This will set the Rx FIFO 1 Get Index
 RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXESC</name>
              <description>Rx Buffer / FIFO Element Size Configuration</description>
              <addressOffset>0xBC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x777</resetMask>
              <fields>
                <field>
                  <name>F0DS</name>
                  <description>Rx FIFO 0 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1DS</name>
                  <description>Rx FIFO 1 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RBDS</name>
                  <description>Rx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBC</name>
              <description>Tx Buffer Configuration</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>TBSA</name>
                  <description>Tx Buffers Start Address
Start address of Tx Buffers section in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NDTB</name>
                  <description>Number of Dedicated Transmit Buffers
0= No Dedicated Tx Buffers
1-32= Number of Dedicated Tx Buffers
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQS</name>
                  <description>Transmit FIFO/Queue Size
0= No Tx FIFO/Queue
1-32= Number of Tx Buffers used for Tx FIFO/Queue
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQM</name>
                  <description>Tx FIFO/Queue Mode
0= Tx FIFO operation
1= Tx Queue operation</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXFQS</name>
              <description>Tx FIFO/Queue Status</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F1F3F</resetMask>
              <fields>
                <field>
                  <name>TFFL</name>
                  <description>Tx FIFO Free Level
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when
Tx Queue operation is configured (TXBC.TFQM = '1')</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFGI</name>
                  <description>Tx FIFO Get Index
Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured
TXBC.TFQM = '1').</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQPI</name>
                  <description>Tx FIFO/Queue Put Index
Tx FIFO/Queue write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQF</name>
                  <description>Tx FIFO/Queue Full
0= Tx FIFO/Queue not full
1= Tx FIFO/Queue full</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXESC</name>
              <description>Tx Buffer Element Size Configuration</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TBDS</name>
                  <description>Tx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBRP</name>
              <description>Tx Buffer Request Pending</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TRP</name>
                  <description>Transmission Request Pending
Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR.
The bits are reset after a requested transmission has completed or has been cancelled via register
TXBCR.
TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set,
a Tx scan (see Section 3.5, Tx Handling) is started to check for the pending Tx request with the
highest priority (Tx Buffer with lowest Message ID).
A cancellation request resets the corresponding transmission request pending bit of register
TXBRP. In case a transmission has already been started when a cancellation is requested, this is
done at the end of the transmission, regardless whether the transmission was successful or not. The
cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.
After a cancellation has been requested, a finished cancellation is signaled via TXBCF
after successful transmission together with the corresponding TXBTO bit
when the transmission has not yet been started at the point of cancellation
when the transmission has been aborted due to lost arbitration
when an error occurred during frame transmission
In DAR mode all transmissions are automatically cancelled if they are not successful. The
corresponding TXBCF bit is set for all unsuccessful transmissions.
0= No transmission request pending
1= Transmission request pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBAR</name>
              <description>Tx Buffer Add Request</description>
              <addressOffset>0xD0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>AR</name>
                  <description>Add Request
Each Tx Buffer has its own Add Request bit. Writing a '1' will set the corresponding Add Request
bit; writing a '0' has no impact. This enables the Host to set transmission requests for multiple Tx
Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC.
When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan
process has completed.
0= No transmission request added
1= Transmission requested added</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCR</name>
              <description>Tx Buffer Cancellation Request</description>
              <addressOffset>0xD4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CR</name>
                  <description>Cancellation Request
Each Tx Buffer has its own Cancellation Request bit. Writing a '1' will set the corresponding
Cancellation Request bit; writing a '0' has no impact. This enables the Host to set cancellation
requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx
Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset.
0= No cancellation pending
1= Cancellation pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTO</name>
              <description>Tx Buffer Transmission Occurred</description>
              <addressOffset>0xD8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TO</name>
                  <description>Transmission Occurred
Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding
TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission
is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmission occurred
1= Transmission occurred</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCF</name>
              <description>Tx Buffer Cancellation Finished</description>
              <addressOffset>0xDC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CF</name>
                  <description>Cancellation Finished
Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding
TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding
TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a
new transmission is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmit buffer cancellation
1= Transmit buffer cancellation finished</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTIE</name>
              <description>Tx Buffer Transmission Interrupt Enable</description>
              <addressOffset>0xE0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIE</name>
                  <description>Transmission Interrupt Enable
Each Tx Buffer has its own Transmission Interrupt Enable bit.
0= Transmission interrupt disabled
1= Transmission interrupt enable</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCIE</name>
              <description>Tx Buffer Cancellation Finished Interrupt Enable</description>
              <addressOffset>0xE4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CFIE</name>
                  <description>Cancellation Finished Interrupt Enable
Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.
0= Cancellation finished interrupt disabled
1= Cancellation finished interrupt enabled</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFC</name>
              <description>Tx Event FIFO Configuration</description>
              <addressOffset>0xF0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>EFSA</name>
                  <description>Event FIFO Start Address
Start address of Tx Event FIFO in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFS</name>
                  <description>Event FIFO Size
0= Tx Event FIFO disabled
1-32= Number of Tx Event FIFO elements
32= Values greater than 32 are interpreted as 32
The Tx Event FIFO elements are indexed from 0 to EFS-1</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFWM</name>
                  <description>Event FIFO Watermark
0= Watermark interrupt disabled
1-32= Level for Tx Event FIFO watermark interrupt (IR.TEFW)
32= Watermark interrupt disabled</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFS</name>
              <description>Tx Event FIFO Status</description>
              <addressOffset>0xF4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x31F1F3F</resetMask>
              <fields>
                <field>
                  <name>EFFL</name>
                  <description>Event FIFO Fill Level
Number of elements stored in Tx Event FIFO, range 0 to 32.
When the software reading the value immediately after writing to TXEFA.EFAI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFGI</name>
                  <description>Event FIFO Get Index
Tx Event FIFO read index pointer, range 0 to 31.
This field is updated by the software writing to TXEFA.EFAI.
When the software reading the value immediately after writing to TXEFA.EFAI, this value should be read twice to ensure that the update is reflected.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFPI</name>
                  <description>Event FIFO Put Index
Tx Event FIFO write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFF</name>
                  <description>Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TEFL</name>
                  <description>Tx Event FIFO Element Lost
This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset.
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFA</name>
              <description>Tx Event FIFO Acknowledge</description>
              <addressOffset>0xF8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>EFAI</name>
                  <description>Event FIFO Acknowledge Index
After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write
the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get
Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMC</name>
              <description>TT Trigger Memory Configuration</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>TMSA</name>
                  <description>Trigger Memory Start Address
Start address of Trigger Memory in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TME</name>
                  <description>Trigger Memory Elements
0= No Trigger Memory
1-64= Number of Trigger Memory elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTRMC</name>
              <description>TT Reference Message Configuration</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xDFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RID</name>
                  <description>Reference Identifier
Identifier transmitted with reference message and used for reference message filtering. Standard or
extended reference identifier depending on bit XTD. A standard identifier has to be written to
ID[28:18].</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>XTD</name>
                  <description>Extended Identifier
0= 11-bit standard identifier
1= 29-bit extended identifier</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RMPS</name>
                  <description>Reference Message Payload Select
Ignored in case of time slaves.
0= Reference message has no additional payload
1= The following elements are taken from Tx Buffer 0:
Message Marker MM, Event FIFO Control EFC, Data Length Code DLC, Data Bytes DB
Level 1: bytes 2-8, Level 0,2: bytes 5-8)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCF</name>
              <description>TT Operation Configuration</description>
              <addressOffset>0x108</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x7FFFFFB</resetMask>
              <fields>
                <field>
                  <name>OM</name>
                  <description>Operation Mode
00= Event-driven CAN communication, default
01= TTCAN level 1
10= TTCAN level 2
11= TTCAN level 0</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN</name>
                  <description>Gap Enable
0= Strictly time-triggered operation
1= External event-synchronized time-triggered operation</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TM</name>
                  <description>Time Master
0= Time Master function disabled
1= Potential Time Master</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDSDL</name>
                  <description>LD of Synchronization Deviation Limit
The Synchronization Deviation Limit SDL is configured by its dual logarithm LDSDL with SDL =
2(LDSDL + 5). It should not exceed the clock tolerance given by the CAN bit timing configuration.
0x0-7 LD of Synchronization Deviation Limit (SDL &lt;= 32...4096)</description>
                  <bitRange>[7:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IRTO</name>
                  <description>Initial Reference Trigger Offset
0x00-7F Positive offset, range from 0 to 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EECS</name>
                  <description>Enable External Clock Synchronization
If enabled, TUR configuration (TURCF.NCL only) may be updated during TTCAN operation.
0= External clock synchronization in TTCAN Level 0,2 disabled
1= External clock synchronization in TTCAN Level 0,2 enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL</name>
                  <description>Application Watchdog Limit
The application watchdog can be disabled by programming AWL to 0x00.
0x00-FF Maximum time after which the application has to serve the application watchdog.
The application watchdog is incremented once each 256 NTUs.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EGTF</name>
                  <description>Enable Global Time Filtering
0= Global time filtering in TTCAN Level 0,2 is disabled
1= Global time filtering in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECC</name>
                  <description>Enable Clock Calibration
0= Automatic clock calibration in TTCAN Level 0,2 is disabled
1= Automatic clock calibration in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EVTP</name>
                  <description>Event Trigger Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTMLM</name>
              <description>TT Matrix Limits</description>
              <addressOffset>0x10C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFF0FFF</resetMask>
              <fields>
                <field>
                  <name>CCM</name>
                  <description>N/A</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSS</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXEW</name>
                  <description>Tx Enable Window
0x0-F Length of Tx enable window, 1-16 NTU cycles</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENTT</name>
                  <description>Expected Number of Tx Triggers
0x000-FFF Expected number of Tx Triggers in one Matrix Cycle</description>
                  <bitRange>[27:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURCF</name>
              <description>TUR Configuration</description>
              <addressOffset>0x110</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000000</resetValue>
              <resetMask>0xBFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>NCL</name>
                  <description>Numerator Configuration Low
Write access to the TUR Numerator Configuration Low is only possible during configuration with
TURCF.ELT = '0' or if TTOCF.EECS (external clock synchronization enabled) is set. When a new
value for NCL is written outside TT Configuration Mode, the new value takes effect when
TTOST.WECS is cleared to '0'. NCL is locked TTOST.WECS is '1'.
0x0000-FFFF Numerator Configuration Low</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DC</name>
                  <description>Denominator Configuration
0x0000 Illegal value
0x0001-3FFF Denominator Configuration</description>
                  <bitRange>[29:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELT</name>
                  <description>Enable Local Time
0= Local time is stopped, default
1= Local time is enabled</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCN</name>
              <description>TT Operation Control</description>
              <addressOffset>0x114</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xBFFF</resetMask>
              <fields>
                <field>
                  <name>SGT</name>
                  <description>Set Global time
Writing a '1' to SGT sets TTOST.WGDT if the node is the actual Time Master. SGT is reset after one
Host clock period. The global time preset takes effect when the node transmits the next reference
message with the Master_Ref_Mark modified by the preset value written to TTGTP.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECS</name>
                  <description>External Clock Synchronization
Writing a '1' to ECS sets TTOST.WECS if the node is the actual Time Master. ECS is reset after one
Host clock period. The external clock synchronization takes effect at the start of the next basic cycle.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWP</name>
                  <description>Stop Watch Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWS</name>
                  <description>Stop Watch Source
00= Stop Watch disabled
01= Actual value of cycle time is copied to TTCPT.SWV
10= Actual value of local time is copied to TTCPT.SWV
11= Actual value of global time is copied to TTCPT.SWV</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTIE</name>
                  <description>Register Time Mark Interrupt Pulse Enable
Register time mark interrupts are configured by register TTTMK. A register time mark interrupt pulse
with the length of one NTU is generated when the time referenced by TTOCN.TMC (cycle, local, or
global) equals TTTMK.TM, independent of the synchronization state.
0= Register Time Mark Interrupt output m_ttcan_rtp disabled
1= Register Time Mark Interrupt output m_ttcan_rtp enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMC</name>
                  <description>Register Time Mark Compare
00= No Register Time Mark Interrupt generated
01= Register Time Mark Interrupt if Time Mark = cycle time
10= Register Time Mark Interrupt if Time Mark = local time
11= Register Time Mark Interrupt if Time Mark = global time</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTIE</name>
                  <description>Trigger Time Mark Interrupt Pulse Enable
External time mark events are configured by trigger memory element TMEX (see Section 2.4.7). A
trigger time mark interrupt pulse is generated when the trigger memory element becomes active,
and the M_TTCAN is in synchronization state In_Schedule or In_Gap.
0= Trigger Time Mark Interrupt output m_ttcan_tmp disabled
1= Trigger Time Mark Interrupt output m_ttcan_tmp enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GCS</name>
                  <description>Gap Control Select
0= Gap control independent from m_ttcan_evt
1= Gap control by input pin m_ttcan_evt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FGP</name>
                  <description>Finish Gap
Set by the CPU, reset by each reference message
0= No reference message requested
1= Application requested start of reference message</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMG</name>
                  <description>Time Mark Gap
0= Reset by each reference message
1= Next reference message started when Register Time Mark interrupt TTIR.RTMI is activated</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NIG</name>
                  <description>Next is Gap
This bit can only be set when the M_TTCAN is the actual Time Master and when it is configured for
external event-synchronized time-triggered operation (TTOCF.GEN = '1')
0= No action, reset by reception of any reference message
1= Transmit next reference message with Next_is_Gap = '1'</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ESCN</name>
                  <description>External Synchronization Control
If enabled the M_TTCAN synchronizes its cycle time phase to an external event signaled by a rising
edge at pin m_ttcan_evt (see Section 4.11).
0= External synchronization disabled
1= External synchronization enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKC</name>
                  <description>TT Operation Control Register Locked
Set by a write access to register TTOCN. Reset when the updated configuration has been
synchronized into the CAN clock domain.
0= Write access to TTOCN enabled
1= Write access to TTOCN locked</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTGTP</name>
              <description>TT Global Time Preset</description>
              <addressOffset>0x118</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TP</name>
                  <description>N/A</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTP</name>
                  <description>Cycle Time Target Phase
CTP is write-protected while TTOCN.ESCN or TTOST.SPL are set (see Section 4.11).
0x0000-FFFF Defines target value of cycle time when a rising edge of m_ttcan_evt is expected</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMK</name>
              <description>TT Time Mark</description>
              <addressOffset>0x11C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x807FFFFF</resetMask>
              <fields>
                <field>
                  <name>TM_</name>
                  <description>Time Mark
0x0000-FFFF Time Mark</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TICC</name>
                  <description>Time Mark Cycle Code
Cycle count for which the time mark is valid.
0b000000x valid for all cycles
0b000001c valid every second cycle at cycle count mod2 = c
0b00001cc valid every fourth cycle at cycle count mod4 = cc
0b0001ccc valid every eighth cycle at cycle count mod8 = ccc
0b001cccc valid every sixteenth cycle at cycle count mod16 = cccc
0b01ccccc valid every thirty-second cycle at cycle count mod32 = ccccc
0b1cccccc valid every sixty-fourth cycle at cycle count mod64 = cccccc</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKM</name>
                  <description>TT Time Mark Register Locked
Always set by a write access to registers TTOCN. Set by write access to register TTTMK when
TTOCN.TMC != '00'. Reset when the registers have been synchronized into the CAN clock domain.
0= Write access to TTTMK enabled
1= Write access to TTTMK locked</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIR</name>
              <description>TT Interrupt Register</description>
              <addressOffset>0x120</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBC</name>
                  <description>Start of Basic Cycle
0= No Basic Cycle started since bit has been reset
1= Basic Cycle started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMC</name>
                  <description>Start of Matrix Cycle
0= No Matrix Cycle started since bit has been reset
1= Matrix Cycle started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSM_</name>
                  <description>Change of Synchronization Mode
0= No change in master to slave relation or schedule synchronization
1= Master to slave relation or schedule synchronization changed,
also set when TTOST.SPL is reset</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOG</name>
                  <description>Start of Gap
0= No reference message seen with Next_is_Gap bit set
1= Reference message with Next_is_Gap bit set becomes valid</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMI</name>
                  <description>Register Time Mark Interrupt
Set when time referenced by TTOCN.TMC (cycle, local, or global) equals TTTMK.TM, independent
of the synchronization state.
0= Time mark not reached
1= Time mark reached</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMI</name>
                  <description>Trigger Time Mark Event Internal
Internal time mark events are configured by trigger memory element TMIN (see Section 2.4.7). Set
when the trigger memory element becomes active, and the M_TTCAN is in synchronization state
In_Gap or In_Schedule.
0= Time mark not reached
1= Time mark reached (Level 0: cycle time TTOCF.IRTO * 0x200)</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWE</name>
                  <description>Stop Watch Event
0= No rising/falling edge at stop watch trigger pin m_ttcan_swt detected
1= Rising/falling edge at stop watch trigger pin m_ttcan_swt detected</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTW</name>
                  <description>Global Time Wrap
0= No global time wrap occurred
1= Global time wrap from 0xFFFF to 0x0000 occurred</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTD</name>
                  <description>Global Time Discontinuity
0= No discontinuity of global time
1= Discontinuity of global time</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTE</name>
                  <description>Global Time Error
Synchronization deviation SD exceeds limit specified by TTOCF.LDSDL, TTCAN Level 0,2 only.
0= Synchronization deviation within limit
1= Synchronization deviation exceeded limit</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXU</name>
                  <description>Tx Count Underflow
0= Number of Tx Trigger as expected
1= Less Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXO</name>
                  <description>Tx Count Overflow
0= Number of Tx Trigger as expected
1= More Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1</name>
                  <description>Scheduling Error 1
0= No scheduling error 1
1= Scheduling error 1 occurred</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2</name>
                  <description>Scheduling Error 2
0= No scheduling error 2
1= Scheduling error 2 occurred</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELC</name>
                  <description>Error Level Changed
Not set when error level changed during initialization.
0= No change in error level
1= Error level changed</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWT</name>
                  <description>Initialization Watch Trigger
The initialization is restarted by resetting IWT.
0= No missing reference message during system startup
1= No system startup due to missing reference message</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WT</name>
                  <description>Watch Trigger
0= No missing reference message
1= Missing reference message (Level 0: cycle time 0xFF00)</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AW</name>
                  <description>Application Watchdog
0= Application watchdog served in time
1= Application watchdog not served in time</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CER</name>
                  <description>Configuration Error
Trigger out of order.
0= No error found in trigger list
1= Error found in trigger list</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIE</name>
              <description>TT Interrupt Enable</description>
              <addressOffset>0x124</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCE</name>
                  <description>Start of Basic Cycle Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCE</name>
                  <description>Start of Matrix Cycle Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSME</name>
                  <description>Change of Synchronization Mode Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGE</name>
                  <description>Start of Gap Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIE</name>
                  <description>Register Time Mark Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIE</name>
                  <description>Trigger Time Mark Event Internal Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEE</name>
                  <description>Stop Watch Event Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWE</name>
                  <description>Global Time Wrap Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDE</name>
                  <description>Global Time Discontinuity Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEE</name>
                  <description>Global Time Error Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUE</name>
                  <description>Tx Count Underflow Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOE</name>
                  <description>Tx Count Overflow Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1E</name>
                  <description>Scheduling Error 1 Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2E</name>
                  <description>Scheduling Error 2 Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCE</name>
                  <description>Change Error Level Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTE</name>
                  <description>Initialization Watch Trigger Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTE</name>
                  <description>Watch Trigger Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWE_</name>
                  <description>Application Watchdog Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERE</name>
                  <description>Configuration Error Interrupt Enable
0= Interrupt Disabled
1= Interrupt Enabled</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTILS</name>
              <description>TT Interrupt Line Select</description>
              <addressOffset>0x128</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCL</name>
                  <description>Start of Basic Cycle Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCL</name>
                  <description>Start of Matrix Cycle Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSML</name>
                  <description>Change of Synchronization Mode Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGL</name>
                  <description>Start of Gap Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIL</name>
                  <description>Register Time Mark Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIL</name>
                  <description>Trigger Time Mark Event Internal Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEL</name>
                  <description>Stop Watch Event Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWL</name>
                  <description>Global Time Wrap Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDL</name>
                  <description>Global Time Discontinuity Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEL</name>
                  <description>Global Time Error Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUL</name>
                  <description>Tx Count Underflow Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOL</name>
                  <description>Tx Count Overflow Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1L</name>
                  <description>Scheduling Error 1 Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2L</name>
                  <description>Scheduling Error 2 Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCL</name>
                  <description>Change Error Level Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTL</name>
                  <description>Initialization Watch Trigger Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTL</name>
                  <description>Watch Trigger Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL_</name>
                  <description>Application Watchdog Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERL</name>
                  <description>Configuration Error Interrupt Select
0= Assign to interrupt  enabled by ILE.EINT0
1= Assign to interrupt enabled by ILE.EINT1</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOST</name>
              <description>TT Operation Status</description>
              <addressOffset>0x12C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x80</resetValue>
              <resetMask>0xFFC0FFFF</resetMask>
              <fields>
                <field>
                  <name>EL</name>
                  <description>Error Level
00= Severity 0 - No Error
01= Severity 1 - Warning
10= Severity 2 - Error
11= Severity 3 - Severe Error</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master State
00= Master_Off, no master properties relevant
01= Operating as Time Slave
10= Operating as Backup Time Master
11= Operating as current Time Master</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SYS</name>
                  <description>Synchronization State
00= Out of Synchronization
01= Synchronizing to TTCAN communication
10= Schedule suspended by Gap (In_Gap)
11= Synchronized to schedule (In_Schedule)</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QGTP</name>
                  <description>Quality of Global Time Phase
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '0'.
0= Global time not valid
1= Global time in phase with Time Master</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QCS</name>
                  <description>Quality of Clock Speed
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '1'.
0= Local clock speed not synchronized to Time Master clock speed
1= Synchronization Deviation &lt;= SDL</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RTO</name>
                  <description>Reference Trigger Offset
The Reference Trigger Offset value is a signed integer with a range from -127 (0x81) to 127 (0x7F).
There is no notification when the lower limit of -127 is reached. In case the M_TTCAN becomes
Time Master (MS[1:0] = '11'), the reset of RTO is delayed due to synchronization between Host and
CAN clock domain. For time slaves the value configured by TTOCF.IRTO is read.
0x00-FF Actual Reference Trigger offset value</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WGTD</name>
                  <description>Wait for Global Time Discontinuity
0= No global time preset pending
1= Node waits for the global time preset to take effect. The bit is reset when the node has transmitted
a reference message with Disc_Bit = '1' or after it received a reference message.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GFI</name>
                  <description>Gap Finished Indicator
Set when the CPU writes TTOCN.FGP, or by a time mark interrupt if TMG = '1', or via input pin
m_ttcan_evt if TTOCN.GCS = '1'. Not set by Ref_Trigger_Gap or when Gap is finished by another
node sending a reference message.
0= Reset at the end of each reference message
1= Gap finished by M_TTCAN</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TMP</name>
                  <description>Time Master Priority
0x0-7 Priority of actual Time Master</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GSI</name>
                  <description>Gap Started Indicator
0= No Gap in schedule, reset by each reference message and for all time slaves
1= Gap time after Basic Cycle has started</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WFE</name>
                  <description>Wait for Event
0= No Gap announced, reset by a reference message with Next_is_Gap = '0'
1= Reference message with Next_is_Gap = '1' received</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>AWE</name>
                  <description>Application Watchdog Event
The application watchdog is served by reading TTOST. When the watchdog is not served in time,
bit AWE is set, all TTCAN communication is stopped, and the M_TTCAN is set into Bus Monitoring
Mode.
0= Application Watchdog served in time
1= Failed to serve Application Watchdog in time</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WECS</name>
                  <description>Wait for External Clock Synchronization
0= No external clock synchronization pending
1= Node waits for external clock synchronization to take effect. The bit is reset at the start of the
next basic cycle.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPL</name>
                  <description>Schedule Phase Lock
The bit is valid only when external synchronization is enabled (TTOCN.ESCN = '1'). In this case it
signals that the difference between cycle time configured by TTGTP.CTP and the cycle time at the
rising edge at pin m_ttcan_evt is less or equal 9 NTU (see Section 4.11).
0= Phase outside range
1= Phase inside range</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURNA</name>
              <description>TUR Numerator Actual</description>
              <addressOffset>0x130</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x3FFFF</resetMask>
              <fields>
                <field>
                  <name>NAV</name>
                  <description>N/A</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTLGT</name>
              <description>TT Local &amp; Global Time</description>
              <addressOffset>0x134</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LT</name>
                  <description>Local Time
Non-fractional part of local time, incremented once each local NTU (see Section 4.5).
0x0000-FFFF Local time value of TTCAN node</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GT</name>
                  <description>Global Time
Non-fractional part of the sum of the node's local time and its local offset (see Section 4.5).
0x0000-FFFF Global time value of TTCAN network</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCTC</name>
              <description>TT Cycle Time &amp; Count</description>
              <addressOffset>0x138</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x3F0000</resetValue>
              <resetMask>0x3FFFFF</resetMask>
              <fields>
                <field>
                  <name>CT</name>
                  <description>Cycle Time
Non-fractional part of the difference of the node's local time and Ref_Mark (see Section 4.5).
0x0000-FFFF Cycle time value of TTCAN Basic Cycle</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC</name>
                  <description>Cycle Count
0x00-3F Number of actual Basic Cycle in the System Matrix</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCPT</name>
              <description>TT Capture Time</description>
              <addressOffset>0x13C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF003F</resetMask>
              <fields>
                <field>
                  <name>CCV</name>
                  <description>Cycle Count Value
Cycle count value captured together with SWV.
0x00-3F Captured cycle count value</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SWV</name>
                  <description>Stop Watch Value
On a rising/falling edge (as configured via TTOCN.SWP) at the Stop Watch Trigger pin m_ttcan_swt, when TTOCN.SWS is != '00' and TTIR.SWE is '0', the actual time value as selected
by TTOCN.SWS (cycle, local, global) is copied to SWV and TTIR.SWE will be set to '1'. Capturing of the next stop watch value is enabled by resetting TTIR.SWE.
0x0000-FFFF Captured Stop Watch value</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCSM</name>
              <description>TT Cycle Sync Mark</description>
              <addressOffset>0x140</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>CSM</name>
                  <description>Cycle Sync Mark
The Cycle Sync Mark is measured</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>RXFTOP_CTL</name>
            <description>Receive FIFO Top control</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>F0TPE</name>
                <description>FIFO 0 Top Pointer Enable.
This enables the FIFO top pointer logic to set the FIFO Top Address (FnTA) and message word counter.
This logic is also disabled when the IP is being reconfigured (CCCR.CCE=1).
When this logic is disabled a Read from RXFTOP0_DATA is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>F1TPE</name>
                <description>FIFO 1 Top Pointer Enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_STAT</name>
            <description>Receive FIFO 0 Top Status</description>
            <addressOffset>0x1A0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F0TA</name>
                <description>Current FIFO 0 Top Address.
This is a pointer to the next word in the message buffer defined by the FIFO Start Address (FnSA), Get Index (FnGI), the FIFO message size (FnDS) and the message word counter (FnMWC)
FnTA = FnSA + FnGI * msg_size[FnDS] + FnMWC</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_DATA</name>
            <description>Receive FIFO 0 Top Data</description>
            <addressOffset>0x1A8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F0TD</name>
                <description>When enabled (F0TPE=1) read data from MRAM at location FnTA. This register can have a read side effect if the following conditions are met:
- M_TTCAN not being reconfigured (CCCR.CCE=0)
- FIFO Top Pointer logic is enabled (FnTPE=1)
- FIFO is not empty (FnFL!=0)
The read side effect is as follows:
- if FnMWC pointed to the last word of the message (as indicated by FnDS) then the corresponding message index (FnGI) is automatically acknowledge by a write to FnAI
- FnMWC is incremented (or restarted if FnMWC pointed to the last word of the message)
- the FIFO top address FnTA is incremented (with FIFO wrap around)
When this logic is disabled (F0TPE=0) a Read from this register returns undefined data.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_STAT</name>
            <description>Receive FIFO 1 Top Status</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F1TA</name>
                <description>See F0TA description</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_DATA</name>
            <description>Receive FIFO 1 Top Data</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F1TD</name>
                <description>See F0TD description</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CTL</name>
          <description>Global CAN control register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>STOP_REQ</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_OFF</name>
              <description>MRAM off
0= Default MRAM on (with MRAM retained in DeepSleep).
1= Switch MRAM off (not retained) to save power. Before setting this bit all the CAN channels have to be powered down using the STOP_REQ/ACK bits.
When the MRAM is off any access attempt to it is considered an address error (as if MRAM_SIZE=0).
After switching the MRAM on again software needs to allow for a certain power up time before MRAM can be used, i.e. before STOP_REQ can be de-asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Global CAN status register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STOP_ACK</name>
              <description>Clock Stop Acknowledge for each TTCAN IP.
These bits are directly driven by m_ttcan_clkstop_ack of each TTCAN IP.
When this bit is set the corresponding TTCAN IP clocks will be gated off, except HCLK will enabled for each AHB write</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0_CAUSE</name>
          <description>Consolidated interrupt0 cause register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT0</name>
              <description>Show pending m_ttcan_int0 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1_CAUSE</name>
          <description>Consolidated interrupt1 cause register</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT1</name>
              <description>Show pending m_ttcan_int1 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CTL</name>
          <description>Time Stamp control register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Time Stamp counter prescale value.
When enabled divide the Host clock (HCLK) by PRESCALE+1 to create Time Stamp clock ticks.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Counter enable bit
0 = Count disabled. Stop counting up and keep the counter value
1 = Count enabled. Start counting up from the current value</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CNT</name>
          <description>Time Stamp counter value</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>The counter value of the Time Stamp Counter.
When enabled this counter will count Time Stamp clock ticks from the pre-scaler.
When written this counter and the pre-scaler will reset to 0 (write data is ignored).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x42820000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300400F</resetValue>
          <resetMask>0x9303D70F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
'0': Internally clocked mode
'1': Externally clocked mode

In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.

The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.

Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>This field specifies the clocking for the SCB block
'0': Internally clocked mode
'1': externally clocked mode
 In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.

Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).

In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1').
In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not separated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_WIDTH</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>8-bit FIFO data elements.
This mode provides the biggest amount of FIFO entries, but  TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 7].</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>16-bit FIFO data elements.
TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 15].</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>32-bit FIFO data elements.
This mode provides the smallest amount of FIFO entries, but TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH can be in a range of [0, 31].</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>Inter-Integrated Circuits (I2C) mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>Serial Peripheral Interface (SPI) mode.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>Universal Asynchronous Receiver/Transmitter (UART) mode.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EC_ACCESS</name>
              <description>EC_ACCESS is used to enable I2CS_EC or SPIS_EC access to internal EZ memory.
1: enable clk_scb
0: disable clk_scb

Before going to deepsleep this field should be set to 1.
when waking up from DeepSleep power mode, and PLL is locked (clk_scb is at expected frequency), this filed should be set to 0.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
Generally when this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).

Specific to SPI master case,  when SCB is idle,  below registers can be changed without disabling SCB block,
      TX_CTRL
      TX_FIFO_CTRL
      RX_CTRL
      RX_FIFO_CTRL
      SPI_CTRL.SSEL,</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address).

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR).

This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transfer.

For SPI, the field is '1' when slave mode is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000010</resetValue>
          <resetMask>0x8F017F3F</resetMask>
          <fields>
            <field>
              <name>SSEL_CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled individual data frame transfers are not necessarily separated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.

When continuous transfers are not enabled individual data frame transfers are always separated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured in master mode, or MOSI is captured in slave mode.

When '0', the default applies,
for Motorola as determined by CPOL and CPHA,
for Texas Instruments on the falling edge of SCLK(CPOL is '0' and CPHA is '1'),
for National Semiconductors on the rising edge of SCLK(CPOL is '0' and CPHA is '0').

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later).
for master, applicable to all Motorola, TI and National Semiconductors flavors, and CPOL/CPHA timing mdoes.
for slave, applicable to Motorola flavor only, and CPHA=0 timing modes only, and internally-clocked mode only.

Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_SETUP_DEL</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_HOLD_DEL</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_INTER_FRAME_DEL</name>
              <description>N/A</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': No local loopback
'1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconductors submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>Selects one of the four incoming/outgoing SPI slave select signals:
- 0: Slave 0, SSEL[0].
- 1: Slave 1, SSEL[1].
- 2: Slave 2, SSEL[2].
- 3: Slave 3, SSEL[3].
SCB block should be disabled when changes are made to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TX_CTRL</name>
          <description>SPI transmitter control</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10030</resetMask>
          <fields>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0').</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSI_IDLE_HIGH</name>
              <description>SPI master MOSI output level when SELECT output inactive,
0: retain the level of last data bit
1: change to high,
   (MOSI level is high, before the first data bit time, and after data bit time, defined SSEL/SCLK driving edge with CPOL/CPHA)</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RX_CTRL</name>
          <description>SPI receiver control</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x130</resetMask>
          <fields>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0').</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins).
0: Loopback is not enabled
1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>Standard UART submode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0x10F7777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of half bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.

Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle time between data frames and the data frame value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails.
When '0', received data is sent to the RX FIFO.
When '1', received data is dropped and lost.
Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behavior when an error is detected in a start or stop period.
When '0', received data is sent to the RX FIFO.
 When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minimum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HDRXEN</name>
              <description>N/A</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_LEVEL</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least significant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal:
'0': RTS is active low;
'1': RTS is active high;

During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal
'0': CTS is active low ;
'1': CTS is active high;</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal by the UART transmitter:
'0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.

in slave mode, this field is used to define number of clk_scb cycles for tSU-DAT timing (from ACK/NACK/data ready, to SCL rising edge (released from I2C slave clock stretching))</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>This field is used during an address match or general call address in internally clocked mode
Only used when:
 - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).

For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
       1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK.
       2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode).
- 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>Only used when:
- non EZ mode
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode.
When '0', no loopback
When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1000035</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2CS_IC_BUSY</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HS_MODE</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>for I2C master, the NACKed byte should be properly received. it write  the data byte, before ACK/NACK decision.

When '1', attempt to transmit a negative acknowledgement (NACK).
if the reciever FIFO is full (the received data byte cannot be written), it stretch SCL(extend SCL low phase) until the receiver FIFO changes to not full, to write the last byte, then send out NACK.

When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'.
 I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x107</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_TX_ONES_ON_EMPTY</name>
              <description>When '1', attempt to send ones when TX_FIFO is empty.

Once hardware starts to send ones, it will continue send ones until NACK is received, regardless of TX_FIFO status (even if new data is written into TX_FIFO).

This bit is used to avoid stretching SCL, which is not expected for some master devices.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_STRETCH_HS</name>
              <description>When '1', attempt to stretch SCL at time t1, SCL falling edge after 'START, Master-code, NACK' pattern is detected.

When I2C_CTRL.HS_ENABLED is set, it should be set; after wakeup from DeepSleep power mode, it should also be set.

When INTR_S.I2C_HS_ENTER triggers, firmware configure clk_scb to meet I2C Hs-mode timing requirements, then firmware can clear this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Enable for 50ns glitch filter on SDA input
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Enable for 50ns glitch filter on SCL input
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to guarantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to guarantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to guarantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
'0': 0 ns.
'1': 50 ns (filter 0 enabled).
'2': 100 ns (filters 0 and 1 enabled).
'3': 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STRETCH_CTRL</name>
          <description>I2C stretch control</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>STRETCH_THRESHOLD</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STRETCH_STATUS</name>
          <description>I2C stretch status</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x13F</resetMask>
          <fields>
            <field>
              <name>STRETCH_COUNT</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STRETCH_DETECTED</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC_DETECTED</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STRETCHING</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL_HS</name>
          <description>I2C control for High-Speed mode</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x88</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>HOVS_HS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOVS_HS</name>
              <description>N/A</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HS_ENABLED</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20107</resetValue>
          <resetMask>0x3011F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width, depending on CTRL.MEM_WIDTH.
DATA_WIDTH + 1 is the amount of bits in a transmitted data frame.
This number does not include start, parity and stop bits.
For UART mode, the valid range is [3, 8].
For SPI, the valid range is [3, 31].
For I2C the only valid value is 7.
In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN</name>
              <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
'0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
'1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').

The open drain mode is supported for:
- UART mode, 'uart_tx' IO cell.
- SPI mode, 'spi_miso' IO cell.

this bit is not applicable to I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN_SCL</name>
              <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
'0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.

'1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').

this bit is applicable to I2C SCL only.
I2C SDA always work in open-drain mode.

this is not applicable to M0S8, which does not need special control in SCB for open-drain drive mode.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event INTR_TX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is transmitted next (when the protocol state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used.

A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x31F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width, depending on CTRL.MEM_WIDTH.
DATA_WIDTH + 1 is the expected amount of bits in received data frame.
This number does not include start, parity and stop bits.
For UART mode, the valid range is [3, 8].
For SPI, the valid range is [3, 31].
For I2C the only valid value is 7.
In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptibility to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event INTR_RX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR  (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.

When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read silent</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only used when CTRL.EC_AM_MODE is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.

Only used when CTRL.EC_AM_MODE is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event.

Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.

The Firmware should clear the TX FIFO, to re-do this transfer.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>entered I2C Hs-mode, at time t1, SCL falling edge after 'START, 8-bit master code (0000_1XXX), NACK' sequence.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>exited I2C Hs-mode, after STOP detection.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>N/A</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x42840000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB2</name>
      <baseAddress>0x42850000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB3</name>
      <baseAddress>0x42860000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB4</name>
      <baseAddress>0x42870000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB5</name>
      <baseAddress>0x42C00000</baseAddress>
    </peripheral>
    <peripheral>
      <name>TCPWM0</name>
      <description>S40 Timer/Counter/PWM</description>
      <headerStructName>TCPWM</headerStructName>
      <baseAddress>0x42A00000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>1048576</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>3</dim>
          <dimIncrement>65536</dimIncrement>
          <name>GRP[%s]</name>
          <description>Group of counters</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <dim>8</dim>
            <dimIncrement>256</dimIncrement>
            <name>CNT[%s]</name>
            <description>Timer/Counter/PWM Counter Module</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CTRL</name>
              <description>Counter control register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xF0</resetValue>
              <resetMask>0xFFF7FFFF</resetMask>
              <fields>
                <field>
                  <name>AUTO_RELOAD_CC0</name>
                  <description>Specifies switching of the CC0 and buffered CC0 values. This field has a function in TIMER, QUAD (QUAD_RANGE0_CMP, QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.
Timer, QUAD, SR modes:
'0': never switch.
'1': switch on a compare match 0 event.
PWM, PWM_DT, PWM_PR modes:
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_CC1</name>
                  <description>Specifies switching of the CC1 and buffered CC1 values. This field has a function in TIMER, QUAD (QUAD_RANGE0_CMP, QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.
Timer, QUAD, SR modes:
'0': never switch.
'1': switch on a compare match 1 event.
PWM, PWM_DT, PWM_PR modes:
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_PERIOD</name>
                  <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM and PWM_DT modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.

In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to select the index / wrap-around capture function.
'0': Captures on index (reload) event. The counter value is copied to the PERIOD register on an index (reload) event.
'1': Captures when COUNTER equals 0 or 0xffff. The counter value is copied to the PERIOD register when COUNTER equals 0 or 0xffff.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_LINE_SEL</name>
                  <description>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values. This field has a function in PWM and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH_UP_EN</name>
                  <description>Enables / disables the compare match 0 event generation (COUNTER equals CC0 register) when counting up (STATUS.DOWN = 0) in CNT_UPDN1/2 mode.
'0': compare match 0 event generation disabled when counting up
'1': compare match 0 event generation enabled when counting up

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH_DOWN_EN</name>
                  <description>Enables / disables the compare match 0 event generation (COUNTER equals CC0 register) when counting down (STATUS.DOWN = 1) in CNT_UPDN1/2 mode.
'0': compare match 0 event generation disabled when counting down
'1': compare match 0 event generation enabled when counting down

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH_UP_EN</name>
                  <description>Enables / disables the compare match 1 event generation (COUNTER equals CC0 register) when counting up (STATUS.DOWN = 0) in CNT_UPDN1/2 mode.
'0': compare match 1 event generation disabled when counting up
'1': compare match 1 event generation enabled when counting up

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH_DOWN_EN</name>
                  <description>Enables / disables the compare match 1 event generation (COUNTER equals CC0 register) when counting down (STATUS.DOWN = 1) in CNT_UPDN1/2 mode.
'0': compare match 1 event generation disabled when counting down
'1': compare match 1 event generation enabled when counting down

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_IMM_KILL</name>
                  <description>Specifies whether the kill event immediately deactivates the 'line_out' and 'line_compl_out' signals or with the next module clock ('active count' pre-scaled 'clk_counter').
'0': synchronous kill activation. Deactivates the 'line_out' and 'line_compl_out' signals with the next module clock ('active count' pre-scaled 'clk_counter').
'1': immediate kill activation. Immediately deactivates the 'dt_line_out' and 'dt_line_compl_out' signals.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_STOP_ON_KILL</name>
                  <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_SYNC_KILL</name>
                  <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'line_out' and 'line_compl_out' signals immediately. 'Line_out' and 'Line_compl_out' will be enable at the next terminal count event (synchronous kill) after kill event is inactive. In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET.

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWAP_ENABLE</name>
                  <description>Specifies whether swapping mechanism between CC0 and buffered CC0, CC1 and buffered CC1, PERIOD and buffered PERIOD, DT and buffered DT are disabled
'0': swap is disable
'1': swap is enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_DISABLE_MODE</name>
                  <description>Specifies the behavior of the PWM outputs 'line_out' and 'line_compl_out' while the TCPWM counter is disabled (CTRL.ENABLED='0') or stopped.

Note: The output signal of this selection can be further modified by the immediate kill logic and line_out polarity settings (CTRL.QUAL_ENCODING_MODE).</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The behavior is the same is in previous mxtcpwm (version 1).

When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are NOT driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).
Note: This is realized by driving the TCPWM output 'line_out_en' to 0.

When the counter is stopped upon a stop event the PWM outputs are deactivated (to the polarity defined by CTRL.KILL_LINE_POLARITY).</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RETAIN</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM.
When the counter is disabled or stopped upon a stop event the PWM outputs are retained (keep their previous levels).
While the counter is disabled or stopped the PWM outputs can be changed via LINE_SEL (when parameter GRP_SMC_PRESENT = 1).</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>L</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM.
When the counter is disabled or stopped upon a stop event the PWM output 'line_out' is driven as a fixed '0' and the PWM output 'line_compl_out' is driven as a fixed '1'.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM.
When the counter is disabled or stopped upon a stop event the PWM output 'line_out' is driven as a fixed '1' and the PWM output 'line_compl_out' is driven as a fixed '0'.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>PWM_TC_SYNC_KILL_DT</name>
                  <description>Specifies TC synchronour DT kill behavior:
'1': TC synchronous DT kill mode: the kill event disables the 'line_out' and 'line_compl_out' signals at the next terminal count event and till the next terminal count event (synchronous 3 kill). If dead time is enabled, output get disables after the tc event + dead time. 'Line_out' and 'line_comp_out' get enable at next tc event after input input is inactive
In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.

'0': TC synchronous DT kill mode: Disable

This field has a function in PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_SYNC_KILL_DT</name>
                  <description>Specifies synchronous DT kill behavior:
'1': synchronous DT kill mode: the kill event disables the 'line_out' immediately whereas 'line_compl_out' signals will be disable after dead time till the next terminal count event (synchronous DT kill). 'Line_out' and 'line_compl_out' get enable at next tc event after kill input is inactive.
In synchronous DT kill mode, STOP_EDGE should  be RISING_EDGE.

'0': synchronous DT kill mode: Disable

This field has a function in PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UP_DOWN_MODE</name>
                  <description>Determines counter direction.

In QUAD mode this field acts as QUAD_RANGE_MODE field selecting between different counter range, reload value and compare / capture behavior.</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>COUNT_UP</name>
                      <description>Count up (to PERIOD). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. A terminal count event is generated when the counter changes from a state in which COUNTER equals PERIOD.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_DOWN</name>
                      <description>Count down (to '0'). An underflow event is generated when  the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_UPDN1</name>
                      <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_UPDN2</name>
                      <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0' AND when the counter changes from a state in which COUNTER equals PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>ONE_SHOT</name>
                  <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>QUAD_ENCODING_MODE</name>
                  <description>In QUAD mode this field selects the quadrature encoding mode (X1/X2/X4) or the Up / Down rotary counting mode.
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'line_out' and 'line_compl_out'.  Inversion is the last step in generation of 'line_out' and 'line_compl_out'; i.e. a disabled output line 'line_out' has the value QUAD_ENCODING_MODE[0] and a disabled output line 'line_compl_out' has the value QUAD_ENCODING_MODE[1].
In TIMER mode, QUAD_ENCODING_MODE[1:0] is used to enable count up/down based on falling edges, rising edge or level of external capture0 event.</description>
                  <bitRange>[21:20]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>X1</name>
                      <description>X1 encoding (QUAD mode)
This encoding is identical with an up / down counting functionality of the following way: Rising edges of input phiA increment or decrement the counter depending on the state of input phiB (direction input).</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>X2</name>
                      <description>X2 encoding (QUAD mode)</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>X4</name>
                      <description>X4 encoding (QUAD mode)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UP_DOWN</name>
                      <description>Up / Down rotary counting mode. Input phiA increments the counter, input phiB decrements the counter. The trigger edge detection settings apply.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DITHEREN</name>
                  <description>When '0', dithering is disabled</description>
                  <bitRange>[23:22]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>PERIOD_DITHEN</name>
                      <description>Period dithering is enabled</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DUTY_DITHEN</name>
                      <description>Duty dithering is enabled</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PER_DUTY_DITHEN</name>
                      <description>Period and Duty dithering is enabled</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>MODE</name>
                  <description>Counter mode.</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TIMER</name>
                      <description>Timer mode</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CAPTURE</name>
                      <description>Capture mode</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>QUAD</name>
                      <description>Quadrature mode

Different encoding modes can be selected by QUAD_ENCODING_MODE including up/down count functionality.
Different counter range, reload value and capture behavior can be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>Pulse width modulation (PWM) mode. HRPWM feature is supported in this mode through HRPWM_CTRL register.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_DT</name>
                      <description>PWM with deadtime insertion mode. HRPWM feature is supported in this mode through HRPWM_CTRL register.</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_PR</name>
                      <description>Pseudo random pulse width modulation</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SR</name>
                      <description>Shift register mode.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>KILL_LINE_POLARITY</name>
                  <description>In PWM and  PWM_DT modes, these two bits can be used to invert 'line_out' and 'line_compl_out' during kill mode</description>
                  <bitRange>[28:27]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>KILL_LINE_OUT_POLARITY</name>
                      <description>When bit 0 is '1', inverts the suppressed 'line_out' during KILL (PWM/PWM_DT/PWM_DISABLE modes).
In the debug mode the safe state of the line_out is defined by this bit value.
 1 - line_out will be high
 0 - line_out will be low</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>KILL_LINE_COMPL_OUT_POLARITY</name>
                      <description>When bit 1 is '1', inverts the suppressed 'line_comp_out' during KILL (PWM/PWM_DT/PWM_DISABLE modes).
In the debug mode the safe state of the line_compl_out is defined by this bit value.
 1 - line_compl_out will be high
 0 - line_compl_out will be low</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DBG_SUS_EN</name>
                  <description>Specifies the counter behavior in debug mode when suspend is enabled
'0': The counter operation continues in debug mode as given by bit DBG_FREEZE_EN
'1': The counter operation freezes in debug mode  depending on DBG_FREEZE_EN value; when = '0', Counter Freeze after roll over (tc event) and enters safe state; when ='1', Counter Freeze immediately  and enters safe state and running bit to be made ='0'.

Safet state values are defined on line_out and line_compl_out by the corressponding kill_line_out_polarity and kill_line_compl_out_polarity</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBG_FREEZE_EN</name>
                  <description>Specifies the counter behavior in debug mode.
'0': The counter operation depends on DBG_SUS_EN value, when ='0', counter operation continues; when ='1', Counter Freeze after roll over (tc event) and enters safe state.
'1': The counter operation freezes in debug mode depending on DBG_SUS_EN value; when='0', Counter Freeze; when ='1', Counter Freeze immediately  and enters safe state and running bit to be made ='0'.

Safet state values are defined on line_out and line_compl_out by the corressponding kill_line_out_polarity and kill_line_compl_out_polarity</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Counter enable.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_IN_SEL, TR_IN_EDGE_SEL, TR_PWM_CTRL and TR_OUT_SEL register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_out0' and tr_out1').
- the counter's line outputs ('line_out' and 'line_compl_out').</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STATUS</name>
              <description>Counter status register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x20</resetValue>
              <resetMask>0xFFFF8FFF</resetMask>
              <fields>
                <field>
                  <name>DOWN</name>
                  <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC0_READ_MISS</name>
                  <description>When '0', CPU did not miss reading capture0 event information
When '1', CPU miss reading past capture0 event information</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC1_READ_MISS</name>
                  <description>When '0', CPU did not miss reading capture1 event information
When '1', CPU miss reading past capture1 event information</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>KILL_STATUS</name>
                  <description>When '0', There is no kill event in pwm, pwm_dt ,pwm_pr ,sr operation
When '1', There is kill event currently active in  pwm, pwm_dt ,pwm_pr ,sr operation</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_CAPTURE0</name>
                  <description>Indicates the actual level of the selected capture 0 trigger.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_COUNT</name>
                  <description>Indicates the actual level of the selected count trigger.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_RELOAD</name>
                  <description>Indicates the actual level of the selected reload trigger.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_STOP</name>
                  <description>Indicates the actual level of the selected stop trigger.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_START</name>
                  <description>Indicates the actual level of the selected start trigger.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_CAPTURE1</name>
                  <description>Indicates the actual level of the selected capture 1 trigger.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINE_OUT</name>
                  <description>Indicates the actual level of the PWM line output signal.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINE_COMPL_OUT</name>
                  <description>Indicates the actual level of the complementary PWM line output signal.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RUNNING</name>
                  <description>When '0', the counter is NOT running. When '1', the counter is running.

This field is used to indicate that the counter is running after a start/reload event and that the counter is stopped after a stop event.
When a running counter operation is paused in debug state (see CTRL.DBG_PAUSE) then the RUNNING bit is still '1'.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DT_CNT_L</name>
                  <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion (8bit dead time counter or low byte of 16-bit dead time counter).</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DT_CNT_H</name>
                  <description>High byte of 16-bit dead time counter. In PWM_DT mode, this counter is used for dead time insertion.
In all other modes, this field has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8bit wide and the only the field DT_CNT_L is used as dead time counter.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>COUNTER</name>
              <description>Counter count register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COUNTER</name>
                  <description>16-bit / 32-bit counter value. It is advised to not write to this field when the counter is running.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC0</name>
              <description>Counter compare/capture 0 register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.  In compare mode 6 LSBs  is used  for HRPWM generation when HRPWM is enabled.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC0_BUFF</name>
              <description>Counter buffered compare/capture 0 register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>Additional buffer for counter CC register. In compare mode 6 LSBs  is used  for HRPWM generation when HRPWM is enabled.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC1</name>
              <description>Counter compare/capture 1 register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.  In compare mode 6 LSBs  is used  for HRPWM generation when HRPWM is enabled.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC1_BUFF</name>
              <description>Counter buffered compare/capture 1 register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>Additional buffer for counter CC1 register.  In compare mode 6 LSBs  is used  for HRPWM generation when HRPWM is enabled.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PERIOD</name>
              <description>Counter period register</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.  In PWM and PWM_DT mode 6 LSBs given by are used  for HRPWM generation when HRPWM is enabled.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PERIOD_BUFF</name>
              <description>Counter buffered period register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Additional buffer for counter PERIOD register.

In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit represents a tap of the shift register which can be feed back to the MSB via an XOR tree.
Examples for GRP_CNT_WIDTH = 16:
- Maximum length 16bit LFSR
  - polynomial x^16 + x^14 + x^13 + x^11 + 1
  - taps 0,2,3,5 -&gt; PERIOD = 0x002d
  - period is 2^16-1 = 65535 cycles
- Maximum length 8bit LFSR:
  - polynomial x^8 + x^6 + x^5 + x^4 + 1
  - taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)
  - period is 2^8-1 = 255 cycles

In SR mode PERIOD_BUFF defines which tap of the shift register generates the PWM output signals. For a delay of n cycles (from capture event to PWM output) the bit CNT_WIDTH-n should be set to '1'. For a shift register function only one tap should be use, i.e. a one-hot value must be written to PERIOD_BUFF. If multiple bits in PERIOD_BUFF are set then the taps are XOR combined.  In PWM and PWM_DT mode 6 LSBs given by are used  for HRPWM generation when HRPWM is enabled.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LINE_SEL</name>
              <description>Counter line selection register</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT_SEL</name>
                  <description>Selects the source for the output signal 'line_out'. Default setting is the PWM signal 'line'. Other settings are useful for Stepper Motor Control.
This field has a function in PWM, PWM_PR, and PWM_DT modes only.

Note: The output signal of this selection can be further modified by the stop / kill logic and line_out polarity setting (CTRL.KILL_LINE_OUT_POLARITY).</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>L</name>
                      <description>fixed '0'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>fixed '1'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>PWM signal 'line'</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_INV</name>
                      <description>inverted PWM signal 'line'</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The output 'line_out' is not driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).

Note: This is realized by driving the output 'line_out_en' to 0.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>MOTIF</name>
                      <description>The source for PWM signal conditioning comes from MOTIF modulation output control signals. 'line_out' can be set to '0' , '1' or PWM.</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>COMPL_OUT_SEL</name>
                  <description>Selects the source for the output signal 'line_compl_out'. Default setting is the inverted PWM signal 'line'. Other settings are useful for Stepper Motor Control.
This field has a function in PWM, PWM_PR and PWM_DT modes only.

Note: The output signal of this selection can be further modified by the stop / kill logic and line_compl_out polarity setting (CTRL.KILL_LINE_COMPL_OUT_POLARITY).</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>L</name>
                      <description>fixed '0'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>fixed '1'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>PWM signal 'line'</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_INV</name>
                      <description>inverted PWM signal 'line'</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The output 'line_compl_out' is not driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).

Note: This is realized by driving the output 'line_compl_out_en' to 0.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>MOTIF</name>
                      <description>The source for PWM signal conditioning comes from MOTIF modulation output control signals. 'line_compl_out' can be set to '0' , '1' or PWM.</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>LINE_SEL_BUFF</name>
              <description>Counter buffered line selection register</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT_SEL</name>
                  <description>Buffer for LINE_SEL.OUT_SEL.
Can be exchanged with LINE_SEL.LINE_OUT_SEL on a terminal count event with an actively pending switch event.

This field has a function in PWM, PWM_PR and PWM_DT modes only.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COMPL_OUT_SEL</name>
                  <description>Buffer for LINE_SEL.COMPL.OUT_SEL.
Can be exchanged with LINE_SEL.LINE_COMPL_OUT_SEL on a terminal count event with an actively pending switch event.

This field has a function in PWM, PWM_PR and PWM_DT modes only.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DT</name>
              <description>Counter PWM dead time register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DT_LINE_OUT_L</name>
                  <description>In PWM_DT mode, this field is used to determine the low byte of the dead time before activating the PWM line output signal 'line_out': amount of dead time cycles in the counter clock domain.

Note: This field determines the low byte of the 16-bit dead time before activating 'line_out' when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by this DT_LINE_OUT_L field is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_OUT_H</name>
                  <description>In PWM_DT mode, this field is used to determine the high byte of the dead time before activating the PWM line output signal 'line_out': amount of dead time cycles in the counter clock domain.
In all other modes, this field  has no effect.   In PWM_DT mode 6 LSBs given by are used  for HRPWM generation when HRPWM is enabled.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_COMPL_OUT</name>
                  <description>In PWM_DT mode, this field is used to determine the dead time before activating the complementary PWM line output signal 'line_compl_out': amount of dead time cycles in the counter clock domain.
In all other modes, this field  has no effect.   In PWM_DT mode 6 LSBs given by are used  for HRPWM generation when HRPWM is enabled.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DT_BUFF</name>
              <description>Counter buffered PWM dead time register</description>
              <addressOffset>0x34</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DT_LINE_OUT_L</name>
                  <description>Buffer for DT.DT_LINE_OUT_L register
Data will shadow transfer to DT.DT_LINE_OUT_L on a terminal count event with an actively pending switch event when CTRL.SWAP_ENABLE is set to 0.

In PWM_DT mode, the data in this field will be shadow transfer to DT.DT_LINE_OUT_L to determine the low byte of the dead time

Note: This field determines the low byte of the 16-bit dead time buffer when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time buffer is only 8 bit wide.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_OUT_H</name>
                  <description>Buffer for DT.DT_LINE_OUT_H register
Data will shadow transfer to DT.DT_LINE_OUT_H on a terminal count event with an actively pending switch event when CTRL.SWAP_ENABLE is set to 0.

In PWM_DT mode, the data in this field will be shadow transfer to DT.DT_LINE_OUT_H to determine the high byte of the dead time. In PWM_DT mode 6 LSBs given by are used  for HRPWM generation when HRPWM is enabled.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise, the dead time buffer is only 8 bit wide</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_COMPL_OUT</name>
                  <description>Buffer for DT.DT_LINE_COMPL_OUT register
Data will shadow transfer to DT.DT_LINE_COMPL_OUT on a terminal count event with an actively pending switch when CTRL.SWAP_ENABLE is set to 0.

In PWM_DT mode, the data in this field will be shadow transfer to DT.DT_LINE_COMPL_OUT

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise, the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used.   In PWM_DT mode 6 LSBs given by are used  for HRPWM generation when HRPWM is enabled.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PS</name>
              <description>Counter prescalar register</description>
              <addressOffset>0x38</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>PS_DIV</name>
                  <description>Select the pre-scaling of the selected counter clock. If HRPWM is intended to be used for the counter output, this value shall be set to default '0' else the HRPWM feature will not work.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DIVBY1</name>
                      <description>Pre-scaling of the selected counter clock. Divide by 1</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY2</name>
                      <description>Pre-scaling of the selected counter clock. Divide by 2</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY4</name>
                      <description>Pre-scaling of the selected counter clock. Divide by 4</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY8</name>
                      <description>Pre-scaling of the selected counter clock. Divide by 8</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY16</name>
                      <description>Pre-scaling of the selected counter clock. Divide by 16</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY32</name>
                      <description>Pre-scaling of the selected counter clock. Divide by 32</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY64</name>
                      <description>Pre-scaling of the selected counter clock. Divide by 64</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY128</name>
                      <description>Pre-scaling of the selected counter clock. Divide by 128</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_CMD</name>
              <description>Counter trigger command register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3D</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0</name>
                  <description>SW capture 0 trigger. When written with '1', a capture 0 trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.ENABLED, the field is immediately set to '0'.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD</name>
                  <description>SW reload trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP</name>
                  <description>SW stop trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>START</name>
                  <description>SW start trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAPTURE1</name>
                  <description>SW capture 1 trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_SEL0</name>
              <description>Counter input trigger selection register 0</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0_SEL</name>
                  <description>Selects one of the up to 256 input triggers as a capture0 trigger. Input trigger 0 is always '0' and input trigger 1 is always '1'. If existing, the one-to-one trigger inputs 'tr_one_cnt_in' (different to each counter) are selected by setting 2 and above. The settings above are used for the general purpose trigger inputs 'tr_all_cnt_in' connected to all counters selected.
In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COUNT_SEL</name>
                  <description>Selects one of the 256 input triggers as a count trigger.
In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.

Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the counter is externally triggered ( COUNT_SEL &gt; 1), an external trigger will be required for each TR_CMD to execute. For example, a write to TR_CMD.START will not start the counter until the trigger selected by COUNT_SEL asserts. The next trigger will increment the counter since the counter is now running. This goes for all TR_CMD fields.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD_SEL</name>
                  <description>Selects one of the 256 input triggers as a reload trigger.
In QUAD mode, this is the index or revolution pulse. In these modes, it will update the counter with 0x8000 (counter midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP_SEL</name>
                  <description>Selects one of the 256 input triggers as a stop trigger.
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_SEL1</name>
              <description>Counter input trigger selection register 1</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>START_SEL</name>
                  <description>Selects one of the 256 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAPTURE1_SEL</name>
                  <description>Selects one of the 256 input triggers as a capture 1 trigger.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_EDGE_SEL</name>
              <description>Counter input trigger edge selection register</description>
              <addressOffset>0x4C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFF</resetValue>
              <resetMask>0xFFF</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0_EDGE</name>
                  <description>A capture 0 event will copy the counter value into the CC0 register.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>COUNT_EDGE</name>
                  <description>A counter event will increase or decrease the counter by '1'.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>RELOAD_EDGE</name>
                  <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>STOP_EDGE</name>
                  <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>START_EDGE</name>
                  <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CAPTURE1_EDGE</name>
                  <description>A capture 1 event will copy the counter value into the CC1 register.</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_PWM_CTRL</name>
              <description>Counter trigger PWM control register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFF</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>CC0_MATCH_MODE</name>
                  <description>Determines the effect of a compare match 0 event (COUNTER equals CC0 register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC0 register should be set to '0'. For a 100 percent duty cycle, the counter CC0 register should be set to larger than the counter PERIOD register.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OVERFLOW_MODE</name>
                  <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UNDERFLOW_MODE</name>
                  <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CC1_MATCH_MODE</name>
                  <description>Determines the effect of a compare match 1 event (COUNTER equals CC1 register) on the 'line_out' output signals.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_OUT_SEL</name>
              <description>Counter output trigger selection register</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT0</name>
                  <description>Selects one of the internal events to generate the output trigger 0. Default setting selects the terminal count event.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OVERFLOW</name>
                      <description>Overflow event</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UNDERFLOW</name>
                      <description>Underflow event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TC</name>
                      <description>Terminal count event (default selection)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_MATCH</name>
                      <description>Compare match 0 event</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC1_MATCH</name>
                      <description>Compare match 1 event</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LINE_OUT</name>
                      <description>PWM output signal 'line_out'</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_CC1_MATCH</name>
                      <description>Compare match 0 event or Compare match 1 event</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Disabled</name>
                      <description>Output trigger disabled.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OUT1</name>
                  <description>Selects one of the internal events to generate the output trigger 1. Default setting selects the compare match 0 event.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OVERFLOW</name>
                      <description>Overflow event</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UNDERFLOW</name>
                      <description>Underflow event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TC</name>
                      <description>Terminal count event</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_MATCH</name>
                      <description>Compare match 0 event (default selection)</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC1_MATCH</name>
                      <description>Compare match 1 event</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LINE_OUT</name>
                      <description>PWM output signal 'line_out'</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_CC1_MATCH</name>
                      <description>Compare match 0 event or Compare match 1 event</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Disabled</name>
                      <description>Output trigger disabled.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR</name>
              <description>Interrupt request register</description>
              <addressOffset>0x70</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Counter matches CC0 register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Counter matches CC1 register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_SET</name>
              <description>Interrupt set request register</description>
              <addressOffset>0x74</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASK</name>
              <description>Interrupt mask register</description>
              <addressOffset>0x78</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASKED</name>
              <description>Interrupt masked request register</description>
              <addressOffset>0x7C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LFSR</name>
              <description>LFSR register</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7FFFF</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>PLFSR</name>
                  <description>PLFSR register.
PLFSR defines pseudo-random value for period.
SW need to be initialized to non 0 (seed value) before dithering is enabled
MSB of PLFSR will be the sign polarity. The magnitude of the randomness to be added to period is in the range of -2^(N-1) to 2^(N-1)-1 where N is the width of the PLFSR register</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DLFSR</name>
                  <description>DLFSR register.
DLFSR defines pseudo-random value for CC0/CC1.
SW need to be initialized to non 0 (seed value) before dithering is enabled
MSB of DLFSR will be the sign polarity. The magnitude of the randomness to be added to CC0/CC1 is in the range of -2^(N-1) to 2^(N-1)-1 where N is the width of the DLFSR register.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LIMITER</name>
                  <description>Limiter register.
It defines the magnitude of the pseudo-random value to be added to period/CC0/CC1.
PLFSR[7]/DLFSR[7] is the sign polarity</description>
                  <bitRange>[18:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>Limit_1</name>
                      <description>When Limit_1 is '1', the PLFSR[0]/DLFSR[0] is magnitude of the value to be added to period/CC0/CC1</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Limit_2</name>
                      <description>When Limit_2 is '1', the PLFSR[1:0]/DLFSR[1:0] is magnitude of the value to be added to period/CC0/CC1</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Limit_3</name>
                      <description>When Limit_3 is '1', the PLFSR[2:0]/DLFSR[2:0] is magnitude of the value to be added to period/CC0/CC1</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Limit_4</name>
                      <description>When Limit_4 is '1', the PLFSR[3:0]/DLFSR[3:0] is magnitude of the value to be added to period/CC0/CC1</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Limit_5</name>
                      <description>When Limit_5 is '1', the PLFSR[4:0]/DLFSR[4:0] is magnitude of the value to be added to period/CC0/CC1</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Limit_6</name>
                      <description>When Limit_6 is '1', the PLFSR[5:0]/DLFSR[5:0] is magnitude of the value to be added to period/CC0/CC1</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Limit_7</name>
                      <description>When Limit_7 is '1', the PLFSR[6:0]/DLFSR[6:0] is magnitude of the value to be added to period/CC0/CC1</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <dim>8</dim>
              <dimIncrement>4</dimIncrement>
              <name>ONE_GF[%s]</name>
              <description>Glitch filter register for one to one trigger</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>GF_DEPTH</name>
                  <description>Select the glitch filter depth</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DEPTHX0</name>
                      <description>Glitch filter is turned off</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DEPTHX1</name>
                      <description>Glitch filter depth is set to 1 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DEPTHX2</name>
                      <description>Glitch filter depth is set to 2 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DEPTHX4</name>
                      <description>Glitch filter depth is set to 4 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DEPTHX8</name>
                      <description>Glitch filter depth is set to 8 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DEPTHX16</name>
                      <description>Glitch filter depth is set to 16 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DEPTHX32</name>
                      <description>Glitch filter depth is set to 32 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DEPTHX64</name>
                      <description>Glitch filter depth is set to 64 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>GFPS_DIV</name>
                  <description>Select the glitch filter pre-scaling of the selected counter clock</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>GFPS_DIVBY1</name>
                      <description>Glitch filter pre-scaling of the selected counter clock. Divide by 1</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GFPS_DIVBY2</name>
                      <description>Glitch filter pre-scaling of the selected counter clock. Divide by 2</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GFPS_DIVBY4</name>
                      <description>Glitch filter pre-scaling of the selected counter clock. Divide by 4</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GFPS_DIVBY8</name>
                      <description>Glitch filter pre-scaling of the selected counter clock. Divide by 8</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_ONE_SYNC_BYPASS</name>
              <description>Sync bypass register for one to one trigger</description>
              <addressOffset>0xA4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>SYNC_BYPASS</name>
                  <description>When set='1', bypass the sync stage for the corresponding one to one trigger</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HRPWM_CTRL</name>
              <description>Counter control register for HRPWM feature</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x79</resetMask>
              <fields>
                <field>
                  <name>HRPWM_EN</name>
                  <description>When '0' HRPWM feature is bypass, when '1' HRPWM feature is enabled. When enabled HRPWM feature is only available in PWM and PWM_DT mode. In other modes this bit will have no effect and HRPWM feature remain bypass</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_IN_CC0_EN</name>
                  <description>When '1' parallel data path to register CC0 is active and bypass CC0 and CC0_BUFF register.
When this is set to 1, the data from data_in_cc0 get transfered immediately to the cc0 register.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DATA_IN_CC1_EN</name>
                  <description>When '1' parallel data path to register CC1 is active and bypass CC1 and CC1_BUFF register.
When this is set to 1, the data from data_in_cc1 get transfered immediately to the cc1 register.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FREQ_SEL</name>
                  <description>Selects the frequency of operation of HRPWM feature. Microtick is adjusted based on this information. These bits specifies the frequency of CLK_OUT from TCPWM counter. CLK_OUT = CLK_PERI = CLK_HF3</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FREQ_SELX0</name>
                      <description>CLK_OUT = 160MHz</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FREQ_SELX1</name>
                      <description>CLK_OUT = 200 MHz</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FREQ_SELX2</name>
                      <description>CLK_OUT = 240 MHz</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FREQ_SELX3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>TR_ALL_GF</name>
          <description>Glitch filter module for group trigger</description>
          <addressOffset>0x00080000</addressOffset>
          <register>
            <dim>254</dim>
            <dimIncrement>4</dimIncrement>
            <name>ALL_GF[%s]</name>
            <description>Glitch filter register for All Group Triggers</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>GF_DEPTH</name>
                <description>Select the glitch filter depth</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DEPTHX0</name>
                    <description>Glitch filter is turned off</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DEPTHX1</name>
                    <description>Glitch filter depth is set to 1 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DEPTHX2</name>
                    <description>Glitch filter depth is set to 2 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DEPTHX4</name>
                    <description>Glitch filter depth is set to 4 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DEPTHX8</name>
                    <description>Glitch filter depth is set to 8 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DEPTHX16</name>
                    <description>Glitch filter depth is set to 16 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DEPTHX32</name>
                    <description>Glitch filter depth is set to 32 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DEPTHX64</name>
                    <description>Glitch filter depth is set to 64 x GFPS_DIVBYx of prescalar, where x is 1, 2, 4, 8</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GFPS_DIV</name>
                <description>Select the glitch filter pre-scaling of the selected counter clock</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GFPS_DIVBY1</name>
                    <description>Glitch filter pre-scaling of the selected counter clock. Divide by 1</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GFPS_DIVBY2</name>
                    <description>Glitch filter pre-scaling of the selected counter clock. Divide by 2</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GFPS_DIVBY4</name>
                    <description>Glitch filter pre-scaling of the selected counter clock. Divide by 4</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GFPS_DIVBY8</name>
                    <description>Glitch filter pre-scaling of the selected counter clock. Divide by 8</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>TR_ALL_SYNC_BYPASS</name>
          <description>Glitch filter module for group trigger</description>
          <addressOffset>0x00090000</addressOffset>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_ALL_SYNC_BYPASS[%s]</name>
            <description>Trigger Sync bypass for group trigger</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SYNC_BYPASS</name>
                <description>When set='1', bypass the sync stage for the corresponding group trigger</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>3</dim>
          <dimIncrement>16384</dimIncrement>
          <name>MOTIF_GRP[%s]</name>
          <description>Trigger Sync bypass for group trigger</description>
          <addressOffset>0x000A0000</addressOffset>
          <cluster>
            <name>MOTIF</name>
            <description>MOTIF Module</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>PCONF</name>
              <description>Global control register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFC62C0FF</resetMask>
              <fields>
                <field>
                  <name>ENABLE</name>
                  <description>MOTIF enable
0 - MOTIF disabled.
1 - MOTIF enabled.
Enable MOTIF shall have the following effect: MOTIF clock is enabled,MOTIF registers are out of reset.
Disable MOTIF shall have the following effect:MOTIF clock is gated, MOTIF non-retention registers get reset to default value, MOTIF retention register do not get reset,
Output events get reset to default value, Interrupt output get reset to default value
Modulation output get reset to default value.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FSEL</name>
                  <description>Function Selector</description>
                  <bitRange>[2:1]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>HALLEN</name>
                      <description>Hall Sensor Mode enabled</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>QUADEN</name>
                      <description>Quadrature Decoder Mode enabled</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>STANDM</name>
                      <description>stand-alone Multi-Channel Mode enabled</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>QDSTAN</name>
                      <description>Quadrature Decoder and stand-alone Multi_x0002_Channel Mode enabled</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>QDCM</name>
                  <description>Position Decoder Mode selection
This field selects if the Position Decoder block is in Quadrature Mode or Direction Count Mode. In Quadrature mode, the position encoder is providing the phase signals, while in Direction Count Mode is providing a clock and a direction signal.
0 - Position encoder is in Quadrature Mode
1 - Position encoder is in Direction Count Mode.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HIDG</name>
                  <description>Idle generation enable
Setting this field to 1 disables the generation of the IDLE signal that forces a clear on the Multi-Channel pattern and run bit.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MCUE</name>
                  <description>Multi-Channel Pattern SW update enable
0 - Multi-Channel pattern update is controlled via HW
1 - Multi-Channel pattern update is controlled via SW</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FTS</name>
                  <description>Fault Hall event Selection</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>WHE_OR_MP</name>
                      <description>OR between wrong hall event and module pin (MOTIFx.EWHE)</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>WHE</name>
                      <description>Wrong Hall Event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>MODPIN</name>
                      <description>Module Pin - MOTIFx.EWHE</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CHEC</name>
                  <description>Correct Hall Event Clear selection</description>
                  <bitRange>[15:14]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>WHE_OR_MP</name>
                      <description>OR between wrong hall event and module pin (MOTIFx.EWHE)</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>WHE</name>
                      <description>Wrong Hall Event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>MODPIN</name>
                      <description>Module Pin - MOTIFx.EWHE</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>SPES</name>
                  <description>Edge selector for the sampling trigger
This field selects which edge is used of the selected MOTIFx.HSD signal to trigger a sample of the Hall inputs.
0 - Rising edge
1 - Falling edge</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MSES</name>
                  <description>Multi-Channel pattern update mset trigger edge
0 - The signal used to enable a mset pattern update is active on the rising edge
1 - The signal used to enable a mset pattern update is active on the falling edge</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MSYES</name>
                  <description>Multi-Channel pattern update msync trigger edge
0 - The signal used to enable a msync pattern update is active on the rising edge
1 - The signal used to enable a msync pattern update is active on the falling edge</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWIE</name>
                  <description>External Wrong Hall Event enable
0 - External wrong hall event emulation signal, MOTIFx.EWHE, is disabled
1 - External wrong hall event emulation signal, MOTIFx.EWHE, is enabled.</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWIL</name>
                  <description>External Wrong Hall Event active level
0 - MOTIFx.EWHE signal is active HIGH
1 - MOTIFx.EWHE signal is active LOW</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LPC</name>
                  <description>Low Pass Filters Configuration</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>LP_DISABLE</name>
                      <description>Low pass filter disabled</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP1</name>
                      <description>Low pass of 1 clock cycle</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP2</name>
                      <description>Low pass of 2 clock cycle</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP4</name>
                      <description>Low pass of 4 clock cycle</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP8</name>
                      <description>Low pass of 8 clock cycle</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP16</name>
                      <description>Low pass of 16 clock cycle</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP32</name>
                      <description>Low pass of 32 clock cycle</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP64</name>
                      <description>Low pass of 64 clock cycle</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP128</name>
                      <description>Low pass of 128 clock cycle</description>
                      <value>8</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP256</name>
                      <description>Low pass of 256 clock cycle</description>
                      <value>9</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP512</name>
                      <description>Low pass of 512 clock cycle</description>
                      <value>10</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LP1024</name>
                      <description>Low pass of 1024 clock cycle</description>
                      <value>11</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD12</name>
                      <description>N/A</description>
                      <value>12</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD13</name>
                      <description>N/A</description>
                      <value>13</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD14</name>
                      <description>N/A</description>
                      <value>14</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD15</name>
                      <description>N/A</description>
                      <value>15</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>PSUS</name>
              <description>Suspend Configuration</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>SUS</name>
                  <description>MOTIF Mode Suspend Config
This field controls the entering in suspend for the MOTIF module.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>REQ_IGN</name>
                      <description>Suspend request ignored</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>STOP</name>
                      <description>Stop immediately</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SUS_IDX</name>
                      <description>In quad mode and quad with stand-alone mode, suspend in the next index occurrence (QDCM =0).
In any other mode. Stop immediately. When QDCM =1, it is considered as in other mode.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SUS_PHA</name>
                      <description>In quad mode and quad with stand-alone mode (QDCM =0), suspend in the next phase (PhaseA or PhaseB)
In any other mode. Stop immediately. When QDCM =1, it is considered as in other mode.</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>STOP_RST</name>
                      <description>Stop immediately. Multi-Channel pattern is set to the reset value.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SUS_SYN</name>
                      <description>Suspend with the synchronization of the PWM signal. Multi-Channel pattern is set to the reset value at the same time of the synchronization.
In quad mode, stop immediately.</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD1</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD2</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>PRUNS</name>
              <description>MOTIF run bit set</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>SRB</name>
                  <description>Set Run bit
0- Stop MOTIF. Writing an 0 into this bit stop the MOTIF and bring the state machine back to idle.
1- Start MOTIF. Writing an 1 into this bit sets the run bit of the module.A rising edge triggers the start machine.

When a Fault event is detected, the Hardware can clear this bit to '0' and stop MOTIF as saftey mechanisim. The SW needs to re-configure MOTIF and start again MOTIF later.

if LUT mode is enabled, LUTEN=1. The hardware can clear this bit to '0' and stop MOTIF as saftey mechanism when previous pattern is detected or when pattern mismatch is detetcted.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PRUN</name>
              <description>MOTIF run bit status</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>RB</name>
                  <description>Run Bit
This field indicates if the module is in running or IDLE state.
0 - IDLE
1 - Running</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HIST</name>
              <description>Hall Inputs Sample Trigger</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>write-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>HIS</name>
                  <description>Hall Inputs Sample
Writting this bitfield with 1, will trigger a sample of the current hall inputs into the PDBG.HSP field. The hardware will automatically clear the HIS to 0. The sample of the hall inputs can be done even when the run bit of the module is not set. Requesting a sample when the module is running/normal operation, may incurr in wrong behavior.
Read always returns 0.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>write-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HMEC</name>
              <description>Hall Mode Extra Config</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>HDBP</name>
                  <description>Hall Sensor Debounce Stage Bypass
Setting this bitfield to 1, will disable the usage of the debounce delay pins, MOTIFx.HSD. This means that after the low pass filter, the hall inputs are immediately sampled and compared against the expected and current patterns.
0 - The hall inputs are only sampled after a valid transition at the MOTIFx.HSD pin.
1 - The hall inputs are sampled after the filtering stage and the MOTIFx.HSD pin usage is disabled.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPPE</name>
                  <description>Previous Pattern Compare Enable
Setting this bitfield to 1, enables the compare logic between the sampled hall input values and the previous hall pattern - HALP.HPP. This will be used together with the comparison of the current and expected pattern to generate a wrong hall event.
0 - Comparison between previous pattern and sampled pattern not used to generate a wrong hall event.
1 - Comparison between previous pattern and sampled pattern used to generate a wrong hall event.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HALP</name>
              <description>Hall Current and Expected patterns</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x73F</resetMask>
              <fields>
                <field>
                  <name>HCP</name>
                  <description>Hall Current Pattern
if LUTEN = 0, this field contains the Hall Current pattern. This field is updated with the HALPS.HCPS value every time that a correct hall event occurs.

if LUTEN = 1, this field contains the Hall Current pattern. This field is updated with the Hall LUT value every time that a correct hall event occurs.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>HEP</name>
                  <description>Hall Expected Pattern
if LUTEN = 0, this field contains the Hall Expected pattern. This field is updated with the HALPS.HEPS values every time that a correct hall event occurs.

if LUTEN = 1, this field contains the Hall Expected pattern. This field is updated with the Hall LUT value every time that a correct hall event occurs.</description>
                  <bitRange>[5:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>HPP</name>
                  <description>Hall Previous Pattern
if LUTEN = 0, this field contains the Hall Previous pattern. This field is updated with the HALPS.HPPS values every time that a correct hall event occurs.

if LUTEN = 1, this field contains the Hall Previous pattern. This field is updated with the Hall LUT value every time that a correct hall event occurs.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HALPS</name>
              <description>Hall Current and Expected shadow patterns</description>
              <addressOffset>0x34</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x73F073F</resetMask>
              <fields>
                <field>
                  <name>HCPS0</name>
                  <description>Shadow Hall Current Pattern - HLUT0
if LUTEN = 0, this field contains the next Hall Current pattern value. This field is set on the HALP.HCP field every time that a correct hall event occurs.
HCPS[0] - Hall Input 1
HCPS[1] - Hall Input 2
HCPS[2] - Hall Input 3

if HLUTEN = 1 bitfield works as LUT position 0</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HEPS1</name>
                  <description>Shadow Hall expected Pattern - HLUT1
if LUTEN = 0, this field contains the next Hall Expected pattern. This field is set on the HALP.HEP field every time that a correct hall event occurs.
HEPS[0] - Hall Input 1
HEPS[1] - Hall Input 2
HEPS[2] - Hall Input 3

if LUTEN = 1 bitfield works as LUT position 1</description>
                  <bitRange>[5:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPPS2</name>
                  <description>Shadow Hall Previous Pattern - HLUT2
if LUTEN = 0, this field contains the next Hall Previous pattern. This field is set on the HALP.HPP field every time that a correct hall event occurs.
HPPS[0] - Hall Input 1
HPPS[1] - Hall Input 2
HPPS[2] - Hall Input 3

if LUTEN = 1 bitfield works as LUT position 2</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HLUT3</name>
                  <description>Hall LUT data position 3
if LUTEN = 0 bitfield not used
if LUTEN = 1 bitfield works as LUT position 3</description>
                  <bitRange>[18:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HLUT4</name>
                  <description>Hall LUT data position 4
if LUTEN = 0 bitfield not used
if LUTEN = 1 bitfield works as LUT position 4</description>
                  <bitRange>[21:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HLUT5</name>
                  <description>Hall LUT data position 5
if LUTEN = 0 bitfield not used
if LUTEN = 1 bitfield works as LUT position 5</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HOSC</name>
              <description>Hall Sensor Output Config</description>
              <addressOffset>0x38</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7777777</resetMask>
              <fields>
                <field>
                  <name>EDN</name>
                  <description>Edge Detection Event Output Node
This field selects to which output the event signalizing that an modification on the Hall Inputs is forward.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NO_FWD</name>
                      <description>Signal is not forward to any output</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD0</name>
                      <description>Forward to MOTIFx.OUT0</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD1</name>
                      <description>Forward to MOTIFx.OUT1</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD2</name>
                      <description>Forward to MOTIFx.OUT2</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD3</name>
                      <description>Forward to MOTIFx.OUT3</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD4</name>
                      <description>Forward to MOTIFx.OUT4</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD5</name>
                      <description>Forward to MOTIFx.OUT5</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD6</name>
                      <description>Forward to MOTIFx.OUT6</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CHN</name>
                  <description>Correct Hall Event Output Node
This field selects to which output the event signalizing that a correct hall event has been detected is forward.
Same coding description as the EDN field.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IDN</name>
                  <description>Idle/Wrong Hall Event Output Node
This field selects to which output the OR event between the external fault pins,
MOTIFx.EWHE, and the Wrong Hall Event is forward.
Same coding description as the EDN field.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HSTN</name>
                  <description>Start Event Output Node
This field selects to which output the event signalizing that the run bit was set is forward.
Same coding description as the EDN field.</description>
                  <bitRange>[14:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SPN</name>
                  <description>Stop Counters/Pattern Mismatch Event Output Node
This field selects to which output the event signalizing that the Hall Sensor inputs do not match the current, the expected or the previous pattern is forward.
Same coding description as the EDN field.</description>
                  <bitRange>[18:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CPN</name>
                  <description>Current Pattern Match Event Output Node
This field selects to which output the event signalizing that the Hall Sensor inputs match the current pattern is forward.
Same coding description as the EDN field.</description>
                  <bitRange>[22:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PPN</name>
                  <description>Previous Pattern Match Event Output Node
This field selects to which output the event signalizing that the Hall Sensor inputs match the previous pattern is forward.
Same coding description as the EDN field.</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCM</name>
              <description>Multi-Channel Mode Pattern</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0xAAAAAAAA</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MCMP</name>
                  <description>Multi-Channel Pattern
This field contains the Multi-Channel Pattern that is going to be applied to the Multi-Channel outputs, MOTIFx.MOUT[31:0].

if MLUTEN=0, this field is updated with the value of the MCSM.MCMPS every time that a Multi-Channel pattern update is triggered.

if MLUTEN=1, this bitfield is updated with the value select in MLUT0,1,2,3,4,5. These values get transferred to MOTIFx.MOUT[31:0]</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCSM</name>
              <description>Multi-Channel Mode shadow Pattern LUT0</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MCMPS</name>
                  <description>Shadow Multi-Channel Pattern
if MLUTEN=0,
This field contains the next Multi-Channel Pattern. Every time that a Multi-Channel pattern transfer is triggered, this value is passed into the field MCM.MCMP.

if MLUTEN=1,
This field contains the Multi-Channel Pattern stored in Look-up table position 0. If Multi-Channel pattern transfer is triggered and MLUT0 is selected, this value is passed into field MCM.MCMP[31:0]</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCMS</name>
              <description>Multi-Channel Mode Control set</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>write-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>MNPS</name>
                  <description>Multi-Channel Pattern Update Enable Set
Writing a 1 into this field enables the Multi-Channel pattern update (sets the MCMF.MSS bit). The update is not done immediately due to the fact that the trigger that synchronizes the update with the PWM is still needed.
A read always returns 0.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>STHR</name>
                  <description>Hall Pattern Shadow Transfer Request
Writing a 1 into this field leads to an immediate update of the fields HALP.HCP, HALP.HEP and HALP.HPP.
A read always returns 0.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>STMR</name>
                  <description>Multi-Channel Shadow Transfer Request
Writing a 1 into this field leads to an immediate update of the field MCM.MCMP.
A read always returns 0.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>write-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCMC</name>
              <description>Multi-Channel Mode Control clear</description>
              <addressOffset>0x4C</addressOffset>
              <size>32</size>
              <access>write-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>MNPC</name>
                  <description>Multi-Channel Pattern Update Enable Clear
Writing a 1 into this field clears the MCMF.MSS bit.
A read always returns 0.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>MPC</name>
                  <description>Multi-Channel Pattern clear
Writing a 1 into this field clears the Multi-Channel Pattern value with the content of the MCPF register.
A read always returns 0.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>write-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCMF</name>
              <description>Multi-Channel Mode flag status</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>MSS</name>
                  <description>Multi-Channel Pattern update status
This field indicates if the Multi-Channel pattern is ready to be updated or not. When this field is set, the Multi-Channel pattern is updated when the triggering signal, selected from the MOTIFx.MSYNC, becomes active.
0 - Update of the Multi-Channel pattern is set
1 - Update of the Multi-Channel pattern is not set</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCPF</name>
              <description>Multi-Channel Pattern Fault</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MCFV</name>
                  <description>Multi-Channel Fault Value
This register contains the value that is going to be loaded into the Multi-Channel patter, MCP register, and fed consequently to the outputs, MOTIFx.MOUT[31:0].
This value is loaded into the MCP register whenever a fault is detected (via a wrong hall event or one of the MOTIFx.EWHEy pins) or whenever the software requests a pattern clear via the MCMC.MPC bitfield.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MOSC</name>
              <description>Multi-Channel Output Config</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x777</resetMask>
              <fields>
                <field>
                  <name>PUN</name>
                  <description>Pattern Update Event Output Node
This field selects to which output, the event signalizing that a Multi-Channel pattern update is enabled (MSS is set), is forward.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NO_FWD</name>
                      <description>Signal is not forward to any output</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD0</name>
                      <description>Forward to MOTIFx.OUT0</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD1</name>
                      <description>Forward to MOTIFx.OUT1</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD2</name>
                      <description>Forward to MOTIFx.OUT2</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD3</name>
                      <description>Forward to MOTIFx.OUT3</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD4</name>
                      <description>Forward to MOTIFx.OUT4</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD5</name>
                      <description>Forward to MOTIFx.OUT5</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD6</name>
                      <description>Forward to MOTIFx.OUT6</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>SHN</name>
                  <description>Update Sync Event Output Node
This field selects to which output, the event that is used to synchronize the Multi-Channel Pattern update has happened after MSYNC edge detected, is forward.
Same coding description as the PUN field.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MSTN</name>
                  <description>Start Event Output Node
This field selects to which output the event signalizing that the run bit was set is forward.
Same coding description as the PUN field.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>QDC</name>
              <description>Quadrature Decoder Configuration</description>
              <addressOffset>0x60</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x333F13F</resetMask>
              <fields>
                <field>
                  <name>PALS</name>
                  <description>Phase A Level selector
0 - Phase A is active HIGH
1 - Phase A is active LOW</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PBLS</name>
                  <description>Phase B Level selector
0 - Phase B is active HIGH
1 - Phase B is active LOW</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PHS</name>
                  <description>Phase signals swap
0 - Phase A is the leading signal for clockwise rotation
1 - Phase B is the leading signal for clockwise rotation</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INDS</name>
                  <description>Index Signal Level selector
0 - Index signal is active HIGH
1 - Index signal is active LOW</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ICM</name>
                  <description>Index Marker generations control
This field controls the generation of the index marker that is linked PRGINDX event.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NO_IDX</name>
                      <description>No index marker generation</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>1ST_IDX</name>
                      <description>Only first index occurrence generated</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ALL_IDX</name>
                      <description>All index occurrences generated</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DVAL</name>
                  <description>Current rotation direction
0 - Counterclockwise rotation
1 - Clockwise rotation</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PAEM</name>
                  <description>Phase A Edge Mode
Note: Selecting BOTH in one PHASE, implies that other PHASE should not be RISE/FALL. Selecting NONE in one PHASE, implies that other PHASE should not be NONE. Invalid combination can lead to unexpected behavior</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>BOTH</name>
                      <description>clock is decoded on rising and falling edges of the Phase A signal</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RISE</name>
                      <description>clock is decoded on rising edge of the Phase A signal</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALL</name>
                      <description>clock is decoded on falling edge of the Phase A signal</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NONE</name>
                      <description>Clock is not decoded for PHASE A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>PBEM</name>
                  <description>Phase B Edge Mode
Note: Selecting BOTH in one PHASE, implies that other PHASE should not be RISE/FALL. Selecting NONE in one PHASE, implies that other PHASE should not be NONE. Invalid combination can lead to unexpected behavior</description>
                  <bitRange>[15:14]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>BOTH</name>
                      <description>clock is decoded on rising and falling edges of the Phase B signal</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RISE</name>
                      <description>clock is decoded on rising edge of the Phase B signal</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALL</name>
                      <description>clock is decoded on falling edge of the Phase B signal</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NONE</name>
                      <description>Clock is not decoded for PHASE B</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>PACS</name>
                  <description>Phase A or Clock Selector
Selects which signal is used as Phase A signal if in Quadrature Decoder Mode or as Clock if in Direction Count Mode:</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLE</name>
                      <description>Disabled</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>POSI0</name>
                      <description>POSI0</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>POSI1</name>
                      <description>POSI1</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>POSI2</name>
                      <description>POSI2</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>PBDS</name>
                  <description>Phase B or Direction Selector
Selects which signal is used as Phase B signal if in Quadrature Decoder Mode or as Direction if in Direction Count Mode:</description>
                  <bitRange>[21:20]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLE</name>
                      <description>Disabled</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>POSI0</name>
                      <description>POSI0</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>POSI1</name>
                      <description>POSI1</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>POSI2</name>
                      <description>POSI2</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>IDS</name>
                  <description>Index Selector
Selects which signal is used as Index signal if in Quadrature Decoder Mode:</description>
                  <bitRange>[25:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLE</name>
                      <description>Disabled</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>POSI0</name>
                      <description>POSI0</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>POSI1</name>
                      <description>POSI1</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>POSI2</name>
                      <description>POSI2</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>QOSC</name>
              <description>Quadrature Output Config</description>
              <addressOffset>0x64</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x777777</resetMask>
              <fields>
                <field>
                  <name>QCN</name>
                  <description>Quadrature Clock Event Output Node
This field selects to which output, the quadrature clock (QCLK) event, is forward.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NO_FWD</name>
                      <description>Signal is not forward to any output</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD0</name>
                      <description>Forward to MOTIFx.OUT0</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD1</name>
                      <description>Forward to MOTIFx.OUT1</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD2</name>
                      <description>Forward to MOTIFx.OUT2</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD3</name>
                      <description>Forward to MOTIFx.OUT3</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD4</name>
                      <description>Forward to MOTIFx.OUT4</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD5</name>
                      <description>Forward to MOTIFx.OUT5</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FWD6</name>
                      <description>Forward to MOTIFx.OUT6</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DON</name>
                  <description>Direction Event Output Node
This field selects to which output, the direction signal (QDIR), is forward.
Same coding description as the QCN field.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PCN</name>
                  <description>Period Clock Event Output Node
This field selects to which output, the period clock (PCLK) event, is forward.
Same coding description as the QCN field.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CCN</name>
                  <description>Clear/Capture Event Output Node
This field selects to which output the event signalizing that an index/zero marker was detected, is forward. This can be used as a capture or clear function for a timer, to measure time between index events. internal prgindx
Same coding description as the QCN field.</description>
                  <bitRange>[14:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IXN</name>
                  <description>Index Event Output Node
This field selects to which output the event signalizing that an index/zero marker was detected, is forward. This event is only generated when the index input has been detected and the rotation direction did not change (between two index occurrences). internal indx
Same coding description as the QCN field.</description>
                  <bitRange>[18:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>QSTN</name>
                  <description>Start Event Output Node
This field selects to which output the event signalizing that the run bit was set is forward.
Same coding description as the QCN field.</description>
                  <bitRange>[22:20]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCMEC</name>
              <description>Multi-Channel Extra Config</description>
              <addressOffset>0x68</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x13</resetMask>
              <fields>
                <field>
                  <name>MSBP</name>
                  <description>Multi-Channel Mode Sync Bypass
Setting this bitfield to 1 will dictate that whenever the MCMF.MSS bitfield is 1, a pattern update will occur immediately (without waiting for the sync signal - MOTIFx.MSYNC).
0 - Update of the Multi-Channel pattern is only done after the sync signal is detected - MOTIFx.MSYNC.
1 - Update of the Multi-Channel pattern is done immediately after the MCMF.MSS field is set.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MEBP</name>
                  <description>Multi-Channel Pattern Enable Delay Bypass
Setting this bitfield to 1 will bypass the delay between a Correct Hall Event and the enable of the Multi-Channel Patter update.
0 - Enable of the Multi-Channel Pattern update is only done after the external SET signal is detected - MOTIFx.MSET.
1 - Enable of the Multi-Channel Pattern update is done immediately after a Correct Hall Event is detected - only valid when PCONF.MCUE is 0.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MFCE</name>
                  <description>Multi-Channel Fault Clear Enable
Setting this bitfield to 1 will enable a clear of the Multi-Channel pattern, whenever a Hall Fault Event is detected. The Multi-Channel pattern will be cleared with the value programmed in the MCFV field.
0 - Multi-Channel pattern clear with Hall Fault Event disabled.
1 - Multi-Channel pattern clear with Hall Fault Event enabled.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PFLG</name>
              <description>MOTIF interrupt status</description>
              <addressOffset>0x70</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F17</resetMask>
              <fields>
                <field>
                  <name>CHES</name>
                  <description>Correct Hall Event Status
0 - Correct Hall Event not detected
1 - Correct Hall Event detected</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WHES</name>
                  <description>Wrong Hall Event Status
0 - Wrong Hall Event not detected
1 - Wrong Hall Event detected</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>HIES</name>
                  <description>Hall Inputs Update Status
0 - Transition on the Hall Inputs not detected
1 - Transition on the Hall Inputs detected</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MSTS</name>
                  <description>Multi-Channel pattern shadow transfer status
0 - Shadow transfer not done
1 - Shadow transfer done</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>INDXS</name>
                  <description>Quadrature Index Status
0 - Index event not detected
1 - Index event detected</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ERRS</name>
                  <description>Quadrature Phase Error Status
0 - Phase Error event not detected
1 - Phase Error event detected</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CNTS</name>
                  <description>Quadrature CLK Status
0 - Quadrature clock not generated
1 - Quadrature clock generated</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DIRS</name>
                  <description>Quadrature Direction Change
0 - Change on direction not detected
1 - Change on direction detected</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PCLKS</name>
                  <description>Quadrature Period Clk Status
0 - Period clock not generated
1 - Period clock generated</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CPES</name>
                  <description>Current Pattern Match Status
0 - Equality between Sampled Hall input values and Current Pattern value not detected.
1 - Equality between Sampled Hall input values and Current Pattern value detected.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PPES</name>
                  <description>Previous Pattern Match Status
0 - Equality between Sampled Hall input values and Previous Pattern value not detected.
1 - Equality between Sampled Hall input values and Previous Pattern value detected.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PFLGE</name>
              <description>MOTIF interrupt enable</description>
              <addressOffset>0x74</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F177F17</resetMask>
              <fields>
                <field>
                  <name>ECHE</name>
                  <description>Correct Hall Event Enable
0 - Correct Hall Event interrupt disabled
1 - Correct Hall Event interrupt enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWHE</name>
                  <description>Wrong Hall Event Enable
0 - Wrong Hall Event interrupt disabled
1 - Wrong Hall Event interrupt enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EHIE</name>
                  <description>Hall Input Update Enable
0 - Update of the Hall Inputs interrupt is disabled
1 - Update of the Hall Inputs interrupt is enabled</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EMST</name>
                  <description>Multi-Channel pattern shadow transfer enable
0 - Shadow transfer event interrupt disabled
1 - Shadow transfer event interrupt enabled</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EINDX</name>
                  <description>Quadrature Index Event Enable
0 - Index event interrupt disabled
1 - Index event interrupt enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EERR</name>
                  <description>Quadrature Phase Error Enable
0 - Phase error event interrupt disabled
1 - Phase error event interrupt enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECNT</name>
                  <description>Quadrature CLK interrupt Enable
0 - Quadrature CLK event interrupt disabled
1 - Quadrature CLK event interrupt enabled</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EDIR</name>
                  <description>Quadrature direction change interrupt Enable
0 - Direction change event interrupt disabled
1 - Direction change event interrupt enabled</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPCLK</name>
                  <description>Quadrature Period CLK interrupt Enable
0 - Quadrature Period CLK event interrupt disabled
1 - Quadrature Period CLK event interrupt enabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECPE</name>
                  <description>Current Pattern Match interrupt Enable
0 - Current Pattern Match event interrupt disabled
1 - Current Pattern Match event interrupt enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPPE</name>
                  <description>Previous Pattern Match interrupt Enable
0 - Previous Pattern Match event interrupt disabled
1 - Previous Pattern Match event interrupt enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CHESEL</name>
                  <description>Correct Hall Event Service Request Selector
0 - Correct Hall Event interrupt forward to MOTIFx.SR0
1 - Correct Hall Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WHESEL</name>
                  <description>Wrong Hall Event Service Request Selector
0 - Wrong Hall Event interrupt forward to MOTIFx.SR0
1 - Wrong Hall Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HIESEL</name>
                  <description>Hall Inputs Update Event Service Request Selector
0 - Hall Inputs Update Event interrupt forward to MOTIFx.SR0
1 - Hall Inputs Update Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MSTSEL</name>
                  <description>Multi-Channel pattern Update Event Service Request Selector
0 - Multi-Channel pattern Update Event interrupt forward to MOTIFx.SR0
1 - Multi-Channel pattern Update Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>INDSEL</name>
                  <description>Quadrature Index Event Service Request Selector
0 - Quadrature Index Event interrupt forward to MOTIFx.SR0
1 - Quadrature Index Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ERRSEL</name>
                  <description>Quadrature Phase Error Event Service Request Selector
0 - Quadrature Phase error Event interrupt forward to MOTIFx.SR0
1 - Quadrature Phase error Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CNTSEL</name>
                  <description>Quadrature Clock Event Service Request Selector
0 - Quadrature Clock Event interrupt forward to MOTIFx.SR0
1 - Quadrature Clock Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DIRSEL</name>
                  <description>Quadrature Direction Update Event Service Request Selector
0 - Quadrature Direction Update Event interrupt forward to MOTIFx.SR0
1 - Quadrature Direction Update Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PCLSEL</name>
                  <description>Quadrature Period clock Event Service Request Selector
0 - Quadrature Period clock Event interrupt forward to MOTIFx.SR0
1 - Quadrature Period clock Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CPSEL</name>
                  <description>Current Pattern Match Event Service Request Selector
0 - Current Pattern Match Event interrupt forward to MOTIFx.SR0
1 - Current Pattern Match Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PPSEL</name>
                  <description>Previous Pattern Match Event Service Request Selector
0 - Previous Pattern Match Event interrupt forward to MOTIFx.SR0
1 - Previous Pattern Match Event interrupt forward to MOTIFx.SR1</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SPFLG</name>
              <description>Interrupt set register</description>
              <addressOffset>0x78</addressOffset>
              <size>32</size>
              <access>write-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F17</resetMask>
              <fields>
                <field>
                  <name>SCHE</name>
                  <description>Correct Hall Event flag set
Writing a 1 to this field sets the PFLG.CHES bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>SWHE</name>
                  <description>Wrong Hall Event flag set
Writing a 1 to this field sets the PFLG.WHES bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>SHIE</name>
                  <description>Hall Inputs Update Event flag set
Writing a 1 to this field sets the PFLG.HIES bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>SMST</name>
                  <description>Multi-Channel Pattern shadow transfer flag set
Writing a 1 to this field sets the PFLG.MSTS bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>SINDX</name>
                  <description>Quadrature Index flag set
Writing a 1 to this field sets the PFLG.INDXS bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>SERR</name>
                  <description>Quadrature Phase Error flag set
Writing a 1 to this field sets the PFLG.ERRS bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>SCNT</name>
                  <description>Quadrature CLK flag set
Writing a 1 to this field sets the PFLG.CNTS bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>SDIR</name>
                  <description>Quadrature Direction flag set
Writing a 1 to this field sets the PFLG.DIRS bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>SPCLK</name>
                  <description>Quadrature period clock flag set
Writing a 1 to this field sets the PFLG.PCLKS bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>SCP</name>
                  <description>Current Pattern Match flag set
Writing a 1 to this field sets the PFLG.CPES bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>SPP</name>
                  <description>Previous Pattern Match flag set
Writing a 1B to this field sets the PFLG.PPES bit field. An interrupt pulse is generated.
A read always returns 0.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>write-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RPFLG</name>
              <description>Interrupt clear register</description>
              <addressOffset>0x7C</addressOffset>
              <size>32</size>
              <access>write-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F17</resetMask>
              <fields>
                <field>
                  <name>RCHE</name>
                  <description>Correct Hall Event flag clear
Writing a 1 to this field clears the PFLG.CHES bit field.
A read always returns 0.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>RWHE</name>
                  <description>Wrong Hall Event flag clear
Writing a 1 to this field clears the PFLG.WHES bit field.
A read always returns 0.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>RHIE</name>
                  <description>Hall Inputs Update Event flag clear
Writing a 1 to this field clears the PFLG.HIES bit field.
A read always returns 0.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>RMST</name>
                  <description>Multi-Channel Pattern shadow transfer flag clear
Writing a 1 to this field clears the PFLG.MSTS bit field.
A read always returns 0.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>RINDX</name>
                  <description>Quadrature Index flag clear
Writing a 1 to this field clears the PFLG.INDXS bit field.
A read always returns 0.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>RERR</name>
                  <description>Quadrature Phase Error flag clear
Writing a 1 to this field clears the PFLG.ERRS bit field.
A read always returns 0.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>RCNT</name>
                  <description>Quadrature CLK flag clear
Writing a 1 to this field clears the PFLG.CNTS bit field.
A read always returns 0.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>RDIR</name>
                  <description>Quadrature Direction flag clear
Writing a 1 to this field clears the PFLG.DIRS bit field.
A read always returns 0.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>RPCLK</name>
                  <description>Quadrature period clock flag clear
Writing a 1 to this field clears the PFLG.PCLKS bit field.
A read always returns 0.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>RCP</name>
                  <description>Current Pattern Match flag clear
Writing a 1 to this field clears the PFLG.CPES bit field.
A read always returns 0.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>write-only</access>
                </field>
                <field>
                  <name>RPP</name>
                  <description>Previous Pattern Match flag clear
Writing a 1 to this field clears the PFLG.PPES bit field.
A read always returns 0.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>write-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCSM1</name>
              <description>Multi-Channel Mode shadow pattern LUT1</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MLUT1</name>
                  <description>Multi-Channel LUT 1
if MLUTEN=0 this bitfield is not used
if MLUTEN=1 this field contains the Multi-Channel Pattern stored in Look-up table position 1. If Multi-Channel pattern transfer is triggered and MLUT1 is selected, this value is passed into the field MCM.MCMP[31:0]</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCSM2</name>
              <description>Multi-Channel Mode shadow pattern LUT2</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MLUT2</name>
                  <description>Multi-Channel LUT 2
if MLUTEN=0 this bitfield is not used
if MLUTEN=1 this field contains the Multi-Channel Pattern stored in Look-up table position 2. If Multi-Channel pattern transfer is triggered and MLUT2 is selected, this value is passed into the field MCM.MCMP[31:0]</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCSM3</name>
              <description>Multi-Channel Mode shadow pattern LUT3</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MLUT3</name>
                  <description>Multi-Channel LUT 3
if MLUTEN=0 this bitfield is not used
if MLUTEN=1 this field contains the Multi-Channel Pattern stored in Look-up table position 3. If Multi-Channel pattern transfer is triggered and MLUT3 is selected, this value is passed into the field MCM.MCMP[31:0]</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCSM4</name>
              <description>Multi-Channel Mode shadow pattern LUT4</description>
              <addressOffset>0x8C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MLUT4</name>
                  <description>Multi-Channel LUT 4
if MLUTEN=0 this bitfield is not used
if MLUTEN=1 this field contains the Multi-Channel Pattern stored in Look-up table position 4. If Multi-Channel pattern transfer is triggered and MLUT4 is selected, this value is passed into the field MCM.MCMP[31:0]</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MCSM5</name>
              <description>Multi-Channel Mode shadow pattern LUT5</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>MLUT5</name>
                  <description>Multi-Channel LUT 5
if MLUTEN=0 this bitfield is not used
if MLUTEN=1 this field contains the Multi-Channel Pattern stored in Look-up table position 5. If Multi-Channel pattern transfer is triggered and MLUT5 is selected, this value is passed into the field MCM.MCMP[31:0]</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CLUT</name>
              <description>Hall Mode LUT config</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>LUTEN</name>
                  <description>HALL LUT enable
Setting this bitfield to 1, will enable the usage of the Hall Look-up table.
0 - Hall LUT disabled, HCPS, HEPS, HPPS are used. HLUT3, HLUT4,HLUT5 not used.
1 - Hall LUT enabled, HCPS, HEPS, HPPS, HLUT3, HLUT4,HLUT5 works as data container for the LUT. Every time that a correct hall event occurs the LUT provides new values to HALP register</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SLUT</name>
              <description>Hall Mode LUT status</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>PTR</name>
                  <description>HALL LUT Pointer status
This field contains the pointer address to HALL LUT current pattern. LUTEN must be set, if  LUTEN is 0, this bitfield is always 0. Valid values are 0,1,2,3,4,5. Invalid values 6,7</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PDBG</name>
              <description>MOTIF Debug Register</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x777F</resetMask>
              <fields>
                <field>
                  <name>QCSV</name>
                  <description>Quadrature Decoder Current state
This field stores the current state of the quadrature decoder state machine. The ready indicates that the state machine has processed the first values present at the MOTIF inputs (this may not be immediate due to the propgation time of the low pass filters - if enabled).
QCSV[0] - Phase B
QCSV[1] - Phase A
QCSV[2] - ready</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QPSV</name>
                  <description>Quadrature Decoder Previous state
This field stores the previous state of the quadrature decoder state machine. The ready indicates that the state machine has processed the first values present at the MOTIF inputs (this may not be immediate due to the propgation time of the low pass filters - if enabled).
QPSV[0] - Phase B
QPSV[1] - Phase A
QPSV[2] - ready</description>
                  <bitRange>[5:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>IVAL</name>
                  <description>Current Index Value</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>HSP</name>
                  <description>Hall Current Sampled Pattern
HSP[0] - Hall Input 1
HSP[1] - Hall Input 2
HSP[2] - Hall Input 3</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LPF0V</name>
                  <description>Low Pass filter 0 valid state
0 - Low pass filter has not output valid data
1 - Low pass filter has output valid data</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LPF1V</name>
                  <description>Low Pass filter 1 valid state
0 - Low pass filter has not output valid data
1 - Low pass filter has output valid data</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LPF2V</name>
                  <description>Low Pass filter 2 valid state
0 - Low pass filter has not output valid data
1 - Low pass filter has output valid data</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PLP0S</name>
              <description>MOTIF Low Pass 0 Status</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>LPP0</name>
                  <description>Actual count of the Low Pass Filter</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PLP1S</name>
              <description>MOTIF Low Pass 1 Status</description>
              <addressOffset>0x108</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>LPP1</name>
                  <description>Actual count of the Low Pass Filter</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PLP2S</name>
              <description>MOTIF Low Pass 2 Status</description>
              <addressOffset>0x10C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>LPP2</name>
                  <description>Actual count of the Low Pass Filter</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPPASS</name>
      <description>Top Level of MCPASS IP</description>
      <baseAddress>0x42B00000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>1048576</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>SARADC</name>
          <description>SAR ADC Core (Calibration and Test)
NOTE: IP must be ENABLED to write and read these registers.  When the block is disabled these registers are reset</description>
          <addressOffset>0x00070000</addressOffset>
          <register>
            <dim>4</dim>
            <dimIncrement>4</dimIncrement>
            <name>CALOFFST[%s]</name>
            <description>SARADC Offset Calibration Values</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F7F7F7F</resetMask>
            <fields>
              <field>
                <name>OFFSET_4N_0</name>
                <description>7-bit signed offset calibration value for sampler 4n + 0</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSET_4N_1</name>
                <description>7-bit signed offset calibration value for sampler 4n + 1</description>
                <bitRange>[14:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSET_4N_2</name>
                <description>7-bit signed offset calibration value for sampler 4n + 2</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OFFSET_4N_3</name>
                <description>7-bit signed offset calibration value for sampler 4n + 3</description>
                <bitRange>[30:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>16</dim>
            <dimIncrement>4</dimIncrement>
            <name>CALLIN[%s]</name>
            <description>SARADC Linearity Calibration Values</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F7F7F7F</resetMask>
            <fields>
              <field>
                <name>LIN9</name>
                <description>7 bit signed linearity calibration value for bit 9 of this sampler</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LIIN10</name>
                <description>7 bit signed linearity calibration value for bit 10 of this sampler</description>
                <bitRange>[14:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LIN11</name>
                <description>7 bit signed linearity calibration value for bit 11 of this sampler</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LIN12</name>
                <description>7 bit signed linearity calibration value for bit 12 of this sampler</description>
                <bitRange>[30:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CALGAINC</name>
            <description>SARADC Coarse-grained Gain Calibration Values</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF0F0F</resetMask>
            <fields>
              <field>
                <name>GAINC3</name>
                <description>Coarse-grained gain calibration value for gain=3 setting
bit 3: SIGN, bits &lt;2:0&gt; : VALUE
0xF =&gt; -7: Voltage correction -14mV
0xE =&gt; -6: Voltage correction -12mV
0xD =&gt; -5: Voltage correction -10mV
0xC =&gt; -4: Voltage correction -8mV
0xB =&gt; -3: Voltage correction -6mV
0xA =&gt; -2: Voltage correction -4mV
0x9 =&gt; -1: Voltage correction -2mV
0x8 == 0x0 =&gt; 0: Voltage correction 0mV
0x1 =&gt; 1: Voltage correction +2mV
0x2 =&gt; 2: Voltage correction +4mV
0x3 =&gt; 3: Voltage correction +6mV
0x4 =&gt; 4: Voltage correction +8mV
0x5 =&gt; 5: Voltage correction +10mV
0x6 =&gt; 6: Voltage correction +12mV
0x7 =&gt; 7: Voltage correction +14mV</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GAINC6</name>
                <description>Coarse-grained gain calibration value for gain=6 setting
see description of GAINC3</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GAINC12</name>
                <description>Coarse-grained gain calibration value for gain=12 setting
see description of GAINC3</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CALGAINF</name>
            <description>SARADC Fine-grained Gain Calibration Values</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F7F7F</resetMask>
            <fields>
              <field>
                <name>GAINF3</name>
                <description>7-bit signed fine-grained gain calibration value for gain=3 setting</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GAINF6</name>
                <description>7-bit signed fine-grained gain calibration value for gain=6 setting</description>
                <bitRange>[14:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GAINF12</name>
                <description>7-bit signed fine-grained gain calibration value for gain=12 setting</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>SAR</name>
          <description>SAR ADC Controller</description>
          <addressOffset>0x00080000</addressOffset>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>SEQ_ENTRY[%s]</name>
            <description>SAR Sequencer Table Entries</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECT_SAMPLER_EN</name>
                <description>These bits enable the 12 direct samplers in this Entry.  When this Entry is triggered, any samplers with a bit set to '1' will be simultaneously sampled, held, and then converted.  There is a 1-1 correspondence between these 12 samplers and the first 12 result channels. Therefore SAR results may be found in SAR_CFG.CHAN_RESULT0 - CHAN_RESULT12

When pseudo differential or PD is enabled in an even channel  (SAR_CFG.CHAN_CFG.DIFF_EN) that sampler/channel it is the positive input of the PD pair, and the corresponding odd channel becomes the negative input. The result is processed and stored as specified in the even channel (e.g. AVG, FIR, RESULT REG,FIFO)</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MUXED_SAMPLER_EN</name>
                <description>These bits enable the 4 muxed samplers in this Entry.  When this Entry is triggered any samplers with a bit set to '1' will be simultaneously sampled, held, and then converted.  The mux setting for these samplers is determined by the following MUX(i)_SEL fields. Each one of these samplers maps to 4 result channels as determined by the mux setting 0,1,2, or 3 in order.
The mapping is:
MUXED_SAMPLER_EN - bit 12 (sampler 12)  CHAN RESULTS are found in SAR_CFG.CHAN_RESULT12,13,14,15
MUXED_SAMPLER_EN - bit 13 (sampler 13)  CHAN RESULTS are found in SAR_CFG.CHAN_RESULT16,17,18,19
MUXED_SAMPLER_EN - bit 14 (sampler 14)  CHAN RESULTS are found in SAR_CFG.CHAN_RESULT20,21,22,23
MUXED_SAMPLER_EN - bit 15 (sampler 15)  CHAN RESULTS are found in SAR_CFG.CHAN_RESULT24,25,26,27

Muxed samplers may also be specified as pseudo differential sampler pairs, but as described in SAR_CFG.CHAN_CFG.DIFF_EN, there are four possible inputs to each sampler in the even odd sampler pairs 12/13 or 14/15.  Set DIFF_EN for the positive input (also configure post processing and storage specification)  and also set MUX(even)_SEL to match this positive selection. To select the negative input, set the correspoing MUX(odd)_SEL.  The odd bits of this field are ignored when the even sampler is enabled for PD.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MUX0_SEL</name>
                <description>These bits control the input mux selection for sampler 12</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MUX1_SEL</name>
                <description>These bits control the input mux selection for sampler 13</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MUX2_SEL</name>
                <description>These bits control the input mux selection for sampler 14</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MUX3_SEL</name>
                <description>These bits control the input mux selection for sampler 15</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_SEL</name>
                <description>Trigger select for this Entry. By default disabled, or select 1 of 8 hardware triggers or AC trigger.    Normally MCPASS internal triggers are PULSE triggers (see INFRA/TR_HW_MODE), however, a LEVEL trigger may also be used, but the trigger event is always on the positive edge of a LEVEL trigger.
Once this ENTRY is triggered, the user must wait for SAR_ENTRY_DONE status to trigger this entry again.  Otherwise a trigger collision status will be set for this ENTRY (see SAR_CFG.SAR_TR_COLLISION and MCPASS_MMIO.MCPASS_INTR)</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TR0</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TR1</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TR2</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TR3</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TR4</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TR5</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TR6</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TR7</name>
                    <description>N/A</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AC</name>
                    <description>N/A</description>
                    <value>9</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAMP_TIME_SEL</name>
                <description>Sample Time Select.  By default there is no additional sample time after the trigger (samplers are transitioned to HOLD state immediately on a trigger event) or select 1 of 3 available Sample Times in SAR_CFG.SAMPLE_TIME registers</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISBALED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAMPLE_TIME_SEL0</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAMPLE_TIME_SEL1</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAMPLE_TIME_SEL2</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIORITY</name>
                <description>This bit selects the priority for this entry.  High Priority samplers ready for conversion witll be processed before Low Priority samplers.
0: Low Priority
1: High Priority

If the application configures a combination of High and Low Priority Entries, depending on the usage demand on the SAR from High Priority Entries, a Low Priority Entry might stay in HOLD state beyond a spec limit (See SAR_CFG.HOLD_VIOLATION and SAR_CFG.HOLD_CNT for more details).  To ensure that the Low priority Entry did not stay in HOLD state beyond this limit, before reading a Low Priority Entry result, check the SAR_CFG.HOLD_VIOLATION status to ensure that the result is within spec.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONT</name>
                <description>This bit enables continuous conversion for this entry.  When this bit is set, this entry will trigger immediately when the SAR is ENABLED, and will be automatically re-triggered when this ENTRY has been completed.

NOTE: Due to this automatic triggering, the TR_SEL field must be set to DISABLED for this ENTRY

A continuous Entry should have sample time (SAMP_TIME_SEL is not DISABLED), otherwise this Entry will be continously triggered and use the majority of the SAR performance bandwidth.  In other words, sample time is the only way to set the periodicity of a continous Entry.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>ENTRY_MUX_SEL_ALIAS[%s]</name>
            <description>SAR Sequencer MUX select alias registers</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF0000</resetMask>
            <fields>
              <field>
                <name>MUX0_SEL</name>
                <description>Update SEQ_ENTRY.MUX0_SEL field
Using this alias register, the user can read/write directly to the associated routing select fields in a given entry, without the need to do a read-modify-write operation on a SEQ_ENTRY register</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MUX1_SEL</name>
                <description>Update SEQ_ENTRY.MUX1_SEL field</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MUX2_SEL</name>
                <description>Update SEQ_ENTRY.MUX2_SEL field</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MUX3_SEL</name>
                <description>Update SEQ_ENTRY.MUX3_SEL field</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <name>CFG</name>
            <description>SAR configuration and result registers</description>
            <addressOffset>0x00000400</addressOffset>
            <register>
              <name>CTRL</name>
              <description>Control register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x177</resetMask>
              <fields>
                <field>
                  <name>VREF_SEL</name>
                  <description>SARADC VREF selection.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>VDDA</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>EXT_REF</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD_2</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD_3</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>LOW_SUPPLY_MODE</name>
                  <description>Low Supply Mode control - set this bit if VDDA supply range &lt; 2.7V</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>Disabled, VDDA supply is &gt;= 2.7V</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ENABLED</name>
                      <description>Enabled, VDDA supply is &lt; 2.7V</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>STARTUP_CAL_OFFSET_EN</name>
                  <description>Calibration Offset on SAR Enable

All selected CAL routines (OFFSET, LINEARITY, GAIN) in this register are run if these bits are set when the AC enables the SAR.  The user must wait for BLOCK_READY (polling or interrupt) at which time SAR CAL and initialization is complete, before starting the application.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ENABLED</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>STARTUP_CAL_LINEARITY_EN</name>
                  <description>Calibration Linearity on SAR Enable</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ENABLED</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>STARTUP_CAL_GAIN_EN</name>
                  <description>Calibrate Gain on SAR Enable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ENABLED</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CHAN_ID_EN</name>
                  <description>FIFO Channel Number Identifier Enable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>When the FIFO is selected for a channel or FIR result (optional), 16-bit result data is stored in FIFO without tagging in the following format
&lt;00000&gt;, &lt;16-bit result&gt;</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ENABLED</name>
                      <description>Result data is stored in FIFO is tagged with channel number identifier and stored as follows
&lt;5-bit chan_num&gt;, &lt;16-bit result&gt;, where the 5-bit chan_num is 0-27 for channel results, and 30, 31 for FIR results</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>SAMP_EN</name>
              <description>Sampler static enable configuration register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>DIRECT_SAMP_EN</name>
                  <description>Static Enables for Direct Samplers.  Must be set if in use by application, otherwise it is OFF and must not be selected in any SAR Entry.

A given SAR Entry is considered invalid if 1) There are no Samplers enabled and 2) For the given set of enabled Samplers, they all must be powered ON with this static setting.  If the Entry is invalid, no action will be taken in the SAR sequencer if this Entry is triggered.</description>
                  <bitRange>[11:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUXED_SAMP_EN</name>
                  <description>Static Enables for Muxed Samplers. Must be set if in use by application, otherwise it is OFF and must not be selected in any SAR Entry.</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAMP_GAIN</name>
              <description>Sampler gain configuration register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SAMP_GAIN</name>
                  <description>Static Sampler Gain
Configure this register BEFORE enabling the SAR, it must be static during SAR operation.
0 = GAIN of 1 (default)
1 = GAIN of 3
2 = GAIN of 6
3 = GAIN of 12
Two bits per sampler:
Sampler0 gain in [1:0]
Sampler1 gain in [3:2]
Sampler2 gain in [5:4]
...
Sampler14 gain in [29:28]
Sampler15 gain in [31:30]

NOTE: If Psuedo Differential (PD) mode is enabled for a given Channel (see CHAN_CFG.DIFFERENTIAL_EN), then the associated samplers in the pseudo differential operation must be configured manually in this register to have the same SAMP_GAIN.
For example if CHAN_CFG0 is set for PD mode, the associated differential samplers 0 and 1 should be set to the same gain.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>3</dim>
              <dimIncrement>4</dimIncrement>
              <name>SAMPLE_TIME[%s]</name>
              <description>Sample Time configuration register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1F</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>SAMPLE_TIME</name>
                  <description>Sample time (aperture) in given by (SAMPLE_TIME+1) clock cycles of CLK_HF/2.  The range is 0..1023, which results in:
1*CLK_HF/2 - 1024 * CLK_HF/2  cycles

There are 3 sample time registers and each ENTRY (SEQ_ENTRY.SAMPLE_TIME_SEL) can select DISABLED if no sample time is needed (see below) or one of these 3 registers if sample time is needed.

WHEN SAMPLE TIME IS NOT REQUIRED:
If 0 sample time is selected in SEQ_ENTRY.SAMPLE_TIME_SEL, this means when the trigger for that ENTRY is asserted, all the channels in that ENTRY are transitioned to HOLD state immediately and are queued for conversion. This scenario works well for DIRECT CHANNELS, because each input has a dedicated sampler which is either sampling, holding for conversion.  Therefore after a given trigger, if the subsequent trigger is spaced out is time greater than or equal to the time required for all ENTRY channels to convert, plus a minimum sample time, no additional sample time (as would be programmed in this register) will be needed.

WHEN SAMPLE TIME IS REQUIRED
In the case of MUXed samplers, sample time is normally required because the routing is switched to the configured selections (SEQ_TABLE.MUXn_SEL) on trigger assertion. In this case minimum sample time is required.  In a special case, however, if the mux selection is fixed and not changing, then it is equivalent to a direct connection, and in that case additional sampling time may not be required.</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>2</dim>
              <dimIncrement>4</dimIncrement>
              <name>FIR_CFG[%s]</name>
              <description>FIR configuration register</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0x70F0011F</resetMask>
              <fields>
                <field>
                  <name>CHANNEL_SEL</name>
                  <description>Select which SAR channel will be the source for a given FIR input.  When a new conversion output is available, the 16-tap FIR calculation is initiated (17 cycles for 16 taps), and a new FIR output is generated.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_0</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_1</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_2</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_3</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_4</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_5</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_6</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_7</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_8</name>
                      <description>N/A</description>
                      <value>9</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_9</name>
                      <description>N/A</description>
                      <value>10</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_10</name>
                      <description>N/A</description>
                      <value>11</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_11</name>
                      <description>N/A</description>
                      <value>12</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_12</name>
                      <description>N/A</description>
                      <value>13</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_13</name>
                      <description>N/A</description>
                      <value>14</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_14</name>
                      <description>N/A</description>
                      <value>15</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_15</name>
                      <description>N/A</description>
                      <value>16</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_16</name>
                      <description>N/A</description>
                      <value>17</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_17</name>
                      <description>N/A</description>
                      <value>18</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_18</name>
                      <description>N/A</description>
                      <value>19</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_19</name>
                      <description>N/A</description>
                      <value>20</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_20</name>
                      <description>N/A</description>
                      <value>21</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_21</name>
                      <description>N/A</description>
                      <value>22</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_22</name>
                      <description>N/A</description>
                      <value>23</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_23</name>
                      <description>N/A</description>
                      <value>24</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_24</name>
                      <description>N/A</description>
                      <value>25</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_25</name>
                      <description>N/A</description>
                      <value>26</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_26</name>
                      <description>N/A</description>
                      <value>27</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CHANNEL_27</name>
                      <description>N/A</description>
                      <value>28</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>WAIT_TAP_INIT</name>
                  <description>Wait for 16 samples before the first output is stored into a FIR_RESULT register or FIFO.  This allows the user to ignore the FIR outputs until the FIR pipeline is initialized.  .</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ENABLED</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>RANGE_SEL</name>
                  <description>Range detection.  Select 1 of the 8 RANGE detection modules</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_0</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_1</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_2</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_3</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_4</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_5</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_6</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_7</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>FIFO_SEL</name>
                  <description>FIFO selections.  Select 1 of the 4 for FIFOs for data storage
There is a global setting for the number of FIFOs to be configured in LPPASS_MMIO/FIFO_CFG/CFG.  If te indicated FIFO in this field is not configured, this setting will be ignored.</description>
                  <bitRange>[30:28]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_0</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_1</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_2</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_3</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <dim>28</dim>
              <dimIncrement>4</dimIncrement>
              <name>CHAN_CFG[%s]</name>
              <description>SAR Channel configuration register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x77F0FF03</resetMask>
              <fields>
                <field>
                  <name>DIFFERENTIAL_EN</name>
                  <description>Differential Enable.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>Single Ended operation</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ENABLED</name>
                      <description>Pseudo Differential operation

NOTE: Averaging (AVG_SEL below) is not available for this channel if Pseudo Differential is enabled. AVG_SEL must be set to the default DISABLED.

POS and NEG inputs are simultaneously sampled, and then subtracted in hardware. Result is stored in the associated POS Channel RESULT reg

Channels 0 - 11:  There are 6 differential (even, odd) pairs.

Example: Setting DIFFERENTIAL_EN in CHAN CFG 0 configures Sampler 0 as the POS input, and then Channel 1/Sampler 1 is automatically set as the NEG input. The result is stored in CHAN_RESULT 0.

Channels 12 - 27:  These are muxed channels which operate with 4 Samplers. so there are two differential pair groups
   Pair 1: CHAN 12-15, Sampler 12 (POS), CHAN 16-19, Sampler 13 (NEG)
   Pair 2: CHAN 20-23, Sampler 14 (POS), CHAN 24-27, Sampler 15 (NEG)
Any channel of the even sampler could be PD-paired with any channel from the odd sampler

Example: Setting DIFFERENTIAL_EN in CHAN_CFG 14, implies that Sampler 12 is the POS input where the SEQ_ENTRY.MUX0_SEL select must be set to 2 in the Entry configuration (see SEQ_ENTRY.MUXED_SAMPLER_EN for this mapping).  Sampler 13 is automatically configured as the NEG input where input selection/routing is controlled by the SEQ_ENTRY.MUX1_SEL .The result is stored in CHAN_RESULT 14.

This setting will be ignored for the NEG input channels 1,3,5,7,9,11, 16-19, 24-28</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>SIGNED</name>
                  <description>Signed Data Option</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>UNSIGNED</name>
                      <description>Result data unsigned</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIGNED</name>
                      <description>Result data is signed (sign extended if needed)</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>RSVD_11_8</name>
                  <description>N/A</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RSVD_15_12</name>
                  <description>N/A</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RANGE_SEL</name>
                  <description>Enable and select a RANGE resource for this channel</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_0</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_1</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_2</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_3</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_4</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_5</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_6</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RANGE_7</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>AVG_SEL</name>
                  <description>Enable averaging for this channel.  This implementation is accumulation only. There is no hardware shift option.  For example, if AVG_2 is selected, the RESULT register (or FIFO) will contain a 13-bit result, for AVG_4 the RESULT register will contain a 14-bit result, etc.</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AVG_2</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AVG_4</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AVG_8</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AVG_16</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD_5</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD_6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD_7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>FIFO_SEL</name>
                  <description>FIFO Select.  Select 1 of the 4 for FIFO data storage.
There is a global setting for the number of FIFOs to be configured in LPPASS_MMIO/FIFO_CFG/CFG.  If te indicated FIFO in this field is not configured, this setting will be ignored.</description>
                  <bitRange>[30:28]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_0</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_1</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_2</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_3</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <dim>8</dim>
              <dimIncrement>4</dimIncrement>
              <name>RANGE_CFG[%s]</name>
              <description>Range detect configuration register.</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>RANGE_COND</name>
                  <description>Range condition select.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>BELOW</name>
                      <description>result &lt; RANGE_LOW</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INSIDE</name>
                      <description>RANGE_LOW &lt;= result &lt; RANGE_HIGH</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ABOVE</name>
                      <description>result &gt; RANGE_HIGH</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>OUTSIDE</name>
                      <description>result &lt; RANGE_LOW || result &gt;= RANGE_HIGH</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <dim>8</dim>
              <dimIncrement>4</dimIncrement>
              <name>RANGE_LOW[%s]</name>
              <description>Range detect low value register.</description>
              <addressOffset>0xD0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>RANGE_LOW</name>
                  <description>Low threshold for range detect
NOTE on unsigned/signed
ADC RESULT RANGE (inclding averaging): If the channel that is selecting a given RANGE is declared as signed (CHAN_CFG.SIGNED), then the RANGE_HIGH and RANGE_LOW will be considered as signed 16-bit values, otherwise they will be considered as unsigned 16-bit values.
FIR RESULT RANGE:The FIR output is considered as signed, therefore the RANGE_HIGH and RANGE_LOW for FIR comparison are always considered as signed 16-bit values.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>8</dim>
              <dimIncrement>4</dimIncrement>
              <name>RANGE_HIGH[%s]</name>
              <description>Range detect high value register.</description>
              <addressOffset>0xF0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>RANGE_HIGH</name>
                  <description>High threshold for range detect
See RANGE_LOW for signed/unsigned usage rules</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>28</dim>
              <dimIncrement>4</dimIncrement>
              <name>CHAN_RESULT[%s]</name>
              <description>Channel result register</description>
              <addressOffset>0x110</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>RESULT</name>
                  <description>SAR conversion working data of the channel. The data is written here if the corresponding bit if RESULT_MASK is set. (default is to write to CHAN_RESULT).  The RESULT_MASK may be cleared if the channel data is targeted for the FIFO.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>2</dim>
              <dimIncrement>4</dimIncrement>
              <name>FIR_RESULT[%s]</name>
              <description>FIR result register</description>
              <addressOffset>0x180</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>RESULT</name>
                  <description>FIR output data. The data is written here if the corresponding bit in RESULT_MASK is set. (default is to write to FIR_RESULT) . The RESULT_MASK may be cleared if the FIR data is targeted for the FIFO.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RESULT_MASK</name>
              <description>Channel result mask</description>
              <addressOffset>0x190</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xCFFFFFFF</resetValue>
              <resetMask>0xCFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CHAN_RESULT_MASK</name>
                  <description>If set (default) the CHAN_RESULT register will be used to store SAR conversion data for a given Entry and the associated ENTRY_DONE Interrupt will be generated.   If this bit isn't set, the channel must be configured to store the result in a FIFO and the ENTRY_DONE Interrupt will not be generated.</description>
                  <bitRange>[27:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIR_RESULT_MASK</name>
                  <description>If set (default) the FIR_RESULT register will be used to store SAR conversion data for a given Entry and the associated ENTRY_DONE Interrupt will be generated.   If this bit isn't set, the channel must be configured to store the result in a FIFO and the ENTRY_DONE Interrupt will not be generated.</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RESULT_UPDATED</name>
              <description>Channel result register status</description>
              <addressOffset>0x194</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xCFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CHAN_RESULT_UPDATED</name>
                  <description>Each bit will be set when the corresponding CHAN_RESULT register is updated with a new result.   Write 1 to clear.</description>
                  <bitRange>[27:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIR_RESULT_UPDATED</name>
                  <description>Each bit will be set when the corresponding FIR_RESULT register is updated with a new result.   Write 1 to clear.</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RANGE_STATUS</name>
              <description>Range status register</description>
              <addressOffset>0x198</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xCFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CHAN_RANGE</name>
                  <description>A given bit in this register will be set if the conversion result (after averaging) of that channel met the condition specified by the selected RANGE registers. Write with '1' to clear bit.</description>
                  <bitRange>[27:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIR_RANGE</name>
                  <description>A given bit in this register will be set if the conversion result (after averaging) of that channel met the condition specified by the selected RANGE registers. Write with '1' to clear bit.</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAR_STATUS</name>
              <description>SAR status register</description>
              <addressOffset>0x19C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000000</resetMask>
              <fields>
                <field>
                  <name>BUSY</name>
                  <description>If high then the SAR is busy with a conversion. This bit is always high when CONTINUOUS is set. Firmware should wait for this bit to be low before putting the SAR in power down.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RESULT_OVERFLOW</name>
              <description>Entry overflow status</description>
              <addressOffset>0x1A0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x300FF</resetMask>
              <fields>
                <field>
                  <name>ENTRY_RESULT_OVF</name>
                  <description>The associated bit is set in this register if the new Entry results are written before the associated SAR_RESULT_INTR/ENTRY_DONE bit has been cleared from the previous trigger.  This bit may be cleared by writing a '1' to the associated bit.
Any bit set in this register will cause the MCPASS_INTR.RESULT_OVF bit to be set and this may be confgured to generate an interrupt (see MCPASS_MMIO).</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIR_RESULT_OVF</name>
                  <description>The associated bit is set in this register if the new FIR results are written before the associated SAR_RESULT_INTR/FIR_DONE bit has been cleared from the previous trigger.. This bit may be cleared by writing a '1' to the associated bit.
Any bit set in this register will cause the MCPASS_INTR.RESULT_OVF bit to be set and this may be confgured to generate an interrupt (see MCPASS_MMIO).</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENTRY_TR_COLLISION</name>
              <description>Entry trigger collision status</description>
              <addressOffset>0x1A4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>ENTRY_COL</name>
                  <description>The associated bit is set in this register if an Entry is triggered while processing for the previous trigger is still in progress, including sampling, conversion and post processing.
Write a '1' to clear status in this register.
Any bit set in this register will sety the MCPASS_INTR.ENTRY_TR_COLLISION to be set and this may be configured to generate an interrupt (see MCPASS_MMIO/MCPASS_INTR register).</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENTRY_HOLD_VIOLATION</name>
              <description>Entry hold violation status</description>
              <addressOffset>0x1A8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>HOLD_VIOL</name>
                  <description>The associated bit is set in this register if an Entry (and it's associated samplers) are in HOLD state greater than the ENTRY_HOLD_CNT value (see directly below), which indicates the associated channel results may not meet ADC accuracy specs.  Write a '1' to clear status in this register.
Any bit set in this register will sety the MCPASS_INTR.ENTRY_HOLD_VIOLATION to be set and this may be configured to generate an interrupt (see MCPASS_MMIO/MCPASS_INTR register).</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENTRY_HOLD_CNT</name>
              <description>Entry hold violation count</description>
              <addressOffset>0x1AC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1D</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>HOLD_CNT</name>
                  <description>This is the a global max HOLD count applied to all Entries. (See ENTRY_HOLD_VIOLATION above).

The resolution of each count is 16 high frequency clock counts.
For example, in PSOC C3 the high frequency clock is 160MHz, so each count will be 16/160MHz = 100ns.
The default max HOLD time is 3us, thus the default value for this register is 29 (30 counts)

NOTE: The violation can be asserted in the range of HOLD_CNT and HOLD_CNT+1</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAR_RESULT_INTR</name>
              <description>SAR Interrupt register</description>
              <addressOffset>0x200</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x300FF</resetMask>
              <fields>
                <field>
                  <name>ENTRY_DONE</name>
                  <description>The associated ENTRY_DONE(N) status is set.  The CHAN_RESULT registers for channels in this entry are ready for reading.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIR_DONE</name>
                  <description>The associated FIR_DONE(N) status is set.  The FIR_RESULT registers for the FIR modules are ready for reading</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAR_RESULT_INTR_SET</name>
              <description>SAR Interrupt request set register</description>
              <addressOffset>0x204</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x300FF</resetMask>
              <fields>
                <field>
                  <name>ENTRY_DONE_SET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register. (a write of '0' has no effect).</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIR_DONE_SET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register. (a write of '0' has no effect).</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAR_RESULT_INTR_MASK</name>
              <description>SAR Interrupt request mask</description>
              <addressOffset>0x208</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x300FF</resetMask>
              <fields>
                <field>
                  <name>ENTRY_DONE_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIR_DONE_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAR_RESULT_INTR_MASKED</name>
              <description>SAR Interrupt request masked</description>
              <addressOffset>0x20C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x300FF</resetMask>
              <fields>
                <field>
                  <name>ENTRY_DONE_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIR_DONE_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAR_RANGE_INTR</name>
              <description>SAR Range Interrupt register</description>
              <addressOffset>0x210</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>RANGE</name>
                  <description>The associated RANGE(N) status is set. The associated RANGE_STATUS is also set and available for reading.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAR_RANGE_INTR_SET</name>
              <description>SAR Range Interrupt request set register</description>
              <addressOffset>0x214</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>RANGE_SET</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAR_RANGE_INTR_MASK</name>
              <description>SAR Range Interrupt request mask</description>
              <addressOffset>0x218</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>RANGE_SET_MASK</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SAR_RANGE_INTR_MASKED</name>
              <description>SAR Range Interrupt request masked</description>
              <addressOffset>0x21C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>RANGE_SET_MASKED</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>14</dim>
              <dimIncrement>4</dimIncrement>
              <name>CHAN_RESULT_PACKED[%s]</name>
              <description>Channel result register packed with 2 results per register</description>
              <addressOffset>0x230</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>RESULT_EVEN</name>
                  <description>Even numbered channel results (e.g. 0, 2, 4, ... , 26)</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESULT_ODD</name>
                  <description>Odd numbered channel results. (e.g. 1, 3, 5, ... , 27)</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>AROUTE_CTRL_MODE</name>
              <description>AROUTE control mode</description>
              <addressOffset>0x300</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xC0000000</resetValue>
              <resetMask>0xC00000FF</resetMask>
              <fields>
                <field>
                  <name>MUX0_CTRL</name>
                  <description>The associated AROUTE MUX is controlled by the SAR sequencer by static FW setting, or AC

0 (default) - Controlled by SAR sequencer using values in SEQ_ENTRY table  MUXi_SEL fields or ENTRY_MUX_SEL_ALIAS register. This programming is explicit and easy to use and is intended for the majority of applications

Setting 1 and 2 below are for advanced usage only.  These settings override any SEQ_ENTRY setting. Therefore care must be taken to program SEQ_ENTRYs to NOT mix AROUTE_CTRL_MODE settings for the MUXes used in a given ENTRY.  Also, for a given MUX using any of these below modes, only 1 ENTRY should specify the usage of that MUX.

1 - Controlled by FW using AROUTE_FW_SET and AROUTE_FW_CLR registers below.  This mode must be used with care.  Configuration is by individual switch control - buy only 1 switch may be set for each MUX, otherwise the routes will be shorted to each other.
2 - Controlled by AC using ACTRLR/TIMER_TABLE/TT_CFG3/SAR_AROUTE_TR and SAR_AROUTE_SEL fields.  When this mode is used, the AC must be programmed to fully control that ENTRY.  In that case, for example, the external trigger will be routed to the AC code that sets the MUX, triggers that ENTRY, waits for the ENTRY to be completed, switched the MUX to the next selection, triggers that ENTRY again, etc.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX1_CTRL</name>
                  <description>The associated AROUTE MUX is controlled by the SAR sequencer or by FW, or AC</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX2_CTRL</name>
                  <description>The associated AROUTE MUX is controlled by the SAR sequencer or by FW, or AC</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX3_CTRL</name>
                  <description>The associated AROUTE MUX is controlled by the SAR sequencer or by FW, or AC</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEMPSENSE_ENABLED</name>
                  <description>NOTE: This register field has been depricated and no longer in use.  It may be left at the default value of '1' or it may be cleared to '0'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AROUTE_ENABLED</name>
                  <description>Global AROUTE Enable
1: Enabled (default), controlled using selected MUXn_CTRL method
0: Disabled, all switches open, overrides all other switch controls.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>AROUTE_FW_CTRL</name>
              <description>AROUTE firmware switch control set (individual)</description>
              <addressOffset>0x304</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>MUX0_SW0</name>
                  <description>Firmware control: 0=open, 1=close switch. Write with '1' to set bit.
To clear this bit write a '1' to the associated bit in AROUTE_FW_CLR register</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX0_SW1</name>
                  <description>N/A</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX0_SW2</name>
                  <description>N/A</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX0_SW3</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX1_SW0</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX1_SW1</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX1_SW2</name>
                  <description>N/A</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX1_SW3</name>
                  <description>N/A</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX2_SW0</name>
                  <description>N/A</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX2_SW1</name>
                  <description>N/A</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX2_SW2</name>
                  <description>N/A</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX2_SW3</name>
                  <description>N/A</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX3_SW0</name>
                  <description>N/A</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX3_SW1</name>
                  <description>N/A</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX3_SW2</name>
                  <description>N/A</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX3_SW3</name>
                  <description>N/A</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>AROUTE_FW_CTRL_CLR</name>
              <description>AROUTE firmware switch control clear (individual)</description>
              <addressOffset>0x308</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>MUX0_SW0</name>
                  <description>Write '1' to clear corresponding bit in AROUTE_FW_CTRL.  A read of this register returns the values of AROUTE_FW_CTRL.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX0_SW1</name>
                  <description>N/A</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX0_SW2</name>
                  <description>N/A</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX0_SW3</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX1_SW0</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX1_SW1</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX1_SW2</name>
                  <description>N/A</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX1_SW3</name>
                  <description>N/A</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX2_SW0</name>
                  <description>N/A</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX2_SW1</name>
                  <description>N/A</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX2_SW2</name>
                  <description>N/A</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX2_SW3</name>
                  <description>N/A</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX3_SW0</name>
                  <description>N/A</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX3_SW1</name>
                  <description>N/A</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX3_SW2</name>
                  <description>N/A</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MUX3_SW3</name>
                  <description>N/A</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>AROUTE_STATUS</name>
              <description>AROUTE switch status</description>
              <addressOffset>0x30C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>MUX0_SW0</name>
                  <description>Read back the current state of the associated switch control (regardless of mode)</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX0_SW1</name>
                  <description>N/A</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX0_SW2</name>
                  <description>N/A</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX0_SW3</name>
                  <description>N/A</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX1_SW0</name>
                  <description>N/A</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX1_SW1</name>
                  <description>N/A</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX1_SW2</name>
                  <description>N/A</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX1_SW3</name>
                  <description>N/A</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX2_SW0</name>
                  <description>N/A</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX2_SW1</name>
                  <description>N/A</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX2_SW2</name>
                  <description>N/A</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX2_SW3</name>
                  <description>N/A</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX3_SW0</name>
                  <description>N/A</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX3_SW1</name>
                  <description>N/A</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX3_SW2</name>
                  <description>N/A</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MUX3_SW3</name>
                  <description>N/A</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TEMPSENSE_CTRL</name>
              <description>Temperture Sensor Control</description>
              <addressOffset>0x310</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>TEMPSENSE_CURRENT_SEL</name>
                  <description>Used for Delta Vbe Temperature Sensor Algoritm (see BROS for full details)
0: BJT current is 1uA (default)
1: Add 8uA to BJT current</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <dim>2</dim>
            <dimIncrement>128</dimIncrement>
            <name>FIR[%s]</name>
            <description>SAR FIR coefficient and tap registers</description>
            <addressOffset>0x00000800</addressOffset>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>FIR_COEFS[%s]</name>
              <description>FIR Coeffecients</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>COEF</name>
                  <description>FIR Coefficient Value
The coefficient values can range from -1+1/215 to 1-1/215 with a resolution of 1/215. The coefficient uses twos-complement notation and the decimal point is fixed to the right of the most significant bit.
Examples: -0.25 = 0xE000 and 0.25 = 0x2000

NOTE: The max absolute value of the FIR gain must be less than 8 (sum of the coeffients), otherwise the result may overflow the allocated 16-bits.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>16</dim>
              <dimIncrement>4</dimIncrement>
              <name>FIR_TAPS[%s]</name>
              <description>FIR Taps</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TAP</name>
                  <description>FIR Tap Value
In normal operation R/W by hardware
Only when MCPASS IP is enabled and SAR is enabled - these registers may be written to and read by software, typically for debug puposes.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>CSG</name>
          <description>Comparator Slope Generator</description>
          <addressOffset>0x000B0000</addressOffset>
          <cluster>
            <dim>5</dim>
            <dimIncrement>64</dimIncrement>
            <name>SLICE[%s]</name>
            <description>CSG Slice configuration registers</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CMP_CFG</name>
              <description>Comparator Control Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x13F3D</resetMask>
              <fields>
                <field>
                  <name>CMP_POS_SEL</name>
                  <description>Comparator Positive Input Select (Select negative input from CMP_NEG_SEL)</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>AIN_PA</name>
                      <description>Analog input PA</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AIN_PB</name>
                      <description>Analog input PB</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CMP_NEG_SEL</name>
                  <description>Comparator Negative Input Select (Select positive input from CMP_POS_SEL)</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DAC</name>
                      <description>DAC is negative input</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD_1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AIN_NA</name>
                      <description>Analog input NA</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AIN_NB</name>
                      <description>Analog input NB</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CMP_BLANK_MODE</name>
                  <description>Comparator Blanking Mode.  Select a level input trigger from CMP_BLANK_TR_SEL to gate the comparators output of this slice to 0.  Polarity of active signal is selectable.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>Comparator output is not gated</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GATE_ON_ONE</name>
                      <description>Comparator output is gated to 0 by a '1' level</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>GATE_ON_ZERO</name>
                      <description>Comparator output is gated to 0 by a '0' level</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CMP_BLANK_TR_SEL</name>
                  <description>Copmarator Blank Trigger Select.  Select one of the available input MCPASS HW/FW LEVEL mode triggers.</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR0</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR1</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR2</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR3</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR4</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR5</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR6</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR7</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CMP_EDGE_MODE</name>
                  <description>Comparator signal mode for Interrupt generation and AC status</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLE</name>
                      <description>Disabled, no interrupts will be asserted</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RISING</name>
                      <description>Rising edge</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING</name>
                      <description>Falling edge</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>BOTH</name>
                      <description>Both rising and falling edges</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CMP_POLARITY</name>
                  <description>Comparator Polarity</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>True</name>
                      <description>Comparator output is not intverted</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INV</name>
                      <description>Comparator output is inverted</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>DAC_CFG</name>
              <description>DAC Control Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x73F0F7FF</resetMask>
              <fields>
                <field>
                  <name>DAC_TR_START_SEL</name>
                  <description>DAC Trigger Start Select.  Select one of the MCPASS HW or FW triggers. Trigger must be PULSE mode (see INFRA). See DAC_MODE_START register to select this as the DAC start trigger.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR0</name>
                      <description>HW (or FW) input triggers</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR1</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR2</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR3</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR4</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR5</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR6</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR7</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AC</name>
                      <description>AC trigger</description>
                      <value>9</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DAC_TR_UPDATE_SEL</name>
                  <description>DAC Trigger Update Select.  Select one of the triggers or internal events. See DAC_MODE for detailed operation. If one of the MCPASS HW or FW triggers are selected (see INFRA), then the trigger must be PULSE mode.  In addition, the maximum frequency of the active trigger edge must be less than or equal to CSG CLOCK/2 (every other clock).</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR0</name>
                      <description>HW (or FW) input triggers</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR1</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR2</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR3</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR4</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR5</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR6</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TR7</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>AC</name>
                      <description>AC trigger</description>
                      <value>9</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DAC_PERIOD_TC</name>
                      <description>Period terminal count. Period divider value is programmed in DAC_PERIOD register</description>
                      <value>10</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CMP_LEVEL</name>
                      <description>Use comparator output as Update Trigger: (Used only in Hysteretic Mode )
With DAC_VAL_A as high threshold and DAC_VAL_B as low threshold,
CMP 0 to 1 transition (voltage high) outputs DAC_VAL_B
CMP 1 to 0 transition (voltage low) outputs DAC_VAL_A</description>
                      <value>11</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CMP_LEVEL_INV</name>
                      <description>Use inverted comparator output as Update Trigger (Used only in Hysteretic Mode )
(e.g. in the case CMP_POLARITY is set)</description>
                      <value>12</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DAC_MODE</name>
                  <description>DAC Operating Mode.  This setting may only be changed when the mode is disabled. See DAC_MODE_START.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>BUFFERED</name>
                      <description>Single Value Buffered Mode

Transfer data from DAC_VAL_A to DAC_VAL and assert DAC_BUF_EMPTY interrupt.

The first transfer occurs when the mode is started (see DAC_MODE_START).
Subsequent transfers occur on the DAC_TR_UPDATE trigger.

This mode will stay in effect until the mode is stopped.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>HYSTERETIC</name>
                      <description>Two Value Hysteretic Buffered Mode

Toggle DAC_VAL between a high threshold (DAC_VAL_A)  and a low threshold (DAC_VAL_B) on DAC_TR_UPDATE trigger level..

The first transfer occurs from DAC_VAL_A (high threshold) to DAC_VAL when the mode is started (see DAC_MODE_START).

When the trigger transitions from 0 to 1 (e.g. rising voltage), DAC_VAL_B is output (low threshold)
When the trigger transitions from 1 to 0 (e.g. falling voltage), DAC_VAL_A is output (high threshold)

On the DAC_VAL_B update a DAC_BUF_EMPTY interrupt and both the A and B values are buffered and may be updated. (See DAC_PARAM_SYNC_EN to enable synchronized parameter updates.)

This mode will stay in effect until the mode is stopped.

NOTE: The comparator may be used in this mode as an UPDATE trigger - which may also be inverted to provide flexibility.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SLOPE_RISING</name>
                      <description>Rising Slope Mode

DAC_VAL_A is the start value, DAC_VAL_B is the end value.  Configure DAC_STEP if needed and DAC_PERIOD if selected as the DAC_TR_UPDATE trigger.  It is assumed that DAC_VAL_A &lt; DAC_VAL_B for Rising Slope Mode.

DAC_VAL_A (start value) is transferred to DAC_VAL when the mode is started (see DAC_MODE_START) and a DAC_SLOPE_START interrupt is generated.

On the UPDATE trigger, DAC_VAL is incremented by DAC_STEP

This continues until DAC_VAL &gt;= DAC_VAL_B, at which point the operation completes and a DAC_SLOPE_DONE interrupt is generated.

If DAC_OONT is '0', operation is stopped on slope done and DAC_MODE_EN is reset to '0'
If DAC_CONT is '1' then the slope operation will continuously repeat.
In continuous mode, buffered parameters will be updated at the start of the ramp (see DAC_PARAM_SYNC_EN)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SLOPE_FALLING</name>
                      <description>Falling Slope Mode

Same operation as Rising Slope Mode, but DAC_VAL is decremented.  It is assumed that DAC_VAL_A is greater than DAC_VAL_B for Falling Slope Mode.

For other details - see Rising Slope Mode description</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SLOPE_TRIANGULAR</name>
                      <description>Triangular Slope Mode

This mode combines Rising and Falling Slope Modes.  It first generates a Rising Slope, then when DAC_VAL &gt;= DAC_VAL_B, a Falling Slope is generated.  Then when DAC_VAL &lt;= DAC_VAL_A the operation is completed.

For other details - see Rising Slope Mode description</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LUT_FORWARD</name>
                      <description>LUT Forward Mode

LUT waveform is output with incrementing addresses.  DAC_VAL_A is start address and DAC_VAL_B is end address. DAC_STEP is the address step size.  It is assumed that DAC_VAL_A &lt; DAC_VAL_B.
NOTE: For LUT mode, the maximum update rate is limited to CLK_CSG/2 (i.e. Need at least 1 cycle gap between triggers)
For other details see Slope Rising Mode description</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LUT_REVERSE</name>
                      <description>LUT Reverse Mode

LUT waveform is output with decrementing addresses.  DAC_VAL_A is start address and DAC_VAL_B is end address. DAC_STEP is the address step size. It is assumed that DAC_VAL_A &gt; DAC_VAL_B.
NOTE: For LUT mode, the maximum update rate is limited to CLK_CSG/2 (i.e. Need at least 1 cycle gap between triggers)
For other details see Slope Rising Mode description</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LUT_FWD_REV</name>
                      <description>LUT Forward Reverse Mode

LUT waveform is output first with incrementing address, then when the address is &gt;= DAC_VAL_B, a decrementint address is generated.  When the address &lt;= DAC_VAL_A, the operation is completed.
NOTE: For LUT mode, the maximum update rate is limited to CLK_CSG/2 (i.e. Need at least 1 cycle gap between triggers)
For other details see Slope Rising Mode description</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DAC_CONT</name>
                  <description>DAC Continuous Mode (Only valid for Slope and LUT modes)
0: Slope/LUT operation is One-Shot, last output value is held
1: Slope/LUT operation is Continuous, operation is restarted when end value is reached</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAC_SKIP_TR_EN</name>
                  <description>Skip the first DAC hardware update trigger afer a mode is enabled.  Allows for a minimum of a full trigger period before the first hardware update occurs.
0: First trigger following DAC_MODE_EN updates the DAC value.
1: First trigger following DAC_MODE_EN is skipped.  Following trigger updates the DAC value.</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAC_CASCADE_EN</name>
                  <description>Cascade Enable.  Synchronize parameter update with previous CSG slice in the case of multi-phase operation.
0: Disabled.
1: Enabled. This CSG updates it's parameters on a DAC trigger only after the previous numbered CSG has updated it's parameters.</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAC_PARAM_SYNC_EN</name>
                  <description>Parameter Sync Enable.
0: Disabled.  Always update parameters on DAC trigger (as defined by DAC_MODE)
1: Enabled.   Only update parameters on DAC trigger if DAC_PARAM_SYNC.READY is set.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAC_STEP</name>
                  <description>Static value of 6 bit DAC step size. Step size is DAC_STEP +1 (default is '1') , range is 1 - 64, only valid in SLOPE/LUT modes.
NOTE: In LUT mode each step jumps to a new LUT value on WORD boundaries.
So for example:
DAC_STEP = 0  (default Step size of 1) advances the LUT address by 4 (LUT WORD boundary)
DAC_STEP = 1 (Step size of 2) advances the LUT address by 8, etc</description>
                  <bitRange>[25:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAC_DEGLITCH</name>
                  <description>DAC Deglitch Configuration.  Default is disabled.  If enabled, on any DAC value update,the CMP output is latched in it's current state for the number of cycles indicated.</description>
                  <bitRange>[30:28]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DISABLED</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ONE_CYCLE</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TWO_CYCLES</name>
                      <description>N/A</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>THREE_CYCLES</name>
                      <description>N/A</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FOUR_CYCLES</name>
                      <description>N/A</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIVE_CYCLES</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SIX_CYCLES</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SEVEN_CYCLES</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>DAC_PARAM_SYNC</name>
              <description>DAC Parameter Synchronized Update</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>READY</name>
                  <description>Use this bit to synchronize the update of multiple DAC parameters.

If DAC_PARAM_SYNC_EN bit is '1', then set this bit after writes to all parameter registers (VAL_A, VAL_B, DAC_PERIOD, DAC_STEP) are complete to synchronize parameter update on a subsequent DAC trigger This allows for writes to multiple registers to be written before new parameters are updated to avoid partial updates.

This bit is cleared by HW on the parameter update event.

if DAC_PARAM_SYNC_EN is '0', this bit is ignored and parameters are updated on the following UPDATE trigger.

NOTE: This bit can be used in conjunction with DAC_CASCADE_EN to synchronize the parameter update of multiple CSG slices.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DAC_MODE_START</name>
              <description>DAC Mode Start</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC0000001</resetMask>
              <fields>
                <field>
                  <name>BUSY</name>
                  <description>Read only bit to indicate that a DAC MODE has been enabled and is currently in progress.
If FW_START is used to start the mode, then the FW_START bit is equivalent to this bit and low when the mode is completed or stopped.
If HW_START is used to start the mode, then this status bit goes high on the DAC_START_TR event, and low when the mode is completed or stopped.

NOTE: This read only bit refects the state of the DAC controller which is reset in DeepSleep and therefore this bit is not a retention bit.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>HW_START</name>
                  <description>1: Wait for subsequent DAC_START_TR  to start the selected mode.
0: Stops the selected mode.  When this bit is cleared, the current DAC_VAL will not change unless it is over-written directly - or a new DAC mode is started.
This field is automatically reset to '0' on DAC_SLOPE_DONE event (unless DAC_CONT is set for continous mode).</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FW_START</name>
                  <description>1: Starts the selected mode on this FW write.
0: Stops the selected mode.  When this bit is cleared, the current DAC_VAL will not change unless it is over-written directly - or a new DAC mode is started.
This field is automatically reset to '0' on DAC_SLOPE_DONE event (unless DAC_CONT is set for continous mode).</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DAC_VAL_A</name>
              <description>DAC Vaue A Buffer</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>VALUE</name>
                  <description>DAC A Value, usage is mode dependent (see DAC_MODE)

NOTE: In LUT modes this is the Start Address of the LUT waveform in byte address format (e.g. 0, 4, 8, ... 1F8, 1FC)</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DAC_VAL_B</name>
              <description>DAC Value B Buffer</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>VALUE</name>
                  <description>DAC B Value, usage is mode dependent (see DAC_MODE)

NOTE: In LUT modes this is the End Address of the LUT waveform in byte address format (e.g. 0, 4, 8, ... 1F8, 1FC)</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DAC_PERIOD</name>
              <description>DAC Period Buffer</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF8</resetMask>
              <fields>
                <field>
                  <name>PERIOD_FRAC</name>
                  <description>5-bit Fractional Divide Value. Allows for fractional count in the range [0, 31/32]</description>
                  <bitRange>[7:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PERIOD_INT</name>
                  <description>12-bit Integer Divide Value.
Integer count  by (1+PERIOD_INT). Allows for integer counts in the range [1, 4096].</description>
                  <bitRange>[19:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DAC_VAL</name>
              <description>DAC FW write</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>VALUE</name>
                  <description>Direct drive to DAC Hard IP for output.
When DAC_MODE_EN is '0', the value in this register is output.  A write to this register also STOPs the current DAC_MODE operation, and subsequent DAC triggers are ignored.</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DAC_STATUS</name>
              <description>Read of Current DAC Value</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FF</resetMask>
              <fields>
                <field>
                  <name>DAC_VAL</name>
                  <description>Read Only value of current digital DAC output</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CMP_STATUS</name>
              <description>Read of Comparator Value</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1</resetMask>
              <fields>
                <field>
                  <name>CMP_VAL</name>
                  <description>Read Only value of comparator output</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <cluster>
            <dim>2</dim>
            <dimIncrement>512</dimIncrement>
            <name>LUT_CFG[%s]</name>
            <description>DAC LUT waveform data</description>
            <addressOffset>0x00000400</addressOffset>
            <register>
              <dim>128</dim>
              <dimIncrement>4</dimIncrement>
              <name>LUT_DATA[%s]</name>
              <description>LUT Waveform Data</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>DATA</name>
                  <description>DAC waveform</description>
                  <bitRange>[9:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>CSG_CTRL</name>
            <description>CSG control register</description>
            <addressOffset>0xA00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x10F</resetMask>
            <fields>
              <field>
                <name>VDAC_OUT_SEL</name>
                <description>Select the DAC output for SAR conversion</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>Hi-Z (Disabled)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DAC0</name>
                    <description>Connect DAC0 to ADC input</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DAC1</name>
                    <description>Connect DAC1 to ADC input</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DAC2</name>
                    <description>Connect DAC2 to ADC input</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DAC3</name>
                    <description>Connect DAC3 to ADC input</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DAC4</name>
                    <description>Connect DAC4 to ADC input</description>
                    <value>5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CSG_CLK_DIV_BYP</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_INTR</name>
            <description>DAC Interrupt register</description>
            <addressOffset>0xB00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>DAC_HW_START</name>
                <description>This DAC_MODE operation was started with a HW START trigger.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAC_SLOPE_DONE</name>
                <description>When SLOPE or LUT mode is enabled, this interrupt is set when the SLOPE (or LUT waveform) has completed.
This interrupt is also set periodically on the last value of a DAC SLOPE in continuous mode</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAC_BUF_EMPTY</name>
                <description>When BUFFERED or HYSTERETIC mode is enabled, this interrupt is set when there is a DAC UPDATE trigger that transfers the buffered value(s) to active value(s) (see mode operation) and it means that the user may write new values to the buffer registers.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_INTR_SET</name>
            <description>DAC Interrupt request set register</description>
            <addressOffset>0xB04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>DAC_HW_START</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAC_SLOPE_DONE</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAC_BUF_EMPTY</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_INTR_MASK</name>
            <description>DAC Interrupt request mask</description>
            <addressOffset>0xB08</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>DAC_HW_START</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAC_SLOPE_DONE</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAC_BUF_EMPTY</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DAC_INTR_MASKED</name>
            <description>DAC Interrupt request masked</description>
            <addressOffset>0xB0C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>DAC_HW_START</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DAC_SLOPE_DONE</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DAC_BUF_EMPTY</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMP_INTR</name>
            <description>CMP Interrupt register</description>
            <addressOffset>0xB10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>CMP</name>
                <description>This CMP(n) state has generated an interrupt request (see CSG_SLICE.CMP_CTRL.CMP_MODE)</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMP_INTR_SET</name>
            <description>CMP Interrupt request set register</description>
            <addressOffset>0xB14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>CMP</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMP_INTR_MASK</name>
            <description>CMP Interrupt request mask</description>
            <addressOffset>0xB18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>CMP</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMP_INTR_MASKED</name>
            <description>CMP Interrupt request masked</description>
            <addressOffset>0xB1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>CMP</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VDAC_OUT_BLANK</name>
            <description>Blanking control for DAC Observability</description>
            <addressOffset>0xB20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>BLANK_CNT</name>
                <description>This field enables blanking iin CLK_CSG cycles of the Comparator output when one of the DACs in a CSG SLICE is connected as an input for SAR conversion  (See CTRL.VDAC_OUT_SEL)
Disabled: BLANK_CNT = 0
Enabled : BLANK_CNT is between 1 and 31

When the DAC output is first connected to the SAR sampler input, the DAC may have a short transient (50ns). If the DAC is also an active input to the Comparator, this transient may cause false transitions on the Comparator output.  To mitigate this, the Comparator output is latched for the duration of the BLANK_CNT value.   This 5-bit value is the number of clock cycles to blank (latch) the Comparator output.  This count is in CLK_CSG cycles as programmed in the MXPERI divider.  The recommended value is 50ns blanking.
Examples are:
CLK_CSG @40MHz, use 2 cycles
CLK_CSG @80MHz, use 4 cycles
CLK_CSG @120MHz, use 8 cycles</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CSG_SYNC</name>
            <description>CSG Sync Enable register</description>
            <addressOffset>0xB30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>SYNC_EN</name>
                <description>Risk Mitigation only.  By default the CSG Hard IP and comparator output is synchronous to CLK_CSG.  When this bit is set to '1', the CSG comparator output is double synced.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>ACTRLR</name>
          <description>Autonomnous Controller</description>
          <addressOffset>0x000D0000</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>0: MCPASS IP disabled - All mision logic and status is reset, all analog controls are disabled, all clocking is disabled (only available function is AHB access).
NOTE: The SARADC trim is also reset and therefore the SAR needs to be re-calibrated, or previously saved trim values re-written if the IP is disabled.
The only functioing system is the AHB register access when the IP is disabled.

1: MCPASS IP enabled. Clocks ungated, Reset negated</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_RUN</name>
            <description>Run Command register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RUN</name>
                <description>When firmware writes a '1' here it will trigger the Autonomous Controller to run, hardware clears this bit when the Autonomous Controller acknowledges the run command.  This command has no action if the Autonomous Controller is already running.
When the AC is stopped, the AC may be set back into running state by setting the CMD STATE to the address ofone ore more instructions and by setting this RUN bit to '1'</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_STATE</name>
            <description>State Override register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>STATE</name>
                <description>Autonomous Controller CMD_STATE register.  This register indicates which instruction the AC will start execution from when it receives a RUN command.  Software can overrwrite this field only when STATUS.STATUS=STOPPED to set the AC to execute from a specific STATE when triggered by the RUN command.

When first enabled, this register is reset to 0, so by default the AC starts executing at state 0.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLOCK_STATUS</name>
            <description>Block Ready status register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>READY</name>
                <description>This bit reflects the AC BLOCK_READY condition, which can be polled by SW to determine if all the enabled blocks have settled and are ready for use</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>AC Status register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30F</resetMask>
            <fields>
              <field>
                <name>CUR_STATE</name>
                <description>This register indicates where in memory the AC is currently executing instructions.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>STATUS</name>
                <description>This field indicates if the Autonomous Controller is busy</description>
                <bitRange>[9:8]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>STOPPED</name>
                    <description>Autonomous Controller is stopped</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RUNNING</name>
                    <description>Autonomous Controller is running</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD2</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD3</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG</name>
            <description>AC Config register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>DOUT_EN</name>
                <description>DOUT_EN controls the GPIO output drive mode though the HSIOM
This register enables the DOUT feature, where up to 5 GPIOs can be controlled programatically with the AC (ACTRLR.TIMER_TABLE.TT_CFG0.DOUT).
To use this feature:
1) The HSIOM (High Speed I/O Mux) device configuration must be set to select one or more DOUT/DOUT_EN bits to drive the associated GPIOs.
2) The associated bit(s) in this register must be set to enable the GPIO for output drive mode.
0 :DOUT[n] GPIO output disabled
1: DOUT[n] GPIO output enabled</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>4</dimIncrement>
            <name>CNTR_STATUS[%s]</name>
            <description>Loop/Interval counter status register</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800FFF0F</resetMask>
            <fields>
              <field>
                <name>CUR_STATE</name>
                <description>This field indicates which Timer Table State the counter is assigned.  Valid numbers are 0-15</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CUR_CNT</name>
                <description>This field indicates the count value for the given counter.</description>
                <bitRange>[19:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>This field indicates if the counter is busy</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>16</dim>
            <dimIncrement>16</dimIncrement>
            <name>TTCFG[%s]</name>
            <description>Timer Table Structure</description>
            <addressOffset>0x00000800</addressOffset>
            <register>
              <name>TT_CFG0</name>
              <description>AC Configuration 0</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F1FF10</resetMask>
              <fields>
                <field>
                  <name>SAR_UNLOCK</name>
                  <description>SAR Unlock
0: Lock: SAR fields: EN does NOT get updated
1: Unlock: SAR fields: EN does get updated

These fields are used to prevent unintentional mode transitions.  For example, when you wish to enable the SAR, you set this SAR_UNLOCK bit to '1' in that state.  As other states will have a '0' for this field, and therefore the SAR_EN will not be inadvertantly be set to '0' in other states.  If you want to disable the SAR, set this SAR_UNLOCK bit to '1' again and the SAR_EN to '0' for the disable to take effect.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSG_UNLOCK</name>
                  <description>CSG Unlock
0: Lock: CSG fields: EN does NOT get updated
1: Unlock: CSG fields: EN does get updated</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DOUT_UNLOCK</name>
                  <description>DOUT Unlock
0: Lock: DOUT does NOT get updated
1: Unlock: DOUT does get updated</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DOUT</name>
                  <description>MCPASS data out generation
When this function is enabled (see ACTRLR.CFG.DOUT_EN), any enabled bits in this field will be driven through HSIOM to the associated GPIO pads for output.  This allows the AC to digital control to an off chip  resource (e.g. enable a sensor) as part of AC programming.</description>
                  <bitRange>[24:20]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TT_CFG1</name>
              <description>AC Configuration 1</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>BR_ADDR</name>
                  <description>Absolute address of the branch if taken (0-15 possible)</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NC_7_4</name>
                  <description>N/A</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COND</name>
                  <description>Autonomous Controller Condition</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>False</name>
                      <description>Hardcoded FALSE value</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>True</name>
                      <description>Hardcoded TRUE value</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>BLOCK_READY</name>
                      <description>Enabled block(s) are ready for use.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CNT_DONE</name>
                      <description>if the ACTION is WAIT_FOR - this is an interval timer.
If the ACTION is BRANCH IF - this is a loop counter.</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_ENTRY0_DONE</name>
                      <description>SAR Sequencer Entry Done</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_ENTRY1_DONE</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_ENTRY2_DONE</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_ENTRY3_DONE</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_ENTRY4_DONE</name>
                      <description>N/A</description>
                      <value>8</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_ENTRY5_DONE</name>
                      <description>N/A</description>
                      <value>9</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_ENTRY6_DONE</name>
                      <description>N/A</description>
                      <value>10</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_ENTRY7_DONE</name>
                      <description>N/A</description>
                      <value>11</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_RANGE0</name>
                      <description>SAR Range Detected</description>
                      <value>12</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_RANGE1</name>
                      <description>N/A</description>
                      <value>13</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_RANGE2</name>
                      <description>N/A</description>
                      <value>14</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_RANGE3</name>
                      <description>N/A</description>
                      <value>15</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_RANGE4</name>
                      <description>N/A</description>
                      <value>16</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_RANGE5</name>
                      <description>N/A</description>
                      <value>17</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_RANGE6</name>
                      <description>N/A</description>
                      <value>18</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_RANGE7</name>
                      <description>N/A</description>
                      <value>19</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_BUSY</name>
                      <description>SAR Busy</description>
                      <value>20</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_FIR0_DONE</name>
                      <description>SAR FIR0 Done. All FIR outputs, that is, not gated by FIR_CFG/TAP_WAIT_INIT</description>
                      <value>21</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_FIR1_DONE</name>
                      <description>SAR FIR1 Done. All FIR outputs, that is, not gated by FIR_CFG/TAP_WAIT_INIT</description>
                      <value>22</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_QUEUE_HI_EMPTY</name>
                      <description>SAR Hi priority Queue is empty</description>
                      <value>23</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_QUEUE_LO_EMPTY</name>
                      <description>SAR Lo priority Queue is empty</description>
                      <value>24</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SAR_QUEUES_EMPTY</name>
                      <description>Both Queues are empty</description>
                      <value>25</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD26</name>
                      <description>N/A</description>
                      <value>26</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD27</name>
                      <description>N/A</description>
                      <value>27</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD28</name>
                      <description>N/A</description>
                      <value>28</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD29</name>
                      <description>N/A</description>
                      <value>29</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD30</name>
                      <description>N/A</description>
                      <value>30</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD31</name>
                      <description>N/A</description>
                      <value>31</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>HW_TR0_IN</name>
                      <description>HW/FW Trigger from INFRA</description>
                      <value>32</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>HW_TR1_IN</name>
                      <description>N/A</description>
                      <value>33</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>HW_TR2_IN</name>
                      <description>N/A</description>
                      <value>34</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>HW_TR3_IN</name>
                      <description>N/A</description>
                      <value>35</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>HW_TR4_IN</name>
                      <description>N/A</description>
                      <value>36</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>HW_TR5_IN</name>
                      <description>N/A</description>
                      <value>37</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>HW_TR6_IN</name>
                      <description>N/A</description>
                      <value>38</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>HW_TR7_IN</name>
                      <description>N/A</description>
                      <value>39</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD40</name>
                      <description>N/A</description>
                      <value>40</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD41</name>
                      <description>N/A</description>
                      <value>41</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_LEVEL0</name>
                      <description>FIFO Level</description>
                      <value>42</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_LEVEL1</name>
                      <description>N/A</description>
                      <value>43</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_LEVEL2</name>
                      <description>N/A</description>
                      <value>44</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FIFO_LEVEL3</name>
                      <description>N/A</description>
                      <value>45</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD46</name>
                      <description>N/A</description>
                      <value>46</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD47</name>
                      <description>N/A</description>
                      <value>47</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG0_SLOPE_DONE</name>
                      <description>CSG Slope/LUT waveform Done</description>
                      <value>48</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG1_SLOPE_DONE</name>
                      <description>N/A</description>
                      <value>49</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG2_SLOPE_DONE</name>
                      <description>N/A</description>
                      <value>50</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG3_SLOPE_DONE</name>
                      <description>N/A</description>
                      <value>51</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG4_SLOPE_DONE</name>
                      <description>N/A</description>
                      <value>52</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG5_SLOPE_DONE</name>
                      <description>N/A</description>
                      <value>53</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG6_SLOPE_DONE</name>
                      <description>N/A</description>
                      <value>54</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG7_SLOPE_DONE</name>
                      <description>N/A</description>
                      <value>55</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG0_CMP_TR</name>
                      <description>CSG Comparator Trip. Condition is set by CSG.CSG_SLICE.CMP_CFG.CMP_EDGE_MODE</description>
                      <value>56</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG1_CMP_TR</name>
                      <description>N/A</description>
                      <value>57</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG2_CMP_TR</name>
                      <description>N/A</description>
                      <value>58</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG3_CMP_TR</name>
                      <description>N/A</description>
                      <value>59</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG4_CMP_TR</name>
                      <description>N/A</description>
                      <value>60</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG5_CMP_TR</name>
                      <description>N/A</description>
                      <value>61</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG6_CMP_TR</name>
                      <description>N/A</description>
                      <value>62</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CSG7_CMP_TR</name>
                      <description>N/A</description>
                      <value>63</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>NC_15_14</name>
                  <description>N/A</description>
                  <bitRange>[15:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ACTION</name>
                  <description>Autonomous Controller Action</description>
                  <bitRange>[18:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>STOP</name>
                      <description>Stop the autonomous controller</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NEXT</name>
                      <description>Execute the current state and proceed to the next state</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>WAIT_FOR</name>
                      <description>Wait for the associated COND to occur before moving to the next state

If COND=FALSE, stay in the present state indefinitely.  If COND=TRUE, move to the next state.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>BRANCH_IF_TRUE</name>
                      <description>Check if COND has occurred, If it has, take the indicated branch (BR ADDR), if not, proceed to the next state.

If COND=FALSE, proceed to the next state.  If COND=TRUE, take the indicated branch (BR_ADDR).</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>BRANCH_IF_FALSE</name>
                      <description>Check if COND has occurred, If it has proceed to the next state, if not, take the indicated branch (BR ADDR)

If COND=FALSE,  take the indicated branch (BR_ADDR).  If COND=TRUE, proceed to the next state.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD_0</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD_1</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD_2</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>INTR_SET</name>
                  <description>AC Interrupt Set.  This will generate a CPU interrupt or Hardware Trigger output if configured.  If ACTION=WAIT_FOR, the interrupt is generated after the COND occurs.
The AC Interrupt may be configured in MCPASS_MMIO.MCPASS_INTR.
The AC Hardware trigger may be configured in MCPASS_MMIO.TR_PULSE_OUT</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CNT</name>
                  <description>This field is used to set the timer/counter values for either interval and loop counts.  The actual count is CNT value + 1.  Therefore, the range is 1 to 4096.  The value of 1 is degenerate.</description>
                  <bitRange>[31:20]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TT_CFG2</name>
              <description>AC Configuration 2</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>CSG_EN</name>
                  <description>CSG Slice Enables.  The CSG UNLOCK bits must be set in the same state as these bits (see TT_CFG0) to enable or disable. These bits are normally used in conjunction with ACTION=WAIT_FOR and COND=BLOCK_READY</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSG_DAC_TR</name>
                  <description>CSG Slice Triggers.  After the block is ready for use - these bits may be used for CSG DAC START and UPDATE triggers.  The type of trigger is programmed in the CSG_SLICE register block.
 If ACTION=WAIT_FOR, the trigger always occurs in the fir cycle of that state</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NC_31_16</name>
                  <description>N/A</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TT_CFG3</name>
              <description>AC Configuration 3</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SAR_TR</name>
                  <description>SAR Table Entry Triggers.  After the block is ready for use - these bits may be used to trigger one ore more SAR Entries.  If ACTION=WAIT_FOR, the trigger always occurs in the fir cycle of that state</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SAR_EN</name>
                  <description>SARADC Enable   The SAR UNLOCK bit must be set in the same state as this bit (see TT_CFG0) to enable or disable. This bit is normally used in conjunction with ACTION=WAIT_FOR and COND=BLOCK_READY</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NC_11_9</name>
                  <description>N/A</description>
                  <bitRange>[11:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SAR_AROUTE_TR</name>
                  <description>SAR Aroute Trigger (1 bit per mux) to change Route setting for one or more AROUTE MUXes.  Set this bit in conjuction with a new SAR_AROUTE_SEL value.</description>
                  <bitRange>[15:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SAR_AROUTE_SEL</name>
                  <description>SAR Route setting (2 bits per mux) to select the routing input.  The routing bits in this field are only valid if the associated SAR_ROUTE_TR is set.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NC_31_24</name>
                  <description>N/A</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>INFRA</name>
          <description>MCPASS infrastructure</description>
          <addressOffset>0x000E0000</addressOffset>
          <register>
            <name>TR_IN_SEL</name>
            <description>Trigger Input Select</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x77777777</resetMask>
            <fields>
              <field>
                <name>TR0_SEL</name>
                <description>Trigger selection.
NOTE: ALL TRIGGERS ARE GATED (DISABLED) BY HARDWARE UNTIL BLOCK READY IS '1'</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>Trigger is off</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>HW_TR_A</name>
                    <description>Select an external HW trigger from A trigger inputs.  For additional options see HW_TR_MODE</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>HW_TR_B</name>
                    <description>Select the external HW trigger from B trigger inputs. For additional options see HW_TR_MODE</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FW_PULSE</name>
                    <description>Select FW PULSE trigger.  See FW_TR_IN_PULSE.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FW_LEVEL</name>
                    <description>Select FW LEVEL trigger.  See FW_TR_IN_LEVEL.</description>
                    <value>4</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TR1_SEL</name>
                <description>N/A</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR2_SEL</name>
                <description>N/A</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR3_SEL</name>
                <description>N/A</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR4_SEL</name>
                <description>N/A</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR5_SEL</name>
                <description>N/A</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR6_SEL</name>
                <description>N/A</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR7_SEL</name>
                <description>N/A</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HW_TR_MODE</name>
            <description>HW Trigger Mode</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HW_TR0_MODE</name>
                <description>If HW trigger is selected, this controls the trigger mode.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>PULSE_ON_POS_DOUBLE_SYNC</name>
                    <description>HW trigger is assumed to be async in FC, it is double synced and converted to pulse on positive edge.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULSE_ON_NEG_DOUBLE_SYNC</name>
                    <description>HW trigger is assumed to be async in FC, it is double synced and converted to synchronous pulse on negative edge.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULSE_ON_BOTH_DOUBLE_SYNC</name>
                    <description>HW trigger is assumed to be async in FC, it is double synced and converted to synchronous pulse on both edges.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LEVEL_DOUBLE_SYNC</name>
                    <description>HW trigger is assumed to be async in FC, it is double synced and used as a level trigger.
NOTE: Level trigger selection is only for use by a CSG Slice in Hyteretic Mode and the minimum duration of the high or low level must be greater than or equal to the CSG clock period.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULSE_ON_POS_SINGLE_SYNC</name>
                    <description>HW trigger is assumed to sync in FC, captured in a register, and then converted to pulse on positive edge</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULSE_ON_NEG_SINGLE_SYNC</name>
                    <description>HW trigger is assumed to sync in FC, captured in a register, and then converted to pulse on negative edge</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULSE_ON_BOTH_SINGLE_SYNC</name>
                    <description>HW trigger is assumed to sync in FC, captured in a register, and then converted to pulse on both edges</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LEVEL_SINGLE_SYNC</name>
                    <description>HW trigger is assumed to be async in FC, captured in a register, and used as a level trigger.
NOTE: Level trigger selection is only for use by a CSG Slice in Hyteretic Mode and the minimum duration of the high or low level must be greater than or equal to the CSG clock period.</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HW_TR1_MODE</name>
                <description>N/A</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HW_TR2_MODE</name>
                <description>N/A</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HW_TR3_MODE</name>
                <description>N/A</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HW_TR4_MODE</name>
                <description>N/A</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HW_TR5_MODE</name>
                <description>N/A</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HW_TR6_MODE</name>
                <description>N/A</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HW_TR7_MODE</name>
                <description>N/A</description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FW_TR_PULSE</name>
            <description>FW Pulse Mode Trigger</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>FW_TR_PULSE</name>
                <description>If FW is selected in TR_IN_SEL, A write of '1' to this register will generate an internal PULSE trigger. These bits will be cleared automatically by HW.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FW_TR_LEVEL</name>
            <description>FW Level Mode Trigger</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>FW_TR_LEVEL</name>
                <description>If FW is selected in TR_IN_SEL, Writes to this register will be passed to the internal trigger as a LEVEL '1' or '0.
NOTE: LEVEL mode trigger is only valid for CSG module,  Do not use for SAR Entry.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLOCK_STARTUP_DIV</name>
            <description>Startup Clock Divder</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x7</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DIV_VAL</name>
                <description>Divide MCPASS a prescaled clock divide to generate block startup delays.  Actual divide value is DIV_VAL+1.
Typically this register should be set to give a period of 200ns, so the count depends on CLK_HF.
NOTE: This counter is clocked on CLK_HF/2
Examples:
For CLK_HF = 80MHz (CLK_INFRA = 40MHz), set DIV_VAL to 7 (8 cycles * 25ns = 200ns, default)
For CLK_HF = 160MHz (CLK_INFRA = 80MHz) set DIV_VAL to 15 (16 cycles * 12.5ns = 200ns)
For CLK_HF = 240MHz (CLK_INFRA = 120MHz) set DIV_VAL to 23 (24 cycles * 8.33ns = 200ns</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>4</dimIncrement>
            <name>STARTUP_CFG[%s]</name>
            <description>Startup configuration</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFF</resetMask>
            <fields>
              <field>
                <name>COUNT_VAL</name>
                <description>Actual count value is COUNT_VAL+1</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SAR_EN</name>
                <description>SAR startup</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CSG_CH_EN</name>
                <description>CSG Channel Enable startup</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CSG_PWR_EN_SLICE</name>
                <description>CSG Slice Enable startup</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CSG_READY</name>
                <description>CSG Auto Zero/Comparator gate startup
When this bit is set, the associated COUNT_VAL must be calculated relative to the CLK_CSG divide and the resulting period must be 33 CLK_CSG periods
Examples:
Assuming we have 200ns prescale value programmed into CLOCK_STARTUP_DIV.DIV_VAL.
With the examples of CLK_CSG as configured by MXPERI at the following frequencies:
For CSG at 40 MHz, 25ns x 33 cycles = 825ns.  roundup(825/200) = 5 (COUNT_VAL = 4)
For CSG at 80 Mhz,  12.5ns x 33 cycles = 412ns  roundup(412/200) = 3 (COUNT_VAL = 2)
For CSG at 120 MHz, 8.33 ns x 33 cycles = 275ns roundup(275/200) = 2 (COUNT_VAL = 1)</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VDDA_STATUS</name>
            <description>Analog Voltage Status</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>VDDA_OK</name>
                <description>Read only status bit to determine the presence of VDDA.  This bit is set by HW and it must be 1 prior to enabling the SAR or CSG.
0: VDDA is below minimum threshold
1: VDDA is at or above minimum threhold</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CTRL</name>
            <description>Analog Control</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>FORCE_POR_0</name>
                <description>Override for Analog POR Hardware circuit.
0: (default) POR is controlled by analog hardware
1: Force POR asserted (POR is an active low signal)
If the MCPASS is not in use, set this bit to '1' to achieve the lowest level of IP leakage
NOTE: If this bit is set to 1, FORCE_POR_1 must be 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_POR_1</name>
                <description>Override for Analog POR Hardware circuit.
0: (default) POR is controlled by analog hardware
1: Force POR negated (POR is an active low signal)
NOTE: If this bit is set to 1, FORCE_POR_0 must be 0.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_OVERLOAD_EN_0</name>
                <description>Override for Analog OVERLOAD Hardware circuit.
0: (default) OVERLOAD enable is controlled by ACTRL.CTRL.ENABLED bit
1: Force OVERLOAD enable off
NOTE: If this bit is set to 1, FORCE_OVERLOAD_EN_1 must be 0</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_OVERLOAD_EN_1</name>
                <description>Override for Analog OVERLOAD Hardware circuit
0: (default) OVERLOAD enable is controlled by ACTRL.CTRL.ENABLED bit
1: Force OVERLOAD enable on
NOTE:  If this bit is set to 1, FORCE_OVERLOAD_EN_0 must be 0</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <name>AREFV2</name>
            <description>AREF Configuration</description>
            <addressOffset>0x00000E00</addressOffset>
            <register>
              <name>AREF_CTRL</name>
              <description>AREF control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x8031FFFD</resetMask>
              <fields>
                <field>
                  <name>AREF_MODE</name>
                  <description>N/A</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AREF_BIAS_SCALE</name>
                  <description>N/A</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AREF_RMB</name>
                  <description>N/A</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTB_IPTAT_SCALE</name>
                  <description>N/A</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTB_IPTAT_REDIRECT</name>
                  <description>N/A</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IZTAT_SEL</name>
                  <description>N/A</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RSVD</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LOCAL</name>
                      <description>Use locally generated 250nA</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>VREF_SEL</name>
                  <description>N/A</description>
                  <bitRange>[21:20]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RSVD</name>
                      <description>N/A</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LOCAL</name>
                      <description>Use locally generated Vref</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>EXTERNAL</name>
                      <description>Use externally supplied Vref (aref_ext_vref)</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>- 0: AREF disabled
- 1: AREF enabled</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>VREF_TRIM0</name>
            <description>VREF Trim bits</description>
            <addressOffset>0xF00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VREF_ABS_TRIM</name>
                <description>N/A</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VREF_TRIM1</name>
            <description>VREF Trim bits</description>
            <addressOffset>0xF04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VREF_TEMPCO_TRIM</name>
                <description>N/A</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VREF_TRIM2</name>
            <description>VREF Trim bits</description>
            <addressOffset>0xF08</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VREF_CURV_TRIM</name>
                <description>N/A</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VREF_TRIM3</name>
            <description>VREF Trim bits</description>
            <addressOffset>0xF0C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>VREF_ATTEN_TRIM</name>
                <description>Obsolete</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IZTAT_TRIM0</name>
            <description>IZTAT Trim bits</description>
            <addressOffset>0xF10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>IZTAT_ABS_TRIM</name>
                <description>N/A</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IZTAT_TRIM1</name>
            <description>IZTAT Trim bits</description>
            <addressOffset>0xF14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>IZTAT_TC_TRIM</name>
                <description>IZTAT temperature correction trim (RMB)
0x00 : No IZTAT temperature correction
0xFF : Maximum IZTAT temperature correction

As this is a Risk Mitigation Register, it should be loaded with 0x08.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IPTAT_TRIM0</name>
            <description>IPTAT Trim bits</description>
            <addressOffset>0xF18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>IPTAT_CORE_TRIM</name>
                <description>IPTAT trim
0x0 : Minimum IPTAT current (~150nA at room)
0xF : Maximum IPTAT current (~350nA at room)</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPTAT_CTBM_TRIM</name>
                <description>CTMB PTAT Current Trim
0x0 : Minimum CTMB IPTAT Current (~875nA)
0xF : Maximum CTMB IPTAT Current (~1.1uA)</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ICTAT_TRIM0</name>
            <description>ICTAT Trim bits</description>
            <addressOffset>0xF1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>ICTAT_TRIM</name>
                <description>ICTAT trim
0x00 : Minimum ICTAT current (~150nA at room)
0x0F : Maximum ICTAT current (~350nA at room)</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>MMIO</name>
          <description>MCPASS top-level MMIO</description>
          <addressOffset>0x000F0000</addressOffset>
          <register>
            <name>FIFO_INTR</name>
            <description>FIFO Interrupt request register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>FIFO_LEVEL</name>
                <description>This field will be '1', when STATUS.USED &gt;= CTRL.LEVEL+1 and '0' when STATUS.USED &lt; CTRL.LEVEL+1 for the indicated FIFO. This interrupt is level based.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FIFO_INTR_SET</name>
            <description>FIFO Interrupt set request register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>FIFO_LEVEL_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.
Write with '0' to clear corresponding bit in interrupt request register.
NOTE: This register has different functionality than normal event based interrupt register as this interrupt is LEVEL based</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FIFO_INTR_MASK</name>
            <description>FIFO Interrupt mask register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>FIFO_LEVEL_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FIFO_INTR_MASKED</name>
            <description>FIFO Interrupt masked request register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>FIFO_LEVEL_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HPPASS_INTR</name>
            <description>MCPASS Interrupt request register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17FF</resetMask>
            <fields>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>HW sets this field to '1', when writing to a full FIFO. See FIFO_CFG/STATUS (read and write pointers) and FIFO_CFG/USED register for detailed infomration.
Write with '1' to clear bit.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>HW sets this field to '1', when reading from an empty FIFO.. See FIFO_CFG/STATUS (read and write pointers) and FIFO_CFG/USED register for detailed infomration.
Write with '1' to clear bit.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESULT_OVERFLOW</name>
                <description>HW sets this field to '1 on RESULT overflow.  This bit is set when new SAR Entry or FIR results are written and the associated bit the the INTR_SAR_RESULT register bit is set, implying the previous results have not been read.
To determine which Entry or FIR results caused this see SAR_CFG/RESULT_OVERFLOW.
Write a '1' to clear this bit.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENTRY_TR_COLLISION</name>
                <description>HW sets this bit if a SAR Entry trigger is asserted while that Entry is in progress, from triggering until conversion is complete.
Write a '1' to clear this bit.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENTRY_HOLD_VIOLATION</name>
                <description>HW sets this bit if the samplers in a SAR Entry are in HOLD state longer than the programmed count value .
Write a '1' to clear this bit.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AC_INT</name>
                <description>HW sets this field to '1', when the AC generates a programmed interrupt.
Write with '1' to clear bit.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HPPASS_INTR_SET</name>
            <description>MCPASS Interrupt set request register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17FF</resetMask>
            <fields>
              <field>
                <name>FIFO_OVERFLOW_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register. (a write of '0' has no effect).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register. (a write of '0' has no effect).</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESULT_OVERFLOW_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register. (a write of '0' has no effect).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENTRY_TR_COLLISION_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register. (a write of '0' has no effect).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENTRY_HOLD_VIOLATION_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register. (a write of '0' has no effect).</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AC_INT_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register. (a write of '0' has no effect).</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HPPASS_INTR_MASK</name>
            <description>MCPASS Interrupt mask register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17FF</resetMask>
            <fields>
              <field>
                <name>FIFO_OVERFLOW_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESULT_OVERFLOW_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENTRY_TR_COLLISION_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENTRY_HOLD_VIOLATION_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AC_INT_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HPPASS_INTR_MASKED</name>
            <description>MCPASS Interrupt masked request register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17FF</resetMask>
            <fields>
              <field>
                <name>FIFO_OVERFLOW_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESULT_OVERFLOW_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ENTRY_TR_COLLISION_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ENTRY_HOLD_VIOLATION_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AC_INT_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_LEVEL_CFG</name>
            <description>LEVEL Trigger out configuration</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>BYPASS_SYNC</name>
                <description>When this bit is set, the output flip-flop for the given TR_LEVEL_OUT is bypassed.
This option may only be used if the trigger is considered asynchronous and the destination has double sync input.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_LEVEL_OUT[%s]</name>
            <description>LEVEL Trigger out select register</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CMP_TR</name>
                <description>Enable the selected CMP outputs which are then ORed and routed to the associated trigger</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SAR_RANGE_TR</name>
                <description>Enable the selected SAR_RANGE output which are then ORed and routed to the associated trigger</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_PULSE_OUT[%s]</name>
            <description>PULSE Trigger out select register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>SEL</name>
                <description>Enable one of the available pulse trigger outputs for the associated trigger</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAR_ENTRY0_DONE</name>
                    <description>Entry results are ready for reading in the CHAN_RESULT registers</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAR_ENTRY1_DONE</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAR_ENTRY2_DONE</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAR_ENTRY3_DONE</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAR_ENTRY4_DONE</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAR_ENTRY5_DONE</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAR_ENTRY6_DONE</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAR_ENTRY7_DONE</name>
                    <description>N/A</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAR_FIR0_DONE</name>
                    <description>FIR results are ready for reading in the FIR_RESULT registers</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SAR_FIR1_DONE</name>
                    <description>N/A</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AC_TR</name>
                    <description>N/A</description>
                    <value>11</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <cluster>
            <name>FIFO</name>
            <description>FIFO Configuration</description>
            <addressOffset>0x00000100</addressOffset>
            <register>
              <name>CFG</name>
              <description>FIFO configuration register.</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF3</resetMask>
              <fields>
                <field>
                  <name>SEL</name>
                  <description>N/A</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FIFO_TR_EN</name>
                  <description>Enable associated FIFO trigger</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CLR</name>
              <description>FIFO FW clear register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF</resetMask>
              <fields>
                <field>
                  <name>CLR</name>
                  <description>Write a '1' to clear status for associtaed FIFO.  This doesn't actually clear the data, it just resets the pointers.
HW write a '1' to clear the bit when the reset is completed.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>4</dim>
              <dimIncrement>4</dimIncrement>
              <name>LEVEL[%s]</name>
              <description>FIFO level register.</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>LEVEL</name>
                  <description>FIFO level set.  A trigger (and optional interrupt) event occurs when USED.USED = LEVEL+1.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>4</dim>
              <dimIncrement>4</dimIncrement>
              <name>RD_DATA[%s]</name>
              <description>FIFO 32-bit read data register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>RESULT</name>
                  <description>5-bit Channel ID (upper bits), 16-bit SAR/FIR result (lower bits)
See SAR_CFG.CHAN_CFG.FIFO_SEL and SAR_CFG.FIR_CFG.FIFO_SEL registers to select a target FIFO.
See SAR_CFG.CTRL.CHAN_ID_EN to optionally include a channel ID, otherwise these bits are 0</description>
                  <bitRange>[20:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>4</dim>
              <dimIncrement>4</dimIncrement>
              <name>USED[%s]</name>
              <description>FIFO used register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>USED</name>
                  <description>Number of used/occupied entries in the FIFO.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <dim>4</dim>
              <dimIncrement>4</dimIncrement>
              <name>STATUS[%s]</name>
              <description>FIFO status register</description>
              <addressOffset>0x70</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F001F</resetMask>
              <fields>
                <field>
                  <name>RD_PTR</name>
                  <description>FIFO read pointer: FIFO location from which a data is read.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WR_PTR</name>
                  <description>FIFO write pointer: FIFO location at which a new data is written by the hardware.

Note: This functionality is intended for debugging purposes.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
  </peripherals>
</device>