<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: Port Interrupt Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__gpio__functions__interrupt.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Port Interrupt Functions<div class="ingroups"><a class="el" href="group__group__gpio.html">GPIO         (General Purpose Input Output)</a> &raquo; <a class="el" href="group__group__gpio__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadaedeffcd439cca04cd81e20731ade0d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#gadaedeffcd439cca04cd81e20731ade0d">Cy_GPIO_GetInterruptStatus</a> (<a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *base, uint32_t pinNum)</td></tr>
<tr class="memdesc:gadaedeffcd439cca04cd81e20731ade0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current unmasked interrupt state of the pin.  <a href="#gadaedeffcd439cca04cd81e20731ade0d">More...</a><br /></td></tr>
<tr class="separator:gadaedeffcd439cca04cd81e20731ade0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae0b45e44224b8387f5e3deb8f671a1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#gaae0b45e44224b8387f5e3deb8f671a1d">Cy_GPIO_ClearInterrupt</a> (<a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *base, uint32_t pinNum)</td></tr>
<tr class="memdesc:gaae0b45e44224b8387f5e3deb8f671a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the triggered pin interrupt.  <a href="#gaae0b45e44224b8387f5e3deb8f671a1d">More...</a><br /></td></tr>
<tr class="separator:gaae0b45e44224b8387f5e3deb8f671a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a32bd22c79ffcea82ce97ac73d1a6da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#ga0a32bd22c79ffcea82ce97ac73d1a6da">Cy_GPIO_SetInterruptMask</a> (<a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *base, uint32_t pinNum, uint32_t value)</td></tr>
<tr class="memdesc:ga0a32bd22c79ffcea82ce97ac73d1a6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the pin interrupt to be forwarded to the CPU NVIC.  <a href="#ga0a32bd22c79ffcea82ce97ac73d1a6da">More...</a><br /></td></tr>
<tr class="separator:ga0a32bd22c79ffcea82ce97ac73d1a6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95f5b3388753919b2174f6219d720675"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#ga95f5b3388753919b2174f6219d720675">Cy_GPIO_GetInterruptMask</a> (<a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *base, uint32_t pinNum)</td></tr>
<tr class="memdesc:ga95f5b3388753919b2174f6219d720675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state of the pin interrupt mask.  <a href="#ga95f5b3388753919b2174f6219d720675">More...</a><br /></td></tr>
<tr class="separator:ga95f5b3388753919b2174f6219d720675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf39ab24efa69ed432e3b38382adf3c26"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#gaf39ab24efa69ed432e3b38382adf3c26">Cy_GPIO_GetInterruptStatusMasked</a> (<a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *base, uint32_t pinNum)</td></tr>
<tr class="memdesc:gaf39ab24efa69ed432e3b38382adf3c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pin's current interrupt state after being masked.  <a href="#gaf39ab24efa69ed432e3b38382adf3c26">More...</a><br /></td></tr>
<tr class="separator:gaf39ab24efa69ed432e3b38382adf3c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e0559c5988372b57f4546443e824b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#ga16e0559c5988372b57f4546443e824b8">Cy_GPIO_SetSwInterrupt</a> (<a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *base, uint32_t pinNum)</td></tr>
<tr class="memdesc:ga16e0559c5988372b57f4546443e824b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a pin interrupt to trigger.  <a href="#ga16e0559c5988372b57f4546443e824b8">More...</a><br /></td></tr>
<tr class="separator:ga16e0559c5988372b57f4546443e824b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd69c3618483865a278e7dbd3f6dc78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#gacbd69c3618483865a278e7dbd3f6dc78">Cy_GPIO_SetInterruptEdge</a> (<a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *base, uint32_t pinNum, uint32_t value)</td></tr>
<tr class="memdesc:gacbd69c3618483865a278e7dbd3f6dc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the type of edge that will trigger a pin interrupt.  <a href="#gacbd69c3618483865a278e7dbd3f6dc78">More...</a><br /></td></tr>
<tr class="separator:gacbd69c3618483865a278e7dbd3f6dc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3f1c17c1638ac1e7725c1de441fad8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#gaee3f1c17c1638ac1e7725c1de441fad8">Cy_GPIO_GetInterruptEdge</a> (<a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *base, uint32_t pinNum)</td></tr>
<tr class="memdesc:gaee3f1c17c1638ac1e7725c1de441fad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current pin interrupt edge type.  <a href="#gaee3f1c17c1638ac1e7725c1de441fad8">More...</a><br /></td></tr>
<tr class="separator:gaee3f1c17c1638ac1e7725c1de441fad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38dabdc7f8169d9abf83f8c520613f6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#ga38dabdc7f8169d9abf83f8c520613f6e">Cy_GPIO_SetFilter</a> (<a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *base, uint32_t value)</td></tr>
<tr class="memdesc:ga38dabdc7f8169d9abf83f8c520613f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures which pin on the port connects to the port-specific glitch filter.  <a href="#ga38dabdc7f8169d9abf83f8c520613f6e">More...</a><br /></td></tr>
<tr class="separator:ga38dabdc7f8169d9abf83f8c520613f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c06d361814ac341d48135ade26efd1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#ga01c06d361814ac341d48135ade26efd1">Cy_GPIO_GetFilter</a> (<a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *base)</td></tr>
<tr class="memdesc:ga01c06d361814ac341d48135ade26efd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns which pin is currently configured to connect to the port-specific glitch filter.  <a href="#ga01c06d361814ac341d48135ade26efd1">More...</a><br /></td></tr>
<tr class="separator:ga01c06d361814ac341d48135ade26efd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda3b3cb4be20df7d008771e30974fb2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#gadda3b3cb4be20df7d008771e30974fb2">Cy_GPIO_GetInterruptCause0</a> (void)</td></tr>
<tr class="memdesc:gadda3b3cb4be20df7d008771e30974fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt status for ports 0 to 31.  <a href="#gadda3b3cb4be20df7d008771e30974fb2">More...</a><br /></td></tr>
<tr class="separator:gadda3b3cb4be20df7d008771e30974fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8850233bb9c0343a2b9746e640d5ba"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#ga7f8850233bb9c0343a2b9746e640d5ba">Cy_GPIO_GetInterruptCause1</a> (void)</td></tr>
<tr class="memdesc:ga7f8850233bb9c0343a2b9746e640d5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt status for ports 32 to 63.  <a href="#ga7f8850233bb9c0343a2b9746e640d5ba">More...</a><br /></td></tr>
<tr class="separator:ga7f8850233bb9c0343a2b9746e640d5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga903c984fb0d24e2cc36399a736a891b6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#ga903c984fb0d24e2cc36399a736a891b6">Cy_GPIO_GetInterruptCause2</a> (void)</td></tr>
<tr class="memdesc:ga903c984fb0d24e2cc36399a736a891b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt status for ports 64 to 95.  <a href="#ga903c984fb0d24e2cc36399a736a891b6">More...</a><br /></td></tr>
<tr class="separator:ga903c984fb0d24e2cc36399a736a891b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35a9fe350709ea8b2fc104913c609db2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__gpio__functions__interrupt.html#ga35a9fe350709ea8b2fc104913c609db2">Cy_GPIO_GetInterruptCause3</a> (void)</td></tr>
<tr class="memdesc:ga35a9fe350709ea8b2fc104913c609db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt status for ports 96 to 127.  <a href="#ga35a9fe350709ea8b2fc104913c609db2">More...</a><br /></td></tr>
<tr class="separator:ga35a9fe350709ea8b2fc104913c609db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadaedeffcd439cca04cd81e20731ade0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaedeffcd439cca04cd81e20731ade0d">&#9670;&nbsp;</a></span>Cy_GPIO_GetInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_GPIO_GetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current unmasked interrupt state of the pin. </p>
<p>The core processor's NVIC is triggered by the masked interrupt bits. This function allows reading the unmasked interrupt state. Whether the bit positions actually trigger the interrupt are defined by the interrupt mask bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the pin's port register base address</td></tr>
    <tr><td class="paramname">pinNum</td><td>Position of the pin bit-field within the port register Bit position 8 is the routed pin through the port glitch filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = Pin interrupt condition not detected 1 = Pin interrupt condition detected</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Clear stale (unmasked) port interrupts before reconfiguration */</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span>(1UL == <a class="code" href="group__group__gpio__functions__interrupt.html#gadaedeffcd439cca04cd81e20731ade0d">Cy_GPIO_GetInterruptStatus</a>(P0_3_PORT, P0_3_NUM))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Clear the P0.3 interrupt */</span></div><div class="line">        <a class="code" href="group__group__gpio__functions__interrupt.html#gaae0b45e44224b8387f5e3deb8f671a1d">Cy_GPIO_ClearInterrupt</a>(P0_3_PORT, P0_3_NUM);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaae0b45e44224b8387f5e3deb8f671a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae0b45e44224b8387f5e3deb8f671a1d">&#9670;&nbsp;</a></span>Cy_GPIO_ClearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_GPIO_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the triggered pin interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the pin's port register base address</td></tr>
    <tr><td class="paramname">pinNum</td><td>Position of the pin bit-field within the port register Bit position 8 is the routed pin through the port glitch filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Inside the interrupt service routine of port 0 interrupt */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Clear the P0.3 interrupt */</span></div><div class="line">    <a class="code" href="group__group__gpio__functions__interrupt.html#gaae0b45e44224b8387f5e3deb8f671a1d">Cy_GPIO_ClearInterrupt</a>(P0_3_PORT, P0_3_NUM);</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga0a32bd22c79ffcea82ce97ac73d1a6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a32bd22c79ffcea82ce97ac73d1a6da">&#9670;&nbsp;</a></span>Cy_GPIO_SetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_GPIO_SetInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the pin interrupt to be forwarded to the CPU NVIC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the pin's port register base address</td></tr>
    <tr><td class="paramname">pinNum</td><td>Position of the pin bit-field within the port register. Bit position 8 is the routed pin through the port glitch filter.</td></tr>
    <tr><td class="paramname">value</td><td>0 = Pin interrupt not forwarded to CPU interrupt controller 1 = Pin interrupt masked and forwarded to CPU interrupt controller</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function modifies a port register in a read-modify-write operation. It is not thread safe as the resource is shared among multiple pins on a port.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Need port interrupt to trigger on P0.3 */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Get the interrupt mask of P0.3 */</span></div><div class="line">    <span class="keywordflow">if</span>(0UL == <a class="code" href="group__group__gpio__functions__interrupt.html#ga95f5b3388753919b2174f6219d720675">Cy_GPIO_GetInterruptMask</a>(P0_3_PORT, P0_3_NUM))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the interrupt mask of P0.3 */</span></div><div class="line">        <a class="code" href="group__group__gpio__functions__interrupt.html#ga0a32bd22c79ffcea82ce97ac73d1a6da">Cy_GPIO_SetInterruptMask</a>(P0_3_PORT, P0_3_NUM, 1UL);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga95f5b3388753919b2174f6219d720675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95f5b3388753919b2174f6219d720675">&#9670;&nbsp;</a></span>Cy_GPIO_GetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_GPIO_GetInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the state of the pin interrupt mask. </p>
<p>This mask is used to determine whether the pin is configured to be forwarded to the CPU NVIC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the pin's port register base address</td></tr>
    <tr><td class="paramname">pinNum</td><td>Position of the pin bit-field within the port register. Bit position 8 is the routed pin through the port glitch filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = Pin interrupt not forwarded to CPU interrupt controller 1 = Pin interrupt masked and forwarded to CPU interrupt controller</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Need port interrupt to trigger on P0.3 */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Get the interrupt mask of P0.3 */</span></div><div class="line">    <span class="keywordflow">if</span>(0UL == <a class="code" href="group__group__gpio__functions__interrupt.html#ga95f5b3388753919b2174f6219d720675">Cy_GPIO_GetInterruptMask</a>(P0_3_PORT, P0_3_NUM))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the interrupt mask of P0.3 */</span></div><div class="line">        <a class="code" href="group__group__gpio__functions__interrupt.html#ga0a32bd22c79ffcea82ce97ac73d1a6da">Cy_GPIO_SetInterruptMask</a>(P0_3_PORT, P0_3_NUM, 1UL);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaf39ab24efa69ed432e3b38382adf3c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf39ab24efa69ed432e3b38382adf3c26">&#9670;&nbsp;</a></span>Cy_GPIO_GetInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_GPIO_GetInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the pin's current interrupt state after being masked. </p>
<p>The core processor's NVIC is triggered by the masked interrupt bits. This function allows reading this masked interrupt state. Note that the bits that are not masked will not be forwarded to the NVIC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the pin's port register base address</td></tr>
    <tr><td class="paramname">pinNum</td><td>Position of the pin bit-field within the port register. Bit position 8 is the routed pin through the port glitch filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = Pin interrupt not detected or not forwarded to CPU interrupt controller 1 = Pin interrupt detected and forwarded to CPU interrupt controller</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Inside the interrupt service routine of port 0 interrupt */</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span>(1UL == <a class="code" href="group__group__gpio__functions__interrupt.html#gaf39ab24efa69ed432e3b38382adf3c26">Cy_GPIO_GetInterruptStatusMasked</a>(P0_3_PORT, P0_3_NUM))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Clear the P0.3 interrupt */</span></div><div class="line">        <a class="code" href="group__group__gpio__functions__interrupt.html#gaae0b45e44224b8387f5e3deb8f671a1d">Cy_GPIO_ClearInterrupt</a>(P0_3_PORT, P0_3_NUM);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga16e0559c5988372b57f4546443e824b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16e0559c5988372b57f4546443e824b8">&#9670;&nbsp;</a></span>Cy_GPIO_SetSwInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_GPIO_SetSwInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a pin interrupt to trigger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the pin's port register base address</td></tr>
    <tr><td class="paramname">pinNum</td><td>Position of the pin bit-field within the port register. Bit position 8 is the routed pin through the port glitch filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Test that the port interrupt triggers */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Set the P0.3 interrupt through software */</span></div><div class="line">    <a class="code" href="group__group__gpio__functions__interrupt.html#ga16e0559c5988372b57f4546443e824b8">Cy_GPIO_SetSwInterrupt</a>(P0_3_PORT, P0_3_NUM);</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gacbd69c3618483865a278e7dbd3f6dc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbd69c3618483865a278e7dbd3f6dc78">&#9670;&nbsp;</a></span>Cy_GPIO_SetInterruptEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_GPIO_SetInterruptEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the type of edge that will trigger a pin interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the pin's port register base address</td></tr>
    <tr><td class="paramname">pinNum</td><td>Position of the pin bit-field within the port register. Bit position 8 is the routed pin through the port glitch filter.</td></tr>
    <tr><td class="paramname">value</td><td>Pin interrupt mode. Options are detailed in <a class="el" href="group__group__gpio__interrupt_trigger.html">Interrupt trigger type</a> macros</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function modifies a port register in a read-modify-write operation. It is not thread safe as the resource is shared among multiple pins on a port.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Update the port interrupt trigger type to falling edge */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Get the interrupt edge setting of P0.3 */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__gpio__interrupt_trigger.html#gafbaa3f5dff9b5689cdb43bb07c7c6fef">CY_GPIO_INTR_RISING</a> == <a class="code" href="group__group__gpio__functions__interrupt.html#gaee3f1c17c1638ac1e7725c1de441fad8">Cy_GPIO_GetInterruptEdge</a>(P0_3_PORT, P0_3_NUM))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the interrupt trigger type to falling edge for P0.3 */</span></div><div class="line">        <a class="code" href="group__group__gpio__functions__interrupt.html#gacbd69c3618483865a278e7dbd3f6dc78">Cy_GPIO_SetInterruptEdge</a>(P0_3_PORT, P0_3_NUM, <a class="code" href="group__group__gpio__interrupt_trigger.html#ga2b72e6abd555cceea2baa9f62eac5ed4">CY_GPIO_INTR_FALLING</a>);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaee3f1c17c1638ac1e7725c1de441fad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee3f1c17c1638ac1e7725c1de441fad8">&#9670;&nbsp;</a></span>Cy_GPIO_GetInterruptEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_GPIO_GetInterruptEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current pin interrupt edge type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the pin's port register base address</td></tr>
    <tr><td class="paramname">pinNum</td><td>Position of the pin bit-field within the port register. Bit position 8 is the routed pin through the port glitch filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pin interrupt mode. Options are detailed in <a class="el" href="group__group__gpio__interrupt_trigger.html">Interrupt trigger type</a> macros</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Update the port interrupt trigger type to falling edge */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Get the interrupt edge setting of P0.3 */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__gpio__interrupt_trigger.html#gafbaa3f5dff9b5689cdb43bb07c7c6fef">CY_GPIO_INTR_RISING</a> == <a class="code" href="group__group__gpio__functions__interrupt.html#gaee3f1c17c1638ac1e7725c1de441fad8">Cy_GPIO_GetInterruptEdge</a>(P0_3_PORT, P0_3_NUM))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the interrupt trigger type to falling edge for P0.3 */</span></div><div class="line">        <a class="code" href="group__group__gpio__functions__interrupt.html#gacbd69c3618483865a278e7dbd3f6dc78">Cy_GPIO_SetInterruptEdge</a>(P0_3_PORT, P0_3_NUM, <a class="code" href="group__group__gpio__interrupt_trigger.html#ga2b72e6abd555cceea2baa9f62eac5ed4">CY_GPIO_INTR_FALLING</a>);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga38dabdc7f8169d9abf83f8c520613f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38dabdc7f8169d9abf83f8c520613f6e">&#9670;&nbsp;</a></span>Cy_GPIO_SetFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_GPIO_SetFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures which pin on the port connects to the port-specific glitch filter. </p>
<p>Each port contains a single 50ns glitch filter. Any of the pins on the port can be routed to this filter such that the input signal is filtered before reaching the edge-detect interrupt circuitry. The state of the filtered pin can also be read by calling the <a class="el" href="group__group__gpio__functions__gpio.html#ga4fa0bdf7c0dc3e734e4f76a093f9fd02" title="Reads the current logic level on the input buffer of the pin. ">Cy_GPIO_Read()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the pin's port register base address</td></tr>
    <tr><td class="paramname">value</td><td>The number of the port pin to route to the port filter (0...7)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function modifies a port register in a read-modify-write operation. It is not thread safe as the resource is shared among multiple pins on a port.</dd>
<dd>
The filtered pin does not have an associated HSIOM connection. Therefore it cannot be routed directly to other peripherals in hardware.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Utilize the glitch filter for input signal on P0.3 */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Get the source of the port 0 glitch filter */</span></div><div class="line">    <span class="keywordflow">if</span>(P0_3_NUM != <a class="code" href="group__group__gpio__functions__interrupt.html#ga01c06d361814ac341d48135ade26efd1">Cy_GPIO_GetFilter</a>(P0_3_PORT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the port 0 glitch filter source to be P0.3 */</span></div><div class="line">        <a class="code" href="group__group__gpio__functions__interrupt.html#ga38dabdc7f8169d9abf83f8c520613f6e">Cy_GPIO_SetFilter</a>(P0_3_PORT, P0_3_NUM);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga01c06d361814ac341d48135ade26efd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01c06d361814ac341d48135ade26efd1">&#9670;&nbsp;</a></span>Cy_GPIO_GetFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_GPIO_GetFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_i_o___p_r_t___type.html">GPIO_PRT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns which pin is currently configured to connect to the port-specific glitch filter. </p>
<p>Each port contains a single 50ns glitch filter. Any of the pins on the port can be routed to this filter such that the input signal is filtered before reaching the edge-detect interrupt circuitry. The state of the filtered pin can also be read by calling the <a class="el" href="group__group__gpio__functions__gpio.html#ga4fa0bdf7c0dc3e734e4f76a093f9fd02" title="Reads the current logic level on the input buffer of the pin. ">Cy_GPIO_Read()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the pin's port register base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of the port pin routed to the port filter (0...7)</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Utilize the glitch filter for input signal on P0.3 */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Get the source of the port 0 glitch filter */</span></div><div class="line">    <span class="keywordflow">if</span>(P0_3_NUM != <a class="code" href="group__group__gpio__functions__interrupt.html#ga01c06d361814ac341d48135ade26efd1">Cy_GPIO_GetFilter</a>(P0_3_PORT))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the port 0 glitch filter source to be P0.3 */</span></div><div class="line">        <a class="code" href="group__group__gpio__functions__interrupt.html#ga38dabdc7f8169d9abf83f8c520613f6e">Cy_GPIO_SetFilter</a>(P0_3_PORT, P0_3_NUM);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gadda3b3cb4be20df7d008771e30974fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadda3b3cb4be20df7d008771e30974fb2">&#9670;&nbsp;</a></span>Cy_GPIO_GetInterruptCause0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_GPIO_GetInterruptCause0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the interrupt status for ports 0 to 31. </p>
<dl class="section return"><dt>Returns</dt><dd>0 = Interrupt not detected on port 1 = Interrupt detected on port</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Inside the interrupt service routine of &quot;all port&quot; interrupt */</span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define PORT0_INTR_MASK  0x00000001UL</span></div><div class="line">    uint32_t intrSrc = <a class="code" href="group__group__gpio__functions__interrupt.html#gadda3b3cb4be20df7d008771e30974fb2">Cy_GPIO_GetInterruptCause0</a>();</div><div class="line">    </div><div class="line">    <span class="comment">/* Check if the interrupt was from port 0 */</span></div><div class="line">    <span class="keywordflow">if</span>(PORT0_INTR_MASK == (intrSrc &amp; PORT0_INTR_MASK))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>(1UL == <a class="code" href="group__group__gpio__functions__interrupt.html#gaf39ab24efa69ed432e3b38382adf3c26">Cy_GPIO_GetInterruptStatusMasked</a>(P0_3_PORT, P0_3_NUM))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Clear the P0.3 interrupt */</span></div><div class="line">            <a class="code" href="group__group__gpio__functions__interrupt.html#gaae0b45e44224b8387f5e3deb8f671a1d">Cy_GPIO_ClearInterrupt</a>(P0_3_PORT, P0_3_NUM);</div><div class="line">        }</div><div class="line">    }       </div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7f8850233bb9c0343a2b9746e640d5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f8850233bb9c0343a2b9746e640d5ba">&#9670;&nbsp;</a></span>Cy_GPIO_GetInterruptCause1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_GPIO_GetInterruptCause1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the interrupt status for ports 32 to 63. </p>
<dl class="section return"><dt>Returns</dt><dd>0 = Interrupt not detected on port 1 = Interrupt detected on port</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd>Refer to the <a class="el" href="group__group__gpio__functions__interrupt.html#gadda3b3cb4be20df7d008771e30974fb2" title="Returns the interrupt status for ports 0 to 31. ">Cy_GPIO_GetInterruptCause0()</a> example. </dd></dl>

</div>
</div>
<a id="ga903c984fb0d24e2cc36399a736a891b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga903c984fb0d24e2cc36399a736a891b6">&#9670;&nbsp;</a></span>Cy_GPIO_GetInterruptCause2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_GPIO_GetInterruptCause2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the interrupt status for ports 64 to 95. </p>
<dl class="section return"><dt>Returns</dt><dd>0 = Interrupt not detected on port 1 = Interrupt detected on port </dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd>Refer to the <a class="el" href="group__group__gpio__functions__interrupt.html#gadda3b3cb4be20df7d008771e30974fb2" title="Returns the interrupt status for ports 0 to 31. ">Cy_GPIO_GetInterruptCause0()</a> example. </dd></dl>

</div>
</div>
<a id="ga35a9fe350709ea8b2fc104913c609db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35a9fe350709ea8b2fc104913c609db2">&#9670;&nbsp;</a></span>Cy_GPIO_GetInterruptCause3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_GPIO_GetInterruptCause3 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the interrupt status for ports 96 to 127. </p>
<dl class="section return"><dt>Returns</dt><dd>0 = Interrupt not detected on port 1 = Interrupt detected on port</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd>Refer to the <a class="el" href="group__group__gpio__functions__interrupt.html#gadda3b3cb4be20df7d008771e30974fb2" title="Returns the interrupt status for ports 0 to 31. ">Cy_GPIO_GetInterruptCause0()</a> example. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
