<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__flash__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__flash.html">Flash        (Flash System Routine)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8457cc408eb5f9eaf573b7303a92b13e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga8457cc408eb5f9eaf573b7303a92b13e">Cy_Flashc_MainWriteEnable</a> (void)</td></tr>
<tr class="memdesc:ga8457cc408eb5f9eaf573b7303a92b13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable writing to main flash.  <a href="#ga8457cc408eb5f9eaf573b7303a92b13e">More...</a><br /></td></tr>
<tr class="separator:ga8457cc408eb5f9eaf573b7303a92b13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6182b2ee98bda81b66036837b3a078f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga6182b2ee98bda81b66036837b3a078f7">Cy_Flashc_MainWriteDisable</a> (void)</td></tr>
<tr class="memdesc:ga6182b2ee98bda81b66036837b3a078f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable writing to main flash Disables writing to main flash.  <a href="#ga6182b2ee98bda81b66036837b3a078f7">More...</a><br /></td></tr>
<tr class="separator:ga6182b2ee98bda81b66036837b3a078f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff727b87261a3593e18b4d44a04100f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gaff727b87261a3593e18b4d44a04100f8">Cy_Flashc_WorkWriteEnable</a> (void)</td></tr>
<tr class="memdesc:gaff727b87261a3593e18b4d44a04100f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable writing work flash Work Flash embedded operations are enabled.  <a href="#gaff727b87261a3593e18b4d44a04100f8">More...</a><br /></td></tr>
<tr class="separator:gaff727b87261a3593e18b4d44a04100f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86be3053111defaf2ab3439f4dc58348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga86be3053111defaf2ab3439f4dc58348">Cy_Flashc_WorkWriteDisable</a> (void)</td></tr>
<tr class="memdesc:ga86be3053111defaf2ab3439f4dc58348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable writing work flash Work Flash embedded operations are blocked.  <a href="#ga86be3053111defaf2ab3439f4dc58348">More...</a><br /></td></tr>
<tr class="separator:ga86be3053111defaf2ab3439f4dc58348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c6206b38501114957cc4541670f064"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga62c6206b38501114957cc4541670f064">Cy_Flashc_WorkECCEnable</a> (void)</td></tr>
<tr class="memdesc:ga62c6206b38501114957cc4541670f064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables ECC for work flash ECC checking/reporting on FLASH work interface is enabled.  <a href="#ga62c6206b38501114957cc4541670f064">More...</a><br /></td></tr>
<tr class="separator:ga62c6206b38501114957cc4541670f064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14f23bb58900a56a4c28b823fde19049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga14f23bb58900a56a4c28b823fde19049">Cy_Flashc_WorkECCDisable</a> (void)</td></tr>
<tr class="memdesc:ga14f23bb58900a56a4c28b823fde19049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables ECC for work flash ECC checking/reporting on FLASH work interface is disabled.  <a href="#ga14f23bb58900a56a4c28b823fde19049">More...</a><br /></td></tr>
<tr class="separator:ga14f23bb58900a56a4c28b823fde19049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc2844b3a28e808c1ffde8c01b1c805"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga4bc2844b3a28e808c1ffde8c01b1c805">Cy_Flashc_MainECCEnable</a> (void)</td></tr>
<tr class="memdesc:ga4bc2844b3a28e808c1ffde8c01b1c805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables ECC for main flash ECC checking/reporting on FLASH main interface is enabled.  <a href="#ga4bc2844b3a28e808c1ffde8c01b1c805">More...</a><br /></td></tr>
<tr class="separator:ga4bc2844b3a28e808c1ffde8c01b1c805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb71555c199febf31048e808f08c284"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gadfb71555c199febf31048e808f08c284">Cy_Flashc_MainECCDisable</a> (void)</td></tr>
<tr class="memdesc:gadfb71555c199febf31048e808f08c284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables ECC for main flash.  <a href="#gadfb71555c199febf31048e808f08c284">More...</a><br /></td></tr>
<tr class="separator:gadfb71555c199febf31048e808f08c284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ea8baa8b0c67b9cc9caa0c022faeb43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga8ea8baa8b0c67b9cc9caa0c022faeb43">Cy_Flash_Program_WorkFlash</a> (const <a class="el" href="structcy__stc__flash__programrow__config__t.html">cy_stc_flash_programrow_config_t</a> *config)</td></tr>
<tr class="memdesc:ga8ea8baa8b0c67b9cc9caa0c022faeb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes an array data to work flash.  <a href="#ga8ea8baa8b0c67b9cc9caa0c022faeb43">More...</a><br /></td></tr>
<tr class="separator:ga8ea8baa8b0c67b9cc9caa0c022faeb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c9188232c336932c075b29677670434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga7c9188232c336932c075b29677670434">Cy_Flash_Program</a> (const <a class="el" href="structcy__stc__flash__programrow__config__t.html">cy_stc_flash_programrow_config_t</a> *config, <a class="el" href="group__group__flash__enumerated__types.html#ga6eca51e351cd0e73a59f92b7bd9c726f">cy_en_flash_driver_blocking_t</a> block)</td></tr>
<tr class="memdesc:ga7c9188232c336932c075b29677670434"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes an array of data to flash.  <a href="#ga7c9188232c336932c075b29677670434">More...</a><br /></td></tr>
<tr class="separator:ga7c9188232c336932c075b29677670434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e18868377bcfb2ace477e06361be5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga25e18868377bcfb2ace477e06361be5f">Cy_Flash_Checksum</a> (const <a class="el" href="structcy__stc__flash__checksum__config__t.html">cy_stc_flash_checksum_config_t</a> *config, uint32_t *checksumPtr)</td></tr>
<tr class="memdesc:ga25e18868377bcfb2ace477e06361be5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a checksum value of the specified flash row.  <a href="#ga25e18868377bcfb2ace477e06361be5f">More...</a><br /></td></tr>
<tr class="separator:ga25e18868377bcfb2ace477e06361be5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga805df2fa876eb23aee0627bcc5def58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga805df2fa876eb23aee0627bcc5def58e">Cy_Flash_EraseSuspend</a> (void)</td></tr>
<tr class="memdesc:ga805df2fa876eb23aee0627bcc5def58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function suspends an ongoing erase operation.  <a href="#ga805df2fa876eb23aee0627bcc5def58e">More...</a><br /></td></tr>
<tr class="separator:ga805df2fa876eb23aee0627bcc5def58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae03886b6268f6c2ebbde6c5c7511e105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gae03886b6268f6c2ebbde6c5c7511e105">Cy_Flash_EraseResume</a> (const <a class="el" href="structcy__stc__flash__eraseresume__config__t.html">cy_stc_flash_eraseresume_config_t</a> *config)</td></tr>
<tr class="memdesc:gae03886b6268f6c2ebbde6c5c7511e105"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls to resume a suspended erase operation.  <a href="#gae03886b6268f6c2ebbde6c5c7511e105">More...</a><br /></td></tr>
<tr class="separator:gae03886b6268f6c2ebbde6c5c7511e105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b3f5e3496cb0aecd06ac357f6af23c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga31b3f5e3496cb0aecd06ac357f6af23c">Cy_Flash_BlankCheck</a> (const <a class="el" href="structcy__stc__flash__blankcheck__config__t.html">cy_stc_flash_blankcheck_config_t</a> *config, <a class="el" href="group__group__flash__enumerated__types.html#ga6eca51e351cd0e73a59f92b7bd9c726f">cy_en_flash_driver_blocking_t</a> block)</td></tr>
<tr class="memdesc:ga31b3f5e3496cb0aecd06ac357f6af23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs blank check on the addressed work FLASH.  <a href="#ga31b3f5e3496cb0aecd06ac357f6af23c">More...</a><br /></td></tr>
<tr class="separator:ga31b3f5e3496cb0aecd06ac357f6af23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga078a8f5f01326202f20b0f6b7d32f7ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga078a8f5f01326202f20b0f6b7d32f7ba">Cy_Flash_OperationStatus</a> (void)</td></tr>
<tr class="memdesc:ga078a8f5f01326202f20b0f6b7d32f7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the status of the Flash Operation, and returns it.  <a href="#ga078a8f5f01326202f20b0f6b7d32f7ba">More...</a><br /></td></tr>
<tr class="separator:ga078a8f5f01326202f20b0f6b7d32f7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a3fa8c605ee60d146caa8b3734fedee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga2a3fa8c605ee60d146caa8b3734fedee">Cy_Flashc_InjectECC</a> (cy_en_region_t region, uint32_t address, uint8_t parity)</td></tr>
<tr class="memdesc:ga2a3fa8c605ee60d146caa8b3734fedee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables ECC injection and sets the address where a parity will be injected and the parity value.  <a href="#ga2a3fa8c605ee60d146caa8b3734fedee">More...</a><br /></td></tr>
<tr class="separator:ga2a3fa8c605ee60d146caa8b3734fedee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a313e212643285eca2aad738e365df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gaa1a313e212643285eca2aad738e365df">Cy_Flashc_SetWorkBankMode</a> (<a class="el" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> <a class="el" href="group__group__ipc__bt__data__structures.html#ga37e90f5e3bd99fac2021fb3a326607d4">mode</a>)</td></tr>
<tr class="memdesc:gaa1a313e212643285eca2aad738e365df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bank mode for work flash.  <a href="#gaa1a313e212643285eca2aad738e365df">More...</a><br /></td></tr>
<tr class="separator:gaa1a313e212643285eca2aad738e365df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a96bc07b10d09564724f39661b5f01c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga7a96bc07b10d09564724f39661b5f01c">Cy_Flashc_GetWorkBankMode</a> (void)</td></tr>
<tr class="memdesc:ga7a96bc07b10d09564724f39661b5f01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets current bank mode for work flash.  <a href="#ga7a96bc07b10d09564724f39661b5f01c">More...</a><br /></td></tr>
<tr class="separator:ga7a96bc07b10d09564724f39661b5f01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba1e7ca437a12c0df27007de2f3768b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gaba1e7ca437a12c0df27007de2f3768b8">Cy_Flashc_SetMainBankMode</a> (<a class="el" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> <a class="el" href="group__group__ipc__bt__data__structures.html#ga37e90f5e3bd99fac2021fb3a326607d4">mode</a>)</td></tr>
<tr class="memdesc:gaba1e7ca437a12c0df27007de2f3768b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bank mode for main flash.  <a href="#gaba1e7ca437a12c0df27007de2f3768b8">More...</a><br /></td></tr>
<tr class="separator:gaba1e7ca437a12c0df27007de2f3768b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95483efb2b8e1c38ec6b6f990f15c5e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga95483efb2b8e1c38ec6b6f990f15c5e9">Cy_Flashc_GetMainBankMode</a> (void)</td></tr>
<tr class="memdesc:ga95483efb2b8e1c38ec6b6f990f15c5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets current bank mode for main flash.  <a href="#ga95483efb2b8e1c38ec6b6f990f15c5e9">More...</a><br /></td></tr>
<tr class="separator:ga95483efb2b8e1c38ec6b6f990f15c5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61b907d56c35da075b1353f9f53ea0cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga61b907d56c35da075b1353f9f53ea0cc">Cy_Flashc_SetMain_Flash_Mapping</a> (<a class="el" href="group__group__flash__enumerated__types.html#ga977f3c56b8510500b008063d8cc5e543">cy_en_maptype_t</a> mapping)</td></tr>
<tr class="memdesc:ga61b907d56c35da075b1353f9f53ea0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets mapping for main flash region.  <a href="#ga61b907d56c35da075b1353f9f53ea0cc">More...</a><br /></td></tr>
<tr class="separator:ga61b907d56c35da075b1353f9f53ea0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga383d2ae70270ed056e50d72cc81cd4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga383d2ae70270ed056e50d72cc81cd4d3">Cy_Flashc_SetWork_Flash_Mapping</a> (<a class="el" href="group__group__flash__enumerated__types.html#ga977f3c56b8510500b008063d8cc5e543">cy_en_maptype_t</a> mapping)</td></tr>
<tr class="memdesc:ga383d2ae70270ed056e50d72cc81cd4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets mapping for work flash region.  <a href="#ga383d2ae70270ed056e50d72cc81cd4d3">More...</a><br /></td></tr>
<tr class="separator:ga383d2ae70270ed056e50d72cc81cd4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9753a9fca6ebea833cbc4af7f0d681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga6b9753a9fca6ebea833cbc4af7f0d681">Cy_Flash_EraseRow</a> (uint32_t rowAddr)</td></tr>
<tr class="memdesc:ga6b9753a9fca6ebea833cbc4af7f0d681"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases a single row of flash.  <a href="#ga6b9753a9fca6ebea833cbc4af7f0d681">More...</a><br /></td></tr>
<tr class="separator:ga6b9753a9fca6ebea833cbc4af7f0d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36c8da8da155cd73eaf3359f3f81af02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga36c8da8da155cd73eaf3359f3f81af02">Cy_Flash_StartEraseRow</a> (uint32_t rowAddr)</td></tr>
<tr class="memdesc:ga36c8da8da155cd73eaf3359f3f81af02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts erasing a single row of flash.  <a href="#ga36c8da8da155cd73eaf3359f3f81af02">More...</a><br /></td></tr>
<tr class="separator:ga36c8da8da155cd73eaf3359f3f81af02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb9cf4bec4ce4202604823cf0feb70ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gadb9cf4bec4ce4202604823cf0feb70ac">Cy_Flash_EraseSubsector</a> (uint32_t subSectorAddr)</td></tr>
<tr class="memdesc:gadb9cf4bec4ce4202604823cf0feb70ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases an 8-row subsector of flash.  <a href="#gadb9cf4bec4ce4202604823cf0feb70ac">More...</a><br /></td></tr>
<tr class="separator:gadb9cf4bec4ce4202604823cf0feb70ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732a0c229dd1acee3b36f1bba0045976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga732a0c229dd1acee3b36f1bba0045976">Cy_Flash_StartEraseSubsector</a> (uint32_t subSectorAddr)</td></tr>
<tr class="memdesc:ga732a0c229dd1acee3b36f1bba0045976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts erasing an 8-row subsector of flash.  <a href="#ga732a0c229dd1acee3b36f1bba0045976">More...</a><br /></td></tr>
<tr class="separator:ga732a0c229dd1acee3b36f1bba0045976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaa220a63444c4e5a5abe9b8c2cec721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gafaa220a63444c4e5a5abe9b8c2cec721">Cy_Flash_WriteRow</a> (uint32_t rowAddr, const uint32_t *data)</td></tr>
<tr class="memdesc:gafaa220a63444c4e5a5abe9b8c2cec721"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes an array of data to a single row of flash.  <a href="#gafaa220a63444c4e5a5abe9b8c2cec721">More...</a><br /></td></tr>
<tr class="separator:gafaa220a63444c4e5a5abe9b8c2cec721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc57348bb2e6922a65826bccad961fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gafc57348bb2e6922a65826bccad961fed">Cy_Flash_StartProgram</a> (uint32_t rowAddr, const uint32_t *data)</td></tr>
<tr class="memdesc:gafc57348bb2e6922a65826bccad961fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts writing an array of data to a single row of flash.  <a href="#gafc57348bb2e6922a65826bccad961fed">More...</a><br /></td></tr>
<tr class="separator:gafc57348bb2e6922a65826bccad961fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga607931427f2d4a2147c7c97ce96577e0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga607931427f2d4a2147c7c97ce96577e0">Cy_Flash_GetExternalStatus</a> (void)</td></tr>
<tr class="memdesc:ga607931427f2d4a2147c7c97ce96577e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles the case where a module such as security image captures a system call from this driver and reports its own status or error code, for example protection violation.  <a href="#ga607931427f2d4a2147c7c97ce96577e0">More...</a><br /></td></tr>
<tr class="separator:ga607931427f2d4a2147c7c97ce96577e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daa482b7696dcb6e06f0776e0ca725a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga3daa482b7696dcb6e06f0776e0ca725a">Cy_Flash_InitExt</a> (<a class="el" href="structcy__stc__flash__notify__t.html">cy_stc_flash_notify_t</a> *ipcWaitMessageAddr)</td></tr>
<tr class="memdesc:ga3daa482b7696dcb6e06f0776e0ca725a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates all needed prerequisites to support flash erase/write.  <a href="#ga3daa482b7696dcb6e06f0776e0ca725a">More...</a><br /></td></tr>
<tr class="separator:ga3daa482b7696dcb6e06f0776e0ca725a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436020eae198750c56b93dbabdf6dc6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete</a> (void)</td></tr>
<tr class="memdesc:ga436020eae198750c56b93dbabdf6dc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a successful operation result, reason of failure or busy status ( <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a9ddac0d7038bbdfe57db1acbeac9df82">CY_FLASH_DRV_OPCODE_BUSY</a> ).  <a href="#ga436020eae198750c56b93dbabdf6dc6d">More...</a><br /></td></tr>
<tr class="separator:ga436020eae198750c56b93dbabdf6dc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafed287628c010c2258f73c5777b52292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292">Cy_Flash_StartWrite</a> (uint32_t rowAddr, const uint32_t *data)</td></tr>
<tr class="memdesc:gafed287628c010c2258f73c5777b52292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts programming the flash row with the input data.  <a href="#gafed287628c010c2258f73c5777b52292">More...</a><br /></td></tr>
<tr class="separator:gafed287628c010c2258f73c5777b52292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42900a5b1b692efc825083c262cc2d7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga42900a5b1b692efc825083c262cc2d7d">Cy_Flash_StartEraseSector</a> (uint32_t sectorAddr)</td></tr>
<tr class="memdesc:ga42900a5b1b692efc825083c262cc2d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts erasing a sector of flash.  <a href="#ga42900a5b1b692efc825083c262cc2d7d">More...</a><br /></td></tr>
<tr class="separator:ga42900a5b1b692efc825083c262cc2d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5218274c43e64791cf28f902d15a355a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga5218274c43e64791cf28f902d15a355a">Cy_Flash_ProgramRow</a> (uint32_t rowAddr, const uint32_t *data)</td></tr>
<tr class="memdesc:ga5218274c43e64791cf28f902d15a355a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes an array of data to a single row of flash.  <a href="#ga5218274c43e64791cf28f902d15a355a">More...</a><br /></td></tr>
<tr class="separator:ga5218274c43e64791cf28f902d15a355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e040ae57d5c4f717b1918eda77ecc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga23e040ae57d5c4f717b1918eda77ecc5">Cy_Flash_EraseSector</a> (uint32_t sectorAddr)</td></tr>
<tr class="memdesc:ga23e040ae57d5c4f717b1918eda77ecc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases a sector of flash.  <a href="#ga23e040ae57d5c4f717b1918eda77ecc5">More...</a><br /></td></tr>
<tr class="separator:ga23e040ae57d5c4f717b1918eda77ecc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f948f4d096b9f93488a889a011bda14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga3f948f4d096b9f93488a889a011bda14">Cy_Flash_CalculateHash</a> (const uint32_t *data, uint32_t numberOfBytes, uint32_t *hashPtr)</td></tr>
<tr class="memdesc:ga3f948f4d096b9f93488a889a011bda14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash value of the specified region of flash.  <a href="#ga3f948f4d096b9f93488a889a011bda14">More...</a><br /></td></tr>
<tr class="separator:ga3f948f4d096b9f93488a889a011bda14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ac711091186d8a7790be298fb6148b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga29ac711091186d8a7790be298fb6148b">Cy_Flash_RowChecksum</a> (uint32_t rowAddr, uint32_t *checksumPtr)</td></tr>
<tr class="memdesc:ga29ac711091186d8a7790be298fb6148b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a checksum value of the specified flash row.  <a href="#ga29ac711091186d8a7790be298fb6148b">More...</a><br /></td></tr>
<tr class="separator:ga29ac711091186d8a7790be298fb6148b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b44a029169a1baa08e211bff714a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19">Cy_Flash_Init</a> (void)</td></tr>
<tr class="memdesc:gaf1b44a029169a1baa08e211bff714a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates all needed prerequisites to support flash erase/write.  <a href="#gaf1b44a029169a1baa08e211bff714a19">More...</a><br /></td></tr>
<tr class="separator:gaf1b44a029169a1baa08e211bff714a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8457cc408eb5f9eaf573b7303a92b13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8457cc408eb5f9eaf573b7303a92b13e">&#9670;&nbsp;</a></span>Cy_Flashc_MainWriteEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_MainWriteEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable writing to main flash. </p>
<p>Enables writing to main flash.</p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<p>Enable writing to main flash. </p>

</div>
</div>
<a id="ga6182b2ee98bda81b66036837b3a078f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6182b2ee98bda81b66036837b3a078f7">&#9670;&nbsp;</a></span>Cy_Flashc_MainWriteDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_MainWriteDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable writing to main flash Disables writing to main flash. </p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<p>Disable writing to main flash Disables writing to main flash. </p>

</div>
</div>
<a id="gaff727b87261a3593e18b4d44a04100f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff727b87261a3593e18b4d44a04100f8">&#9670;&nbsp;</a></span>Cy_Flashc_WorkWriteEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_WorkWriteEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable writing work flash Work Flash embedded operations are enabled. </p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<p>Enable writing work flash Work Flash embedded operations are enabled. </p>

</div>
</div>
<a id="ga86be3053111defaf2ab3439f4dc58348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86be3053111defaf2ab3439f4dc58348">&#9670;&nbsp;</a></span>Cy_Flashc_WorkWriteDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_WorkWriteDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable writing work flash Work Flash embedded operations are blocked. </p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<p>Disable writing work flash Work Flash embedded operations are blocked. </p>

</div>
</div>
<a id="ga62c6206b38501114957cc4541670f064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62c6206b38501114957cc4541670f064">&#9670;&nbsp;</a></span>Cy_Flashc_WorkECCEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_WorkECCEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables ECC for work flash ECC checking/reporting on FLASH work interface is enabled. </p>
<p>Correctable or non-correctable faults are reported by enabling ECC.</p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<p>Enables ECC for work flash ECC checking/reporting on FLASH work interface is enabled. </p>

</div>
</div>
<a id="ga14f23bb58900a56a4c28b823fde19049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14f23bb58900a56a4c28b823fde19049">&#9670;&nbsp;</a></span>Cy_Flashc_WorkECCDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_WorkECCDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables ECC for work flash ECC checking/reporting on FLASH work interface is disabled. </p>
<p>No correctable or non-correctable faults are reported by disabling ECC.</p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<p>Disables ECC for work flash ECC checking/reporting on FLASH work interface is disabled. </p>

</div>
</div>
<a id="ga4bc2844b3a28e808c1ffde8c01b1c805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bc2844b3a28e808c1ffde8c01b1c805">&#9670;&nbsp;</a></span>Cy_Flashc_MainECCEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_MainECCEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables ECC for main flash ECC checking/reporting on FLASH main interface is enabled. </p>
<p>Correctable or non-correctable faults are reported by enabling ECC.</p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<p>Enables ECC for main flash ECC checking/reporting on FLASH main interface is enabled. </p>

</div>
</div>
<a id="gadfb71555c199febf31048e808f08c284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb71555c199febf31048e808f08c284">&#9670;&nbsp;</a></span>Cy_Flashc_MainECCDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_MainECCDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables ECC for main flash. </p>
<p>ECC checking/reporting on FLASH main interface is disabled. No correctable or non-correctable faults are reported by disabling ECC.</p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>

</div>
</div>
<a id="ga8ea8baa8b0c67b9cc9caa0c022faeb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ea8baa8b0c67b9cc9caa0c022faeb43">&#9670;&nbsp;</a></span>Cy_Flash_Program_WorkFlash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_Program_WorkFlash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__flash__programrow__config__t.html">cy_stc_flash_programrow_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes an array data to work flash. </p>
<p>Reports success or or a reason for failure. User should only pass work flash address else it will return an error. This function executes in blocking mode only.</p>
<p>Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is operating flash. User firmware should not enter the hibernate mode until flash Write is complete. The Flash operation is allowed in Sleep and Deep-sleep modes. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete.</dd>
<dd>
This function is applicable for CAT1C devices.</dd>
<dd>
User needs to make sure that the data pointer passed to this function points to 32 byte aligned data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>configuration of this function. This parameter is defined by the <a class="el" href="structcy__stc__flash__programrow__config__t.html" title="Flash program row configuration structure. ">cy_stc_flash_programrow_config_t</a> in <a class="el" href="group__group__flash__srom__config__structure.html">Structures</a> macro.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation (see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>).</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    uint32_t data = 0x55;</div><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> <a class="code" href="group__group__ipc__bt__data__structures.html#ga36692bbc61358ebc0e37a6fc6a395d28">result</a>;</div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__flash__programrow__config__t.html">cy_stc_flash_programrow_config_t</a> flash_programrow_config =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__flash__programrow__config__t.html#ac0fd7a0fd60ff5e7eaa1049d2309bc9d">destAddr</a>  =   (<span class="keyword">const</span> uint32_t *)CY_FLASH_BASE,</div><div class="line">        .dataAddr  =   (<span class="keyword">const</span> uint32_t *)&amp;data,</div><div class="line">        .skipBC    =   <a class="code" href="group__group__flash__enumerated__types.html#gga4de68eaf1e07cfb2bc15a7e3a23570b7a8b03012e62e58614d0ef6bcb6e7a5bbc">CY_FLASH_PROGRAMROW_SKIP_BLANK_CHECK</a>,</div><div class="line">        .dataSize  =   <a class="code" href="group__group__flash__enumerated__types.html#gga0c1a15e58947caee9ca19fb13208437fab04a43a5dce4f55647ee20e21a1dfe80">CY_FLASH_PROGRAMROW_DATA_SIZE_32BIT</a>,</div><div class="line">        .dataLoc   =   <a class="code" href="group__group__flash__enumerated__types.html#ggac5bfed302965242ab9d53a47dd41332face55068160cf2a46cd7dbdd625b7164c">CY_FLASH_PROGRAMROW_DATA_LOCATION_SRAM</a>,</div><div class="line">        .intrMask  =   <a class="code" href="group__group__flash__enumerated__types.html#ggae38819874e76d56b2006d53085654c31a64f9b06d1f17b1322a9f6634b21eec1b">CY_FLASH_PROGRAMROW_NOT_SET_INTR_MASK</a>,</div><div class="line">    };</div><div class="line">    result = <a class="code" href="group__group__flash__functions.html#ga8ea8baa8b0c67b9cc9caa0c022faeb43">Cy_Flash_Program_WorkFlash</a>(&amp;flash_programrow_config);</div><div class="line">    <span class="keywordflow">if</span>(result != <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//handle Error</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> This function writes an array data to work flash.</dd></dl>
<p>Reports success or or a reason for failure. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is operating flash. User firmware should not enter the hibernate mode until flash Write is complete. The Flash operation is allowed in Sleep and Deep-sleep modes. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.</p>
<p>config configuration of this function. This parameter is defined by the <a class="el" href="structcy__stc__flash__programrow__config__t.html" title="Flash program row configuration structure. ">cy_stc_flash_programrow_config_t</a> in group_flash_srom_config_structure macro.</p>
<p>Returns the status of the Flash operation (see cy_en_flashdrv_status_t).</p>
<p>Note: row or page is same and of the size 512 bytes </p>

</div>
</div>
<a id="ga7c9188232c336932c075b29677670434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c9188232c336932c075b29677670434">&#9670;&nbsp;</a></span>Cy_Flash_Program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_Program </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__flash__programrow__config__t.html">cy_stc_flash_programrow_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flash__enumerated__types.html#ga6eca51e351cd0e73a59f92b7bd9c726f">cy_en_flash_driver_blocking_t</a>&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes an array of data to flash. </p>
<p>Reports success or or a reason for failure. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is operating flash. User firmware should not enter the hibernate mode until flash Write is complete. The Flash operation is allowed in Sleep and Deep-sleep modes. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete.</dd>
<dd>
This function is applicable for CAT1C devices.</dd>
<dd>
User needs to make sure that the data pointer passed to this function points to 32 byte aligned data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>configuration of this function. This parameter is defined by the <a class="el" href="structcy__stc__flash__programrow__config__t.html" title="Flash program row configuration structure. ">cy_stc_flash_programrow_config_t</a> in <a class="el" href="group__group__flash__srom__config__structure.html">Structures</a> macro.</td></tr>
    <tr><td class="paramname">block</td><td>specifies if the function to execute in blocking or non blocking mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation (see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>). returns CY_FLASH_DRV_OPERATION_STARTED if operation starts with out error in non blocking mode. returns CY_FLASH_DRV_SUCCESS in blocking mode.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    uint32_t data = 0x55;</div><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> <a class="code" href="group__group__ipc__bt__data__structures.html#ga36692bbc61358ebc0e37a6fc6a395d28">result</a>;</div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__flash__programrow__config__t.html">cy_stc_flash_programrow_config_t</a> flash_programrow_config =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__flash__programrow__config__t.html#ac0fd7a0fd60ff5e7eaa1049d2309bc9d">destAddr</a>  =   (<span class="keyword">const</span> uint32_t *)CY_FLASH_BASE,</div><div class="line">        .dataAddr  =   (<span class="keyword">const</span> uint32_t *)&amp;data,</div><div class="line">        .blocking  =   <a class="code" href="group__group__flash__enumerated__types.html#gga5aa0830ca124208c5e1ecb5e95c28ee2a0560bd2c152fe247f4c5ef102ba378fd">CY_FLASH_PROGRAMROW_BLOCKING</a>,</div><div class="line">        .skipBC    =   <a class="code" href="group__group__flash__enumerated__types.html#gga4de68eaf1e07cfb2bc15a7e3a23570b7a8b03012e62e58614d0ef6bcb6e7a5bbc">CY_FLASH_PROGRAMROW_SKIP_BLANK_CHECK</a>,</div><div class="line">        .dataSize  =   <a class="code" href="group__group__flash__enumerated__types.html#gga0c1a15e58947caee9ca19fb13208437fab04a43a5dce4f55647ee20e21a1dfe80">CY_FLASH_PROGRAMROW_DATA_SIZE_32BIT</a>,</div><div class="line">        .dataLoc   =   <a class="code" href="group__group__flash__enumerated__types.html#ggac5bfed302965242ab9d53a47dd41332face55068160cf2a46cd7dbdd625b7164c">CY_FLASH_PROGRAMROW_DATA_LOCATION_SRAM</a>,</div><div class="line">        .intrMask  =   <a class="code" href="group__group__flash__enumerated__types.html#ggae38819874e76d56b2006d53085654c31a64f9b06d1f17b1322a9f6634b21eec1b">CY_FLASH_PROGRAMROW_NOT_SET_INTR_MASK</a>,</div><div class="line">    };</div><div class="line">    result = <a class="code" href="group__group__flash__functions.html#ga7c9188232c336932c075b29677670434">Cy_Flash_Program</a>(&amp;flash_programrow_config, <a class="code" href="group__group__flash__enumerated__types.html#gga6eca51e351cd0e73a59f92b7bd9c726fa49604b251acf914ce96eb599e6d0431f">CY_FLASH_DRIVER_BLOCKING</a>);</div><div class="line">    <span class="keywordflow">if</span>(result != <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//handle Error</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> This function writes an array of data to flash.</dd></dl>
<p>Reports success or or a reason for failure. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is operating flash. User firmware should not enter the hibernate mode until flash Write is complete. The Flash operation is allowed in Sleep and Deep-sleep modes. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.</p>
<p>config configuration of this function. This parameter is defined by the <a class="el" href="structcy__stc__flash__programrow__config__t.html" title="Flash program row configuration structure. ">cy_stc_flash_programrow_config_t</a> in group_flash_srom_config_structure macro.</p>
<p>Returns the status of the Flash operation (see cy_en_flashdrv_status_t).</p>
<p>Note: row or page is same and of the size 512 bytes </p>

</div>
</div>
<a id="ga25e18868377bcfb2ace477e06361be5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25e18868377bcfb2ace477e06361be5f">&#9670;&nbsp;</a></span>Cy_Flash_Checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_Checksum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__flash__checksum__config__t.html">cy_stc_flash_checksum_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>checksumPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a checksum value of the specified flash row. </p>
<p>supports only blocking mode for now.</p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>configuration of this function. This parameter is defined by the <a class="el" href="structcy__stc__flash__checksum__config__t.html" title="Flash checksum configuration structure. ">cy_stc_flash_checksum_config_t</a> in <a class="el" href="structcy__stc__flash__checksum__config__t.html">cy_stc_flash_checksum_config_t</a> macro.</td></tr>
    <tr><td class="paramname">checksumPtr</td><td>The pointer to the address where checksum is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> <a class="code" href="group__group__ipc__bt__data__structures.html#ga36692bbc61358ebc0e37a6fc6a395d28">result</a>;</div><div class="line">    uint32_t checksumPtr;</div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__flash__checksum__config__t.html">cy_stc_flash_checksum_config_t</a> flash_computechecksum_config =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__flash__checksum__config__t.html#a3d0092b72c74891c8bfe81f2fc416235">rowId</a>  = 0,</div><div class="line">        .bank   = <a class="code" href="group__group__flash__enumerated__types.html#ggad20961536714c7042be66aa26794176ead0681e097573b7c1b51bcbb4a06078ee">CY_FLASH_CHECKSUM_BANK0</a>,</div><div class="line">        .whole  = <a class="code" href="group__group__flash__enumerated__types.html#gga2fbb2b700191fe798495acf592a12cf3af46c289d5d63fb18ef033ac97f113c68">CY_FLASH_CHECKSUM_PAGE</a>,</div><div class="line">        .region = <a class="code" href="group__group__flash__enumerated__types.html#gga44cbfff5598b3e3ed4dad8713c875c14a9d3ed6484021943b1b262d02d4a433c1">CY_FLASH_CHECKSUM_MAIN</a>,</div><div class="line">    };</div><div class="line">    result = <a class="code" href="group__group__flash__functions.html#ga25e18868377bcfb2ace477e06361be5f">Cy_Flash_Checksum</a>(&amp;flash_computechecksum_config, &amp;checksumPtr);</div><div class="line">    <span class="keywordflow">if</span>(result != <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//handle Error</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> supports only blocking mode for now. rowNum The Checksum is calculated to the flash row.</dd></dl>
<p>checksumPtr The pointer to the address where checksum is to be stored</p>
<p>Returns the status of the Flash operation.</p>
<p>Note:row or page is same and of the size 512 bytes </p>

</div>
</div>
<a id="ga805df2fa876eb23aee0627bcc5def58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga805df2fa876eb23aee0627bcc5def58e">&#9670;&nbsp;</a></span>Cy_Flash_EraseSuspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_EraseSuspend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function suspends an ongoing erase operation. </p>
<p>User should not read from a sector which is suspended from an erase operation. Cy_Flash_ProgramRow function will return error if invoked on suspended sector. This function cannot be called on SFLASH. Reports success or a reason for failure. Does not return until the Erase operation is complete. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is operating flash. This function supports only blocking mode for now.</p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation (see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>).</dd></dl>
<p>User should not read from a sector which is suspended from an erase operation. Cy_Flash_ProgramRow function will return error if invoked on suspended sector. This function cannot be called on SFLASH. Reports success or a reason for failure. Does not return until the Erase operation is complete. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is operating flash. This function supports only blocking mode for now.</p>
<p>Returns the status of the Flash operation (see cy_en_flashdrv_status_t). </p>

</div>
</div>
<a id="gae03886b6268f6c2ebbde6c5c7511e105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae03886b6268f6c2ebbde6c5c7511e105">&#9670;&nbsp;</a></span>Cy_Flash_EraseResume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_EraseResume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__flash__eraseresume__config__t.html">cy_stc_flash_eraseresume_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls to resume a suspended erase operation. </p>
<p>Reports success or a reason for failure. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is operating flash. </p><dl class="section note"><dt>Note</dt><dd>A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete.</dd>
<dd>
This function is applicable for CAT1C devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>configuration of this function. This parameter is defined by the <a class="el" href="structcy__stc__flash__eraseresume__config__t.html" title="Flash erase resume configuration structure. ">cy_stc_flash_eraseresume_config_t</a> in <a class="el" href="group__group__flash__srom__config__structure.html">Structures</a> macro.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation (see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>).</dd></dl>
<p>Reports success or a reason for failure. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is operating flash.</p>
<p>config configuration of this function. This parameter is defined by the <a class="el" href="structcy__stc__flash__eraseresume__config__t.html" title="Flash erase resume configuration structure. ">cy_stc_flash_eraseresume_config_t</a> in group_flash_srom_config_structure macro.</p>
<p>Returns the status of the Flash operation (see cy_en_flashdrv_status_t). </p>

</div>
</div>
<a id="ga31b3f5e3496cb0aecd06ac357f6af23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31b3f5e3496cb0aecd06ac357f6af23c">&#9670;&nbsp;</a></span>Cy_Flash_BlankCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_BlankCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__flash__blankcheck__config__t.html">cy_stc_flash_blankcheck_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flash__enumerated__types.html#ga6eca51e351cd0e73a59f92b7bd9c726f">cy_en_flash_driver_blocking_t</a>&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs blank check on the addressed work FLASH. </p>
<p>Reports success or a reason for failure. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is operating flash.</p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>configuration of this function. This parameter is defined by the <a class="el" href="structcy__stc__flash__blankcheck__config__t.html" title="Flash blank check configuration structure. ">cy_stc_flash_blankcheck_config_t</a> in <a class="el" href="group__group__flash__srom__config__structure.html">Structures</a> macro.</td></tr>
    <tr><td class="paramname">block</td><td>specifies if the function to execute in blocking or non blocking mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation (see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>). returns CY_FLASH_DRV_OPERATION_STARTED if operation starts with out error in non blocking mode. returns CY_FLASH_DRV_SUCCESS in blocking mode.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <a class="code" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19">Cy_Flash_Init</a>();</div><div class="line">    <a class="code" href="group__group__flash__functions.html#gaff727b87261a3593e18b4d44a04100f8">Cy_Flashc_WorkWriteEnable</a>();</div><div class="line">    <a class="code" href="group__group__flash__functions.html#ga8457cc408eb5f9eaf573b7303a92b13e">Cy_Flashc_MainWriteEnable</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Writing to a memory location with data is not allowed. Erasing the memory first. */</span></div><div class="line">    <a class="code" href="group__group__flash__functions.html#ga42900a5b1b692efc825083c262cc2d7d">Cy_Flash_StartEraseSector</a>((uint32_t)CY_FLASH_BASE);</div><div class="line">    <a class="code" href="group__group__syslib__functions.html#gaad1c32546fdb0e3c6fa8b46fb95843b5">Cy_SysLib_Delay</a>(100);</div><div class="line">    <span class="comment">// Wait for completion with counting</span></div><div class="line">    <span class="keywordflow">while</span>(<a class="code" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete</a>() != <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__syslib__functions.html#gaad1c32546fdb0e3c6fa8b46fb95843b5">Cy_SysLib_Delay</a>(1); <span class="comment">/* delay one millisecond each iteration */</span></div><div class="line">    }</div><div class="line">    <a class="code" href="structcy__stc__flash__blankcheck__config__t.html">cy_stc_flash_blankcheck_config_t</a> blankcheck_config;</div><div class="line">    blankcheck_config.<a class="code" href="structcy__stc__flash__blankcheck__config__t.html#afd677dde991c6663066cd14596109d38">addrToBeChecked</a>       = (uint32_t*)CY_FLASH_BASE;</div><div class="line">    blankcheck_config.<a class="code" href="structcy__stc__flash__blankcheck__config__t.html#ab39b06bf91730b4961c1d7ff954cc26d">numOfWordsToBeChecked</a> = CY_WORK_LES_SIZE_IN_WORD;</div><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> blank_check_status = <a class="code" href="group__group__flash__functions.html#ga31b3f5e3496cb0aecd06ac357f6af23c">Cy_Flash_BlankCheck</a>(&amp;blankcheck_config, <a class="code" href="group__group__flash__enumerated__types.html#gga6eca51e351cd0e73a59f92b7bd9c726fa49604b251acf914ce96eb599e6d0431f">CY_FLASH_DRIVER_BLOCKING</a>);</div><div class="line">    <span class="keywordflow">if</span>(blank_check_status != <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//handle error</span></div><div class="line">    }</div><div class="line">    flashWriteStatus = <a class="code" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292">Cy_Flash_StartWrite</a>((uint32_t)flashData, (<span class="keyword">const</span> uint32_t *)ramData);</div><div class="line">    <span class="keywordflow">if</span>(flashWriteStatus == <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a5244becc5d012c5195e6d04719575ed1">CY_FLASH_DRV_OPERATION_STARTED</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">while</span>(<a class="code" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete</a>() != <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a>)</div><div class="line">        {</div><div class="line">        }</div><div class="line">        <span class="comment">/* Verify the data written into flash by comparing it with the RAM data */</span></div><div class="line">        <span class="keywordflow">if</span>( memcmp(ramData,flashData,<a class="code" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a>) != 0u)</div><div class="line">        {</div><div class="line">            <span class="comment">//handle error</span></div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">/* flash write operation did not start */</span></div><div class="line">    {</div><div class="line">        <span class="comment">//handle error</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> Reports success or a reason for failure. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is operating flash.</dd></dl>
<p>config configuration of this function. This parameter is defined by the <a class="el" href="structcy__stc__flash__blankcheck__config__t.html" title="Flash blank check configuration structure. ">cy_stc_flash_blankcheck_config_t</a> in group_flash_srom_config_structure macro.</p>
<p>Returns the status of the Flash operation (see cy_en_flashdrv_status_t). </p>

</div>
</div>
<a id="ga078a8f5f01326202f20b0f6b7d32f7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga078a8f5f01326202f20b0f6b7d32f7ba">&#9670;&nbsp;</a></span>Cy_Flash_OperationStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_OperationStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the status of the Flash Operation, and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>Driver status. returns CY_FLASH_DRV_OPERATION_STARTED if operation in non blocking mode is not complete. returns CY_FLASH_DRV_SUCCESS if the operation is complete.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <a class="code" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19">Cy_Flash_Init</a>();</div><div class="line">    <a class="code" href="group__group__flash__functions.html#gaff727b87261a3593e18b4d44a04100f8">Cy_Flashc_WorkWriteEnable</a>();</div><div class="line">    <a class="code" href="group__group__flash__functions.html#ga8457cc408eb5f9eaf573b7303a92b13e">Cy_Flashc_MainWriteEnable</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Writing to a memory location with data is not allowed. Erasing the memory first. */</span></div><div class="line">    <a class="code" href="group__group__flash__functions.html#ga42900a5b1b692efc825083c262cc2d7d">Cy_Flash_StartEraseSector</a>((uint32_t)CY_FLASH_BASE);</div><div class="line">    <a class="code" href="group__group__syslib__functions.html#gaad1c32546fdb0e3c6fa8b46fb95843b5">Cy_SysLib_Delay</a>(100);</div><div class="line">    <span class="comment">// Wait for completion with counting</span></div><div class="line">    <span class="keywordflow">while</span>(<a class="code" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete</a>() != <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__syslib__functions.html#gaad1c32546fdb0e3c6fa8b46fb95843b5">Cy_SysLib_Delay</a>(1); <span class="comment">/* delay one millisecond each iteration */</span></div><div class="line">    }</div><div class="line">    <a class="code" href="structcy__stc__flash__blankcheck__config__t.html">cy_stc_flash_blankcheck_config_t</a> blankcheck_config;</div><div class="line">    blankcheck_config.<a class="code" href="structcy__stc__flash__blankcheck__config__t.html#afd677dde991c6663066cd14596109d38">addrToBeChecked</a>       = (uint32_t*)CY_FLASH_BASE;</div><div class="line">    blankcheck_config.<a class="code" href="structcy__stc__flash__blankcheck__config__t.html#ab39b06bf91730b4961c1d7ff954cc26d">numOfWordsToBeChecked</a> = CY_WORK_LES_SIZE_IN_WORD;</div><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> blank_check_status = <a class="code" href="group__group__flash__functions.html#ga31b3f5e3496cb0aecd06ac357f6af23c">Cy_Flash_BlankCheck</a>(&amp;blankcheck_config, <a class="code" href="group__group__flash__enumerated__types.html#gga6eca51e351cd0e73a59f92b7bd9c726fa49604b251acf914ce96eb599e6d0431f">CY_FLASH_DRIVER_BLOCKING</a>);</div><div class="line">    <span class="keywordflow">if</span>(blank_check_status != <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">//handle error</span></div><div class="line">    }</div><div class="line">    flashWriteStatus = <a class="code" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292">Cy_Flash_StartWrite</a>((uint32_t)flashData, (<span class="keyword">const</span> uint32_t *)ramData);</div><div class="line">    <span class="keywordflow">if</span>(flashWriteStatus == <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a5244becc5d012c5195e6d04719575ed1">CY_FLASH_DRV_OPERATION_STARTED</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">while</span>(<a class="code" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete</a>() != <a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a>)</div><div class="line">        {</div><div class="line">        }</div><div class="line">        <span class="comment">/* Verify the data written into flash by comparing it with the RAM data */</span></div><div class="line">        <span class="keywordflow">if</span>( memcmp(ramData,flashData,<a class="code" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a>) != 0u)</div><div class="line">        {</div><div class="line">            <span class="comment">//handle error</span></div><div class="line">        }</div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">/* flash write operation did not start */</span></div><div class="line">    {</div><div class="line">        <span class="comment">//handle error</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga2a3fa8c605ee60d146caa8b3734fedee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a3fa8c605ee60d146caa8b3734fedee">&#9670;&nbsp;</a></span>Cy_Flashc_InjectECC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flashc_InjectECC </td>
          <td>(</td>
          <td class="paramtype">cy_en_region_t&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables ECC injection and sets the address where a parity will be injected and the parity value. </p>
<p>Reports success or a reason for failure.</p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>An indicator which region (Code/Work/Cache) ECC parity will be injected to. This parameter is defined by the cy_en_region_t in <a class="el" href="group__group__flash__macros.html">Macros</a> macro.</td></tr>
    <tr><td class="paramname">address</td><td>The address where ECC parity will be injected.</td></tr>
    <tr><td class="paramname">parity</td><td>The parity value which will be injected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation (see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>).</dd></dl>
<p>Reports success or a reason for failure.</p>
<p>region An indicator which region (Code/Work/Cache) ECC parity will be injected to. This parameter is defined by the cy_en_region_t in group_flash_macro macro.</p>
<p>address The address where ECC parity will be injected.</p>
<p>parity The parity value which will be injected.</p>
<p>Returns the status of the Flash operation (see cy_en_flashdrv_status_t). </p>

</div>
</div>
<a id="gaa1a313e212643285eca2aad738e365df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1a313e212643285eca2aad738e365df">&#9670;&nbsp;</a></span>Cy_Flashc_SetWorkBankMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_SetWorkBankMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bank mode for work flash. </p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>bank mode to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> set_bank_mode = <a class="code" href="group__group__flash__enumerated__types.html#gga2b49a26d6a69b3f5100da484c7566446a25788d8acf76335ea1eea7244c71b5cb">CY_FLASH_SINGLE_BANK_MODE</a>;</div><div class="line">    <a class="code" href="group__group__flash__functions.html#gaa1a313e212643285eca2aad738e365df">Cy_Flashc_SetWorkBankMode</a>(set_bank_mode);</div><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> get_bank_mode = <a class="code" href="group__group__flash__functions.html#ga7a96bc07b10d09564724f39661b5f01c">Cy_Flashc_GetWorkBankMode</a>();</div><div class="line">    <span class="keywordflow">if</span>(set_bank_mode != get_bank_mode)</div><div class="line">    {</div><div class="line">        <span class="comment">//handle Error</span></div><div class="line">    }</div></div><!-- fragment --> mode bank mode to be set </dd></dl>

</div>
</div>
<a id="ga7a96bc07b10d09564724f39661b5f01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a96bc07b10d09564724f39661b5f01c">&#9670;&nbsp;</a></span>Cy_Flashc_GetWorkBankMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> Cy_Flashc_GetWorkBankMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets current bank mode for work flash. </p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Current bank mode</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> set_bank_mode = <a class="code" href="group__group__flash__enumerated__types.html#gga2b49a26d6a69b3f5100da484c7566446a25788d8acf76335ea1eea7244c71b5cb">CY_FLASH_SINGLE_BANK_MODE</a>;</div><div class="line">    <a class="code" href="group__group__flash__functions.html#gaa1a313e212643285eca2aad738e365df">Cy_Flashc_SetWorkBankMode</a>(set_bank_mode);</div><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> get_bank_mode = <a class="code" href="group__group__flash__functions.html#ga7a96bc07b10d09564724f39661b5f01c">Cy_Flashc_GetWorkBankMode</a>();</div><div class="line">    <span class="keywordflow">if</span>(set_bank_mode != get_bank_mode)</div><div class="line">    {</div><div class="line">        <span class="comment">//handle Error</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaba1e7ca437a12c0df27007de2f3768b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba1e7ca437a12c0df27007de2f3768b8">&#9670;&nbsp;</a></span>Cy_Flashc_SetMainBankMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_SetMainBankMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bank mode for main flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>bank mode to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> set_bank_mode = <a class="code" href="group__group__flash__enumerated__types.html#gga2b49a26d6a69b3f5100da484c7566446a25788d8acf76335ea1eea7244c71b5cb">CY_FLASH_SINGLE_BANK_MODE</a>;</div><div class="line">    <a class="code" href="group__group__flash__functions.html#gaba1e7ca437a12c0df27007de2f3768b8">Cy_Flashc_SetMainBankMode</a>(set_bank_mode);</div><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> get_bank_mode = <a class="code" href="group__group__flash__functions.html#ga95483efb2b8e1c38ec6b6f990f15c5e9">Cy_Flashc_GetMainBankMode</a>();</div><div class="line">    <span class="keywordflow">if</span>(set_bank_mode != get_bank_mode)</div><div class="line">    {</div><div class="line">        <span class="comment">//handle Error</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> mode bank mode to be set </dd></dl>

</div>
</div>
<a id="ga95483efb2b8e1c38ec6b6f990f15c5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95483efb2b8e1c38ec6b6f990f15c5e9">&#9670;&nbsp;</a></span>Cy_Flashc_GetMainBankMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> Cy_Flashc_GetMainBankMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets current bank mode for main flash. </p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1C devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Current bank mode</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> set_bank_mode = <a class="code" href="group__group__flash__enumerated__types.html#gga2b49a26d6a69b3f5100da484c7566446a25788d8acf76335ea1eea7244c71b5cb">CY_FLASH_SINGLE_BANK_MODE</a>;</div><div class="line">    <a class="code" href="group__group__flash__functions.html#gaba1e7ca437a12c0df27007de2f3768b8">Cy_Flashc_SetMainBankMode</a>(set_bank_mode);</div><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#ga2b49a26d6a69b3f5100da484c7566446">cy_en_bankmode_t</a> get_bank_mode = <a class="code" href="group__group__flash__functions.html#ga95483efb2b8e1c38ec6b6f990f15c5e9">Cy_Flashc_GetMainBankMode</a>();</div><div class="line">    <span class="keywordflow">if</span>(set_bank_mode != get_bank_mode)</div><div class="line">    {</div><div class="line">        <span class="comment">//handle Error</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga61b907d56c35da075b1353f9f53ea0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61b907d56c35da075b1353f9f53ea0cc">&#9670;&nbsp;</a></span>Cy_Flashc_SetMain_Flash_Mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_SetMain_Flash_Mapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__flash__enumerated__types.html#ga977f3c56b8510500b008063d8cc5e543">cy_en_maptype_t</a>&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets mapping for main flash region. </p>
<p>Applicable only in Dual Bank mode of Main flash region</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>mapping to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga383d2ae70270ed056e50d72cc81cd4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga383d2ae70270ed056e50d72cc81cd4d3">&#9670;&nbsp;</a></span>Cy_Flashc_SetWork_Flash_Mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flashc_SetWork_Flash_Mapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__flash__enumerated__types.html#ga977f3c56b8510500b008063d8cc5e543">cy_en_maptype_t</a>&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets mapping for work flash region. </p>
<p>Applicable only in Dual Bank mode of Work flash region</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>mapping to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga6b9753a9fca6ebea833cbc4af7f0d681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b9753a9fca6ebea833cbc4af7f0d681">&#9670;&nbsp;</a></span>Cy_Flash_EraseRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_EraseRow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases a single row of flash. </p>
<p>Reports success or a reason for failure. Does not return until the Write operation is complete. Returns immediately and reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash or erasing the row. User firmware should not enter the Hibernate or Deep Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, ors Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete. </dd>
<dd>
This function is applicable for CAT1A devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>.</dd></dl>
<p>Reports success or a reason for failure. Does not return until the Write operation is complete. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is writing to flash or erasing the row. User firmware should not enter the Hibernate or Deep Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p>

</div>
</div>
<a id="ga36c8da8da155cd73eaf3359f3f81af02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36c8da8da155cd73eaf3359f3f81af02">&#9670;&nbsp;</a></span>Cy_Flash_StartEraseRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_StartEraseRow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts erasing a single row of flash. </p>
<p>Returns immediately and reports a successful start or reason for failure. Reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when IPC structure is locked by another process. User firmware should not enter the Hibernate or Deep Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>To avoid situation of reading data from cache memory - before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </dd>
<dd>
A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete. </dd>
<dd>
This function is applicable for CAT1A devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash erase operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. returns CY_FLASH_DRV_OPERATION_STARTED if operation starts with out error.</dd></dl>
<p>Returns immediately and reports a successful start or reason for failure. Reports a CY_FLASH_DRV_IPC_BUSY error in the case when IPC structure is locked by another process. User firmware should not enter the Hibernate or Deep Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. To avoid situation of reading data from cache memory - before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </p>

</div>
</div>
<a id="gadb9cf4bec4ce4202604823cf0feb70ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb9cf4bec4ce4202604823cf0feb70ac">&#9670;&nbsp;</a></span>Cy_Flash_EraseSubsector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_EraseSubsector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>subSectorAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases an 8-row subsector of flash. </p>
<p>Reports success or a reason for failure. Does not return until the Write operation is complete. Returns immediately and reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash or erasing the row. User firmware should not enter the Hibernate or Deep-Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete. </dd>
<dd>
This function is applicable for CAT1A devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subSectorAddr</td><td>Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>.</dd></dl>
<p>Reports success or a reason for failure. Does not return until the Write operation is complete. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is writing to flash or erasing the row. User firmware should not enter the Hibernate or Deep-Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p>

</div>
</div>
<a id="ga732a0c229dd1acee3b36f1bba0045976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga732a0c229dd1acee3b36f1bba0045976">&#9670;&nbsp;</a></span>Cy_Flash_StartEraseSubsector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_StartEraseSubsector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>subSectorAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts erasing an 8-row subsector of flash. </p>
<p>Returns immediately and reports a successful start or reason for failure. Reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when IPC structure is locked by another process. User firmware should not enter the Hibernate or Deep-Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </dd>
<dd>
A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete. </dd>
<dd>
This function is applicable for CAT1A devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subSectorAddr</td><td>Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash erase operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. returns CY_FLASH_DRV_OPERATION_STARTED if operation starts with out error.</dd></dl>
<p>Returns immediately and reports a successful start or reason for failure. Reports a CY_FLASH_DRV_IPC_BUSY error in the case when IPC structure is locked by another process. User firmware should not enter the Hibernate or Deep-Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </p>

</div>
</div>
<a id="gafaa220a63444c4e5a5abe9b8c2cec721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaa220a63444c4e5a5abe9b8c2cec721">&#9670;&nbsp;</a></span>Cy_Flash_WriteRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_WriteRow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes an array of data to a single row of flash. </p>
<p>This is done in three steps - pre-program, erase and then program flash row with the input data. Reports success or a reason for failure. Does not return until the Write operation is complete. Returns immediately and reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete.</dd>
<dd>
This is a blocking function and will not return until the Write operation is complete. </dd>
<dd>
This function is applicable for CAT1A devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the data which has to be written to flash. The size of the data array must be equal to the flash row size. The flash row size for the selected device is defined by the <a class="el" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> macro. Refer to the device datasheet for the details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>.</dd></dl>
<p>This is done in three steps - pre-program, erase and then program flash row with the input data. Reports success or a reason for failure. Does not return until the Write operation is complete. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p>

</div>
</div>
<a id="gafc57348bb2e6922a65826bccad961fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc57348bb2e6922a65826bccad961fed">&#9670;&nbsp;</a></span>Cy_Flash_StartProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_StartProgram </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts writing an array of data to a single row of flash. </p>
<p>Returns immediately and reports a successful start or reason for failure. Reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error if another process is writing to flash. The user firmware should not enter Hibernate or Deep-Sleep mode until flash Program is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.<br />
Before calling this function, the target flash region must be erased by the StartEraseRow/EraseRow function.<br />
Data to be programmed must be located in the SRAM memory region. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </dd>
<dd>
A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete.</dd>
<dd>
This is a non blocking function and will not wait until the Write operation is complete. </dd>
<dd>
This function is applicable for CAT1A devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>The address of the flash row number. The Read-while-Write violation occurs when the Flash Write operation is performing. Refer to the device datasheet for the details. The address must match the row start address.</td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the data to be written to flash. The size of the data array must be equal to the flash row size. The flash row size for the selected device is defined by the <a class="el" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> macro. Refer to the device datasheet for the details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. returns CY_FLASH_DRV_OPERATION_STARTED if operation starts with out error.</dd></dl>
<p>Returns immediately and reports a successful start or reason for failure. Reports a CY_FLASH_DRV_IPC_BUSY error if another process is writing to flash. The user firmware should not enter Hibernate or Deep-Sleep mode until flash Program is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.<br />
Before calling this function, the target flash region must be erased by the StartEraseRow/EraseRow function.<br />
Data to be programmed must be located in the SRAM memory region. Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </p>

</div>
</div>
<a id="ga607931427f2d4a2147c7c97ce96577e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga607931427f2d4a2147c7c97ce96577e0">&#9670;&nbsp;</a></span>Cy_Flash_GetExternalStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_Flash_GetExternalStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles the case where a module such as security image captures a system call from this driver and reports its own status or error code, for example protection violation. </p>
<p>In that case, a function from this driver returns an unknown error (see cy_en_flashdrv_status_t). After receipt of an unknown error, the user may call this function to get the status of the capturing module.</p>
<p>The user is responsible for parsing the content of the returned value and casting it to the appropriate enumeration. </p><dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1A devices.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation code.</dd></dl>
<p>In that case, a function from this driver returns an unknown error (see cy_en_flashdrv_status_t). After receipt of an unknown error, the user may call this function to get the status of the capturing module.</p>
<p>The user is responsible for parsing the content of the returned value and casting it to the appropriate enumeration. </p>

</div>
</div>
<a id="ga3daa482b7696dcb6e06f0776e0ca725a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3daa482b7696dcb6e06f0776e0ca725a">&#9670;&nbsp;</a></span>Cy_Flash_InitExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flash_InitExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__flash__notify__t.html">cy_stc_flash_notify_t</a> *&#160;</td>
          <td class="paramname"><em>ipcWaitMessageAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates all needed prerequisites to support flash erase/write. </p>
<p>Should be called from each core. Defines the address of the message structure.</p>
<p>Requires a call to <a class="el" href="group__group__ipc__sema__functions.html#ga1cbc3b147c650c8716de10a1ee8423bd" title="This function initializes the semaphores subsystem. ">Cy_IPC_Sema_Init()</a>, <a class="el" href="group__group__ipc__pipe__functions.html#ga7a1c8f1e92e74f27856ef2b7ac09c640" title="This function stores a copy of a pointer to the array of endpoints. ">Cy_IPC_Pipe_Config()</a> and <a class="el" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c" title="Initializes the system pipes. ">Cy_IPC_Pipe_Init()</a> functions before use.</p>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for CAT1A devices.</dd></dl>
<p>This function is called in the <a class="el" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19" title="Initiates all needed prerequisites to support flash erase/write. ">Cy_Flash_Init()</a> function - see the <a class="el" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19">Cy_Flash_Init</a> usage considerations.</p>
<p>Should be called from each core. Defines the address of the message structure.</p>
<p>Requires a call to <a class="el" href="group__group__ipc__sema__functions.html#ga1cbc3b147c650c8716de10a1ee8423bd" title="This function initializes the semaphores subsystem. ">Cy_IPC_Sema_Init()</a>, <a class="el" href="group__group__ipc__pipe__functions.html#ga7a1c8f1e92e74f27856ef2b7ac09c640" title="This function stores a copy of a pointer to the array of endpoints. ">Cy_IPC_Pipe_Config()</a> and <a class="el" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c" title="Initializes the system pipes. ">Cy_IPC_Pipe_Init()</a> functions before use.</p>
<p>This function is called in the <a class="el" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19" title="Initiates all needed prerequisites to support flash erase/write. ">Cy_Flash_Init()</a> function - see the Cy_Flash_Init usage considerations. </p>

</div>
</div>
<a id="ga436020eae198750c56b93dbabdf6dc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga436020eae198750c56b93dbabdf6dc6d">&#9670;&nbsp;</a></span>Cy_Flash_IsOperationComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_IsOperationComplete </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a successful operation result, reason of failure or busy status ( <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a9ddac0d7038bbdfe57db1acbeac9df82">CY_FLASH_DRV_OPCODE_BUSY</a> ). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation (see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>). returns CY_FLASH_DRV_OPERATION_STARTED if operation in non blocking mode is not complete. returns CY_FLASH_DRV_SUCCESS if the operation is complete.</dd></dl>
<p>Reports a successful operation result, reason of failure or busy status ( <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a9ddac0d7038bbdfe57db1acbeac9df82">CY_FLASH_DRV_OPCODE_BUSY</a> ). </p>

</div>
</div>
<a id="gafed287628c010c2258f73c5777b52292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafed287628c010c2258f73c5777b52292">&#9670;&nbsp;</a></span>Cy_Flash_StartWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_StartWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts programming the flash row with the input data. </p>
<p>Returns immediately and reports a successful start or reason for failure. Reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-Sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </dd>
<dd>
This is added as backword compatibility function in CAT1C devices. This function will not erase the row before writing to the row. Erase ROW is not supported in CAT1C devices. User can use <a class="el" href="group__group__flash__functions.html#ga23e040ae57d5c4f717b1918eda77ecc5">Cy_Flash_EraseSector</a> or Cy_Flash_EraseAll functions. </dd>
<dd>
A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete.</dd>
<dd>
This is a non blocking function and will not wait until the Write operation is complete.</dd>
<dd>
User needs to make sure that the data pointer passed to this function points to 32 byte aligned data for CAT1C devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the data to be written to flash. The size of the data array must be equal to the flash row size. The flash row size for the selected device is defined by the <a class="el" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> macro. Refer to the device datasheet for the details. For CAT1C devices this data pointer needs to point to 32 byte aligned data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, returns CY_FLASH_DRV_OPERATION_STARTED if operation starts with out error. see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>.</dd></dl>
<p>Starts programming the flash row with the input data.</p>
<p>Returns immediately and reports a successful start or reason for failure. Reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-Sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function.</p>
<p>Returns immediately and reports a successful start or reason for failure. Reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-Sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function.</dd></dl>
<p>rowAddr Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</p>
<p>data The pointer to the data to be written to flash. The size of the data array must be equal to the flash row size. The flash row size for the selected device is defined by the <a class="el" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> macro. Refer to the device datasheet for the details.</p>
<p>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. </p>

</div>
</div>
<a id="ga42900a5b1b692efc825083c262cc2d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42900a5b1b692efc825083c262cc2d7d">&#9670;&nbsp;</a></span>Cy_Flash_StartEraseSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_StartEraseSector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sectorAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts erasing a sector of flash. </p>
<p>Returns immediately and reports a successful start or reason for failure. Reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when IPC structure is locked by another process. User firmware should not enter the Hibernate or Deep Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </dd>
<dd>
A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete.</dd>
<dd>
This is a non blocking function and will not wait until the operation is complete.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorAddr</td><td>Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash erase operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, returns CY_FLASH_DRV_OPERATION_STARTED if operation starts with out error. see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>.</dd></dl>
<p>Returns immediately and reports a successful start or reason for failure. Reports a CY_FLASH_DRV_IPC_BUSY error in the case when IPC structure is locked by another process. User firmware should not enter the Hibernate or Deep Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes. Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </p>

</div>
</div>
<a id="ga5218274c43e64791cf28f902d15a355a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5218274c43e64791cf28f902d15a355a">&#9670;&nbsp;</a></span>Cy_Flash_ProgramRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_ProgramRow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes an array of data to a single row of flash. </p>
<p>Reports success or a reason for failure. Does not return until the Program operation is complete. Returns immediately and reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.<br />
Before calling this function, the target flash region must be erased by the StartErase/EraseRow function.<br />
Data to be programmed must be located in the SRAM memory region. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </dd>
<dd>
A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete.</dd>
<dd>
This is a blocking function and will not return until the Write operation is complete.</dd>
<dd>
User needs to make sure that the data pointer passed to this function points to 32 byte aligned data for CAT1C devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the data which has to be written to flash. The size of the data array must be equal to the flash row size. The flash row size for the selected device is defined by the <a class="el" href="group__group__flash__general__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> macro. Refer to the device datasheet for the details. For CAT1C devices this data pointer needs to point to 32 byte aligned data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>.</dd></dl>
<p>Reports success or a reason for failure. Does not return until the Program operation is complete. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.<br />
Before calling this function, the target flash region must be erased by the StartErase/EraseRow function.<br />
Data to be programmed must be located in the SRAM memory region. Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function.</p>
<p>Reports success or a reason for failure. Does not return until the Program operation is complete. Returns immediately and reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash. User firmware should not enter the Hibernate or Deep-sleep mode until flash Write is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.<br />
Before calling this function, the target flash region must be erased by the StartErase/EraseRow function.<br />
Data to be programmed must be located in the SRAM memory region. </p><dl class="section note"><dt>Note</dt><dd>Before reading data from previously programmed/erased flash rows, the user must clear the flash cache with the <a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f" title="This function invalidates the flash cache and buffer. ">Cy_SysLib_ClearFlashCacheAndBuffer()</a> function. </dd></dl>

</div>
</div>
<a id="ga23e040ae57d5c4f717b1918eda77ecc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23e040ae57d5c4f717b1918eda77ecc5">&#9670;&nbsp;</a></span>Cy_Flash_EraseSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_EraseSector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sectorAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases a sector of flash. </p>
<p>Reports success or a reason for failure. Does not return until the Erase operation is complete. Returns immediately and reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash or erasing the row. User firmware should not enter the Hibernate or Deep Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.</p>
<dl class="section note"><dt>Note</dt><dd>A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash operation is complete.</dd>
<dd>
This is a blocking function and will not return until the erase operation is complete.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorAddr</td><td>Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>.</dd></dl>
<p>Reports success or a reason for failure. Does not return until the Erase operation is complete. Returns immediately and reports a CY_FLASH_DRV_IPC_BUSY error in the case when another process is writing to flash or erasing the row. User firmware should not enter the Hibernate or Deep Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.</p>
<p>Reports success or a reason for failure. Does not return until the Erase operation is complete. Returns immediately and reports a <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a6b2c46694345a4366933c0a7dfbec4ae">CY_FLASH_DRV_IPC_BUSY</a> error in the case when another process is writing to flash or erasing the row. User firmware should not enter the Hibernate or Deep Sleep mode until flash Erase is complete. The Flash operation is allowed in Sleep mode. During the Flash operation, the device should not be reset, including the XRES pin, a software reset, and watchdog reset sources. Also, low-voltage detect circuits should be configured to generate an interrupt instead of a reset. Otherwise, portions of flash may undergo unexpected changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorAddr</td><td>Address of the flash row number. The Read-while-Write violation occurs when the flash read operation is initiated in the same flash sector where the flash write operation is performing. Refer to the device datasheet for the details. Address must match row start address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation, see <a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>. </dd></dl>

</div>
</div>
<a id="ga3f948f4d096b9f93488a889a011bda14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f948f4d096b9f93488a889a011bda14">&#9670;&nbsp;</a></span>Cy_Flash_CalculateHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_CalculateHash </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numberOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>hashPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash value of the specified region of flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Start the data address.</td></tr>
    <tr><td class="paramname">numberOfBytes</td><td>The hash value is calculated for the number of bytes after the start data address (0 - 1 byte, 1- 2 bytes etc).</td></tr>
    <tr><td class="paramname">hashPtr</td><td>The pointer to the address where hash is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation. </dd></dl>

</div>
</div>
<a id="ga29ac711091186d8a7790be298fb6148b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29ac711091186d8a7790be298fb6148b">&#9670;&nbsp;</a></span>Cy_Flash_RowChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_RowChecksum </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>checksumPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a checksum value of the specified flash row. </p>
<dl class="section note"><dt>Note</dt><dd>Now <a class="el" href="group__group__flash__functions.html#ga29ac711091186d8a7790be298fb6148b" title="Returns a checksum value of the specified flash row. ">Cy_Flash_RowChecksum()</a> requires the row <b>address</b> (rowAddr) as a parameter. In previous versions of the driver, this function used the row <b>number</b> (rowNum) for this parameter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>The address of the flash row.</td></tr>
    <tr><td class="paramname">checksumPtr</td><td>The pointer to the address where checksum is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the Flash operation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Now <a class="el" href="group__group__flash__functions.html#ga29ac711091186d8a7790be298fb6148b" title="Returns a checksum value of the specified flash row. ">Cy_Flash_RowChecksum()</a> requires the row <b>address</b> (rowAddr) as a parameter. In previous versions of the driver, this function used the row <b>number</b> (rowNum) for this parameter.</dd></dl>
<p>rowAddr The address of the flash row.</p>
<p>checksumPtr The pointer to the address where checksum is to be stored</p>
<p>Returns the status of the Flash operation. </p>

</div>
</div>
<a id="gaf1b44a029169a1baa08e211bff714a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1b44a029169a1baa08e211bff714a19">&#9670;&nbsp;</a></span>Cy_Flash_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_Flash_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates all needed prerequisites to support flash erase/write. </p>
<p>Should be called from each core.</p>
<p>Requires a call to <a class="el" href="group__group__ipc__sema__functions.html#ga1cbc3b147c650c8716de10a1ee8423bd" title="This function initializes the semaphores subsystem. ">Cy_IPC_Sema_Init()</a>, <a class="el" href="group__group__ipc__pipe__functions.html#ga7a1c8f1e92e74f27856ef2b7ac09c640" title="This function stores a copy of a pointer to the array of endpoints. ">Cy_IPC_Pipe_Config()</a> and <a class="el" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c" title="Initializes the system pipes. ">Cy_IPC_Pipe_Init()</a> functions before use for CAT1A devices.</p>
<p>This function is called in the <a class="el" href="group__group__startup__config__system__functions.html#ga93f514700ccf00d08dbdcff7f1224eb2" title="For CAT1A: ">SystemInit()</a> function, for proper flash write and erase operations. If the default startup file is not used, or the function <a class="el" href="group__group__startup__config__system__functions.html#ga93f514700ccf00d08dbdcff7f1224eb2" title="For CAT1A: ">SystemInit()</a> is not called in your project, ensure to perform the following steps before any flash or EmEEPROM write/erase operations: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* 1. Allocate and initialize IPC semaphores for the system operations */</span></div><div class="line">    <span class="keyword">static</span> uint32_t ipcSemaArray[<a class="code" href="group__group__system__config__user__settings__macro.html#gaba78bac52ffcbd69ab531467fa3caa6d">CY_IPC_SEMA_COUNT</a> / <a class="code" href="group__group__ipc__sema__macros.html#ga7c011c5126248439921e442aab3c6b23">CY_IPC_SEMA_PER_WORD</a>];</div><div class="line"></div><div class="line">    (void) <a class="code" href="group__group__ipc__sema__functions.html#ga1cbc3b147c650c8716de10a1ee8423bd">Cy_IPC_Sema_Init</a>(CY_IPC_CHAN_SEMA, <a class="code" href="group__group__system__config__user__settings__macro.html#gaba78bac52ffcbd69ab531467fa3caa6d">CY_IPC_SEMA_COUNT</a>, ipcSemaArray);</div><div class="line"></div><div class="line">    <span class="comment">/* 2. Create an array of endpoint structures and configure an IPC pipe infrastructure */</span></div><div class="line">    <span class="keyword">static</span> <a class="code" href="structcy__stc__ipc__pipe__ep__t.html">cy_stc_ipc_pipe_ep_t</a> ipcPipeEpArray[<a class="code" href="group__group__system__config__user__settings__macro.html#ga26b976c68c4fc4e45bc7f400e97c8495">CY_IPC_MAX_ENDPOINTS</a>];</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga7a1c8f1e92e74f27856ef2b7ac09c640">Cy_IPC_Pipe_Config</a>(ipcPipeEpArray);</div><div class="line"></div><div class="line">    <span class="comment">/* 3. Create an array of client callbacks and initialize a system pipe by a configuration structure */</span></div><div class="line">    <span class="keyword">static</span> cy_ipc_pipe_callback_ptr_t sysIpcPipeCbArray[CY_SYS_CYPIPE_CLIENT_CNT];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structcy__stc__ipc__pipe__config__t.html">cy_stc_ipc_pipe_config_t</a> systemIpcPipeConfig =</div><div class="line">    {</div><div class="line">    <span class="comment">/* .ep0ConfigData */</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* .ipcNotifierNumber    */</span>  CY_IPC_INTR_CYPIPE_EP0,</div><div class="line">            <span class="comment">/* .ipcNotifierPriority  */</span>  CY_SYS_INTR_CYPIPE_PRIOR_EP0,</div><div class="line">            <span class="comment">/* .ipcNotifierMuxNumber */</span>  CY_SYS_INTR_CYPIPE_MUX_EP0,</div><div class="line">            <span class="comment">/* .epAddress            */</span>  CY_IPC_EP_CYPIPE_CM0_ADDR,</div><div class="line">            <span class="comment">/* .epConfig             */</span>  CY_SYS_CYPIPE_CONFIG_EP0</div><div class="line">        },</div><div class="line">    <span class="comment">/* .ep1ConfigData */</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* .ipcNotifierNumber    */</span>  CY_IPC_INTR_CYPIPE_EP1,</div><div class="line">            <span class="comment">/* .ipcNotifierPriority  */</span>  CY_SYS_INTR_CYPIPE_PRIOR_EP1,</div><div class="line">            <span class="comment">/* .ipcNotifierMuxNumber */</span>  0u,</div><div class="line">            <span class="comment">/* .epAddress            */</span>  CY_IPC_EP_CYPIPE_CM4_ADDR,</div><div class="line">            <span class="comment">/* .epConfig             */</span>  CY_SYS_CYPIPE_CONFIG_EP1</div><div class="line">        },</div><div class="line">    <span class="comment">/* .endpointClientsCount     */</span>  CY_SYS_CYPIPE_CLIENT_CNT,</div><div class="line">    <span class="comment">/* .endpointsCallbacksArray  */</span>  sysIpcPipeCbArray,</div><div class="line">    <span class="comment">/* .systemPipeIsrHandler     */</span>  &amp;SysIpcPipeIsr</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c">Cy_IPC_Pipe_Init</a>(&amp;systemIpcPipeConfig);</div><div class="line"></div><div class="line">    <span class="comment">/* 4. And finally initialize the flash */</span></div><div class="line">    <a class="code" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19">Cy_Flash_Init</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Ensure to run these steps on all the MCU cores */</span></div><div class="line"></div></div><!-- fragment --><p> Should be called from each core.</p>
<p>Requires a call to <a class="el" href="group__group__ipc__sema__functions.html#ga1cbc3b147c650c8716de10a1ee8423bd" title="This function initializes the semaphores subsystem. ">Cy_IPC_Sema_Init()</a>, <a class="el" href="group__group__ipc__pipe__functions.html#ga7a1c8f1e92e74f27856ef2b7ac09c640" title="This function stores a copy of a pointer to the array of endpoints. ">Cy_IPC_Pipe_Config()</a> and <a class="el" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c" title="Initializes the system pipes. ">Cy_IPC_Pipe_Init()</a> functions before use.</p>
<p>This function is called in the <a class="el" href="group__group__startup__config__system__functions.html#ga93f514700ccf00d08dbdcff7f1224eb2" title="For CAT1A: ">SystemInit()</a> function, for proper flash write and erase operations. If the default startup file is not used, or the function <a class="el" href="group__group__startup__config__system__functions.html#ga93f514700ccf00d08dbdcff7f1224eb2" title="For CAT1A: ">SystemInit()</a> is not called in your project, ensure to perform the following steps before any flash or EmEEPROM write/erase operations:</p>
<p>Should be called from each core.</p>
<p>This function is called in the <a class="el" href="group__group__startup__config__system__functions.html#ga93f514700ccf00d08dbdcff7f1224eb2" title="For CAT1A: ">SystemInit()</a> function, for proper flash write and erase operations. If the default startup file is not used, or the function <a class="el" href="group__group__startup__config__system__functions.html#ga93f514700ccf00d08dbdcff7f1224eb2" title="For CAT1A: ">SystemInit()</a> is not called in your project, ensure to perform the following steps before any flash or EmEEPROM write/erase operations: </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
