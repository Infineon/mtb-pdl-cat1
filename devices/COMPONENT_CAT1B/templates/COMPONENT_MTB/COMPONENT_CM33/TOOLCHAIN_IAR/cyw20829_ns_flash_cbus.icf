/*******************************************************************************
* \file cyw20829_ns_flash_cbus.icf
* \version 1.0.0
*
* Linker file for the IAR compiler.
*
* The main purpose of the linker script is to describe how the sections in the
* input files should be mapped into the output file, and to control the memory
* layout of the output file.
*
* \note The entry point starts at 0x0401c600. The valid application
* image should be placed there.
*
* \note The linker files included with the PDL template projects must be generic
* and handle all common use cases. Your project may not use every section
* defined in the linker files. In that case you may see warnings during the
* build process. In your project, you can simply comment out or remove the
* relevant code in the linker file.
*
********************************************************************************
* \copyright
* Copyright (c) (2020-2022), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/


/* The size of the stack section at the end of CM33 SRAM */
define symbol STACK_SIZE = 0x800;
define symbol HEAP_SIZE = 0x0400;

define symbol FLASH_START_ADDR_SAHB         = 0x60000000;
define symbol FLASH_START_ADDR_CBUS         = 0x08000000;
define symbol RAM_START_ADDR_SAHB           = 0x20000000;
define symbol RAM_START_ADDR_CBUS           = 0x04000000;
define symbol RAM_END_ADDR_SAHB             = 0x20020000; /* 128K */
define symbol RAM_END_ADDR_CBUS             = 0x04020000; /* 128K */
define symbol FLASH_END_ADDR_SAHB           = 0x60080000; /* 512K */

define symbol BOOTSTRAP_OFFSET_FLASH        = 0x00000050; /* toc2=0x10, l1_desc=0x1C, sign_header=0x20 */
define symbol BOOTSTRAP_OFFSET_RAM          = 0x0001C600;
define symbol APPCODE_OFFSET_FLASH          = 0x00003C00;

define symbol RAMVECTORS_ALIGNMENT          = 512;

/* Memory reserved for Bootstrap code and data */
define symbol BOOTSTRAP_SIZE                = RAM_END_ADDR_SAHB - RAM_START_ADDR_SAHB - BOOTSTRAP_OFFSET_RAM; /* 0x00003A00 */
/* vma for bootstrap code region */
define symbol CODE_VMA                      = RAM_START_ADDR_CBUS + BOOTSTRAP_OFFSET_RAM; /* 0x0401C600 */
/* lma for bootstrap code region */
define symbol CODE_LMA                      = FLASH_START_ADDR_SAHB + BOOTSTRAP_OFFSET_FLASH; /* 0x60000050 */
/* Maximum bootstrap code + data size */
define symbol CODE_BS_SIZE                  = 0x00003800; /* 14 KB */
/* vma for bootstrap data region */
define symbol DATA_BS_VMA                   = RAM_START_ADDR_SAHB + BOOTSTRAP_OFFSET_RAM + CODE_BS_SIZE; /* 0x2001F000 */
/* vma for app data region */
define symbol DATA_VMA                      = RAM_START_ADDR_SAHB; /* 0x20000000 */
/* lma for app data region */
define symbol DATA_LMA                      = CODE_LMA + CODE_BS_SIZE; /* 0x6000204C */
/* app data size */
define symbol DATA_SIZE                     = RAM_END_ADDR_SAHB - DATA_VMA - BOOTSTRAP_SIZE; /* 0x1C600 */
/* vma for application XIP region */
define symbol XIP_VMA                       = FLASH_START_ADDR_CBUS + APPCODE_OFFSET_FLASH; /* 0x08008200 */
/* lma for application XIP region */
define symbol XIP_LMA                       = FLASH_START_ADDR_SAHB + APPCODE_OFFSET_FLASH; /* 0x60008200 */
/* size of XIP region */
define symbol XIP_SIZE                      = FLASH_END_ADDR_SAHB - XIP_LMA;
/* Total size of SRAM */
define symbol RAM_SIZE                      = RAM_END_ADDR_SAHB - RAM_START_ADDR_SAHB; /* 0x00020000 */
/* Size of Bootstrap data is kept same as BOOTSTRAP_SIZE */
define symbol DATA_BS_SIZE                  = BOOTSTRAP_SIZE - CODE_BS_SIZE;

/* The symbols below define the location and size of blocks of memory in the target.
 * Use these symbols to specify the memory regions available for allocation.
 */

/*-Sizes-*/
if (!isdefinedsymbol(__STACK_SIZE)) {
  define symbol __size_cstack__   = STACK_SIZE;
} else {
  define symbol __size_cstack__   = __STACK_SIZE;
}
define symbol __size_proc_stack__ = 0x0;

/* Defines the minimum heap size. The actual heap size will be expanded to the end of the stack region */
if (!isdefinedsymbol(__HEAP_SIZE)) {
    define symbol __size_heap__   = HEAP_SIZE;
} else {
  define symbol __size_heap__     = __HEAP_SIZE;
}

define memory mem with size = 4G;
/* bootstrap code region */
define region CODE_region     = mem:[from CODE_VMA size CODE_BS_SIZE];
/* bootstrap data region */
define region DATA_BS_region  = mem:[from DATA_BS_VMA size DATA_BS_SIZE];
/* app data region */
define region DATA_region     = mem:[from DATA_VMA size DATA_SIZE];
/* app code (xip) region */
define region XIP_region      = mem:[from XIP_VMA size XIP_SIZE];


define block CSTACK           with alignment = 8, size = __size_cstack__     { };
define block PROC_STACK       with alignment = 8, size = __size_proc_stack__ { };
define block HEAP             with expanding size, alignment = 8, minimum size = __size_heap__ { };
define block HSTACK           {first block CSTACK, block PROC_STACK};
define block RO               {first section .intvec};
define block RAMVECTOR        with alignment = RAMVECTORS_ALIGNMENT { section .intvec_ram};
define block APPTEXTRAM       with alignment = 8 { section .cy_ramfunc};
define block XIP              {readonly};

/*-Initializations-*/
initialize by copy { readwrite }; /* copy .data section from flash to ram and initialize by ILINK */
initialize by copy { rw, section .cy_ramfunc }; /* copy .data section from flash to ram and initialize by ILINK */
do not initialize  { section .noinit, section .intvec_ram }; /* exclude .noinit and .intvec_ram sections */

/*-Placement-*/

/* RAM */
place at start of CODE_region     { block RO };
place in          CODE_region     { readonly object *ns_start_cyw20829.o };
place in          CODE_region     { readonly object *ns_system_cyw20829.o };
place in          CODE_region     { readonly object *cy_device.o };
place in          CODE_region     { readonly object *cy_btss.o };
place in          CODE_region     { readonly object *cy_sysclk_v2.o };
place in          CODE_region     { readonly object *cy_syspm_v2.o };
place in          CODE_region     { readonly object *cy_sysint_v2.o };
place in          CODE_region     { readonly object *cy_syslib*.o };
place in          CODE_region     { readonly object *ppu_v1.o };
place in          CODE_region     { readonly object *cy_mpc.o };
place in          CODE_region     { readonly object *cy_pd_ppu.o };


place in          DATA_BS_region  { readwrite object *ns_start_cyw20829.o };
place in          DATA_BS_region  { readwrite object *ns_system_cyw20829.o };
place in          DATA_BS_region  { readwrite object *cy_device.o };
place in          DATA_BS_region  { readwrite object *cy_btss.o };
place in          DATA_BS_region  { readwrite object *cy_sysclk_v2.o };
place in          DATA_BS_region  { readwrite object *cy_syspm_v2.o };
place in          DATA_BS_region  { readwrite object *cy_sysint_v2.o };
place in          DATA_BS_region  { readwrite object *cy_syslib*.o };
place in          DATA_BS_region  { readwrite object *ppu_v1.o };
place in          DATA_BS_region  { readwrite object *cy_mpc.o };
place in          DATA_BS_region  { readwrite object *cy_pd_ppu.o };


place at start of DATA_region     { block HSTACK };
place in          DATA_region     { block RAMVECTOR };
place in          DATA_region     { block APPTEXTRAM };
place in          DATA_region     { readwrite };
place at end   of DATA_region     { block HEAP };


place in          XIP_region      { block XIP };


keep {  section .intvec  };


define exported symbol __bootstrap_code_vma__          = CODE_VMA;
define exported symbol __bootstrap_code_lma__          = CODE_LMA;
define exported symbol __app_code_vma__                = XIP_VMA;
define exported symbol __app_code_lma__                = XIP_LMA;
define exported symbol __bootstrap_size__              = BOOTSTRAP_SIZE;
define exported symbol __bootstrapzero_table_start__   = DATA_BS_VMA;
define exported symbol __bootstrapzero_table_end__     = DATA_BS_VMA;
define exported symbol __bootstrap_start_addr__        = RAM_START_ADDR_SAHB + BOOTSTRAP_OFFSET_RAM;
/* EOF */
