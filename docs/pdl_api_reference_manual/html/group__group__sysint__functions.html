<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT1 Peripheral driver library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT1 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__sysint__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__sysint.html">SysInt       (System Interrupt)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab2ff6820a898e9af3f780000054eea5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a> (const <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> *config, <a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> userIsr)</td></tr>
<tr class="memdesc:gab2ff6820a898e9af3f780000054eea5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the referenced interrupt by setting the priority and the interrupt vector.  <a href="#gab2ff6820a898e9af3f780000054eea5d">More...</a><br /></td></tr>
<tr class="separator:gab2ff6820a898e9af3f780000054eea5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6628d90db5d0e0e8801535e2f1519266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga6628d90db5d0e0e8801535e2f1519266">Cy_SysInt_SetVector</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn, <a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> userIsr)</td></tr>
<tr class="memdesc:ga6628d90db5d0e0e8801535e2f1519266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the ISR vector for the interrupt.  <a href="#ga6628d90db5d0e0e8801535e2f1519266">More...</a><br /></td></tr>
<tr class="separator:ga6628d90db5d0e0e8801535e2f1519266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3feeb7969667eebe109ecab98dbfbb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gac3feeb7969667eebe109ecab98dbfbb2">Cy_SysInt_GetVector</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn)</td></tr>
<tr class="memdesc:gac3feeb7969667eebe109ecab98dbfbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of the current ISR vector for the interrupt.  <a href="#gac3feeb7969667eebe109ecab98dbfbb2">More...</a><br /></td></tr>
<tr class="separator:gac3feeb7969667eebe109ecab98dbfbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e3d1e09d83aa163865bcf5f363d7c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn, <a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> devIntrSrc)</td></tr>
<tr class="memdesc:ga59e3d1e09d83aa163865bcf5f363d7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the interrupt selection for the specified NVIC channel.  <a href="#ga59e3d1e09d83aa163865bcf5f363d7c3">More...</a><br /></td></tr>
<tr class="separator:ga59e3d1e09d83aa163865bcf5f363d7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc962aa9f81be5df394ccf2ff746270b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gacc962aa9f81be5df394ccf2ff746270b">Cy_SysInt_GetInterruptSource</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn)</td></tr>
<tr class="memdesc:gacc962aa9f81be5df394ccf2ff746270b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the interrupt source of the NVIC channel.  <a href="#gacc962aa9f81be5df394ccf2ff746270b">More...</a><br /></td></tr>
<tr class="separator:gacc962aa9f81be5df394ccf2ff746270b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7caa3ebc40ed414983d1330e01dbb932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a> (<a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> devIntrSrc)</td></tr>
<tr class="memdesc:ga7caa3ebc40ed414983d1330e01dbb932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the NVIC channel to which the interrupt source is connected.  <a href="#ga7caa3ebc40ed414983d1330e01dbb932">More...</a><br /></td></tr>
<tr class="separator:ga7caa3ebc40ed414983d1330e01dbb932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e42b44b1946290e12f25ff5042f1fc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga9e42b44b1946290e12f25ff5042f1fc0">Cy_SysInt_GetInterruptActive</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn)</td></tr>
<tr class="memdesc:ga9e42b44b1946290e12f25ff5042f1fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the highest priority active interrupt for the selected NVIC channel.  <a href="#ga9e42b44b1946290e12f25ff5042f1fc0">More...</a><br /></td></tr>
<tr class="separator:ga9e42b44b1946290e12f25ff5042f1fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be24fe4952cebbba78e612463981287"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga7be24fe4952cebbba78e612463981287">Cy_SysInt_DisconnectInterruptSource</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn, <a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> devIntrSrc)</td></tr>
<tr class="memdesc:ga7be24fe4952cebbba78e612463981287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the interrupt source from the specified NVIC channel.  <a href="#ga7be24fe4952cebbba78e612463981287">More...</a><br /></td></tr>
<tr class="separator:ga7be24fe4952cebbba78e612463981287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28cee26f53a27552e4cb434f5b16bde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga28cee26f53a27552e4cb434f5b16bde3">Cy_SysInt_InitExtIRQ</a> (const <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> *config, <a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> userIsr)</td></tr>
<tr class="memdesc:ga28cee26f53a27552e4cb434f5b16bde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the referenced external interrupt by setting the CPU IRQ priority and the interrupt vector.  <a href="#ga28cee26f53a27552e4cb434f5b16bde3">More...</a><br /></td></tr>
<tr class="separator:ga28cee26f53a27552e4cb434f5b16bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc474639ecee7d1014e94464ca72520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga7dc474639ecee7d1014e94464ca72520">Cy_SysInt_InitIntIRQ</a> (const <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> *config, <a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> userIsr)</td></tr>
<tr class="memdesc:ga7dc474639ecee7d1014e94464ca72520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the referenced internal interrupt by setting the priority and the interrupt vector.  <a href="#ga7dc474639ecee7d1014e94464ca72520">More...</a><br /></td></tr>
<tr class="separator:ga7dc474639ecee7d1014e94464ca72520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9dbdadbfad60830b215cc9ca4a14cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gac9dbdadbfad60830b215cc9ca4a14cdc">Cy_SysInt_SetSystemIrqVector</a> (<a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> sysIntSrc, <a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> userIsr)</td></tr>
<tr class="memdesc:gac9dbdadbfad60830b215cc9ca4a14cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the User ISR vector for the System Interrupt.  <a href="#gac9dbdadbfad60830b215cc9ca4a14cdc">More...</a><br /></td></tr>
<tr class="separator:gac9dbdadbfad60830b215cc9ca4a14cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e7577e0339a89a74bf09596a2c874b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga65e7577e0339a89a74bf09596a2c874b">Cy_SysInt_GetSystemIrqVector</a> (<a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> sysIntSrc)</td></tr>
<tr class="memdesc:ga65e7577e0339a89a74bf09596a2c874b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of the current user ISR vector for the System Interrupt.  <a href="#ga65e7577e0339a89a74bf09596a2c874b">More...</a><br /></td></tr>
<tr class="separator:ga65e7577e0339a89a74bf09596a2c874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4be2b36944476c434f4bd20545d8a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga3b4be2b36944476c434f4bd20545d8a3">Cy_SysInt_EnableSystemInt</a> (<a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> sysIntSrc)</td></tr>
<tr class="memdesc:ga3b4be2b36944476c434f4bd20545d8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable system interrupt.  <a href="#ga3b4be2b36944476c434f4bd20545d8a3">More...</a><br /></td></tr>
<tr class="separator:ga3b4be2b36944476c434f4bd20545d8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a85186c69bb5375f1009fba7ea4ca0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga4a85186c69bb5375f1009fba7ea4ca0f">Cy_SysInt_DisableSystemInt</a> (<a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> sysIntSrc)</td></tr>
<tr class="memdesc:ga4a85186c69bb5375f1009fba7ea4ca0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable system interrupt.  <a href="#ga4a85186c69bb5375f1009fba7ea4ca0f">More...</a><br /></td></tr>
<tr class="separator:ga4a85186c69bb5375f1009fba7ea4ca0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3163ed7de473929acded134fc67ab997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga3163ed7de473929acded134fc67ab997">Cy_SysInt_SetNmiSource</a> (<a class="el" href="group__group__sysint__enums.html#ga07f7e918a4abcd8e1da910e9642e6ccb">cy_en_sysint_nmi_t</a> nmiNum, <a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> devIntrSrc)</td></tr>
<tr class="memdesc:ga3163ed7de473929acded134fc67ab997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interrupt source of the CPU core NMI.  <a href="#ga3163ed7de473929acded134fc67ab997">More...</a><br /></td></tr>
<tr class="separator:ga3163ed7de473929acded134fc67ab997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga460d1703cced3ba31091a77355434649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga460d1703cced3ba31091a77355434649">Cy_SysInt_GetNmiSource</a> (<a class="el" href="group__group__sysint__enums.html#ga07f7e918a4abcd8e1da910e9642e6ccb">cy_en_sysint_nmi_t</a> nmiNum)</td></tr>
<tr class="memdesc:ga460d1703cced3ba31091a77355434649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the interrupt source of the CPU core NMI for the given NMI source number.  <a href="#ga460d1703cced3ba31091a77355434649">More...</a><br /></td></tr>
<tr class="separator:ga460d1703cced3ba31091a77355434649"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab2ff6820a898e9af3f780000054eea5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2ff6820a898e9af3f780000054eea5d">&#9670;&nbsp;</a></span>Cy_SysInt_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a> Cy_SysInt_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td>
          <td class="paramname"><em>userIsr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the referenced interrupt by setting the priority and the interrupt vector. </p>
<p>In case of CM33 with Security Extension enabled, if this function is called from secure world then, the parameters are used to configure secure interrupt. If it is called form non-secure world then the parameters are used to configure non-secure interrupt. In case of CM33 without Security Extension, this function always configures the non-secure interrupt. In case of CM55, this function always configures the non-secure interrupt. In case of CM7/CM0+ it initializes the external system interrupt, maps it to CPU interrupt and registers the User ISR vector for the System Interrupt.</p>
<p>Use the CMSIS core function NVIC_EnableIRQ(config.intrSrc) to enable the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Interrupt configuration structure</td></tr>
    <tr><td class="paramname">userIsr</td><td>Address of the ISR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Initialization status</dd></dl>
<dl class="section note"><dt>Note</dt><dd>CM0+/CM4 <br />
 The interrupt vector will be relocated only if the vector table was moved to __ramVectors in SRAM. Otherwise it is ignored.</dd>
<dd>
CM33<br />
 The interrupt vector will be relocated only if the vector table was moved to __s_vector_table_rw and __ns_vector_table_rw for secure and non-secure world respectively.</dd>
<dd>
CM55<br />
 The interrupt vector will be relocated only if the vector table was moved to __ns_vector_table_rw non-secure world.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is relocated to RAM in __ramVectors[] */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Prototype of ISR function for port interrupt 0. For CY_IP_M7CPUSS port 21 is configured */</span></div><div class="line">    <span class="keywordtype">void</span> Interrupt_Handler_Port0 (<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the interrupt with vector at Interrupt_Handler_Port0() */</span></div><div class="line">    <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;intrCfg, &amp;Interrupt_Handler_Port0);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the interrupt */</span></div><div class="line"><span class="preprocessor">#if (CY_IP_M7CPUSS)</span></div><div class="line">    NVIC_EnableIRQ((<a class="code" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>) NvicMux3_IRQn);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    NVIC_EnableIRQ(intrCfg.intrSrc);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga6628d90db5d0e0e8801535e2f1519266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6628d90db5d0e0e8801535e2f1519266">&#9670;&nbsp;</a></span>Cy_SysInt_SetVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> Cy_SysInt_SetVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td>
          <td class="paramname"><em>userIsr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the ISR vector for the interrupt. </p>
<p>CM0+/CM4 (non-TVIIBE):<br />
 This function relies on the assumption that the vector table is relocated to __ramVectors[RAM_VECTORS_SIZE] in SRAM. Otherwise it will return the address of the default ISR location in the flash vector table.</p>
<p>CM0+/CM7 and TVIIBE CM0+/CM4:<br />
 This function relies on the assumption that the vector table is relocated to __ramVectors[RAM_VECTORS_SIZE] in SRAM. Otherwise it will return the address of the default ISR location in the flash vector table. This function is applicable only to User Interrupts (NvicMux0_IRQn - NvicMux7_IRQn) and System Interrupts (Internal0_IRQn - Internal0_IRQn).</p>
<p>CM33:<br />
 When called from secure world. this function relies on the assumption that the vector table is relocated to __s_vector_table_rw[] in secure SRAM. Otherwise it will return the address of the default ISR location in the secure flash/ROM vector table.</p>
<p>When called from non-secure world. this function relies on the assumption that the vector table is relocated to __ns_vector_table_rw[] in non-secure SRAM. Otherwise it will return the address of the default ISR location in the non-secure flash/ROM vector table.</p>
<p>CM55:<br />
 This function relies on the assumption that the vector table is relocated to __ns_vector_table_rw[] in non-secure SRAM. Otherwise it will return the address of the default ISR location in the non-secure flash/ROM vector table.</p>
<p>Use the CMSIS core function NVIC_EnableIRQ(config.intrSrc) to enable the interrupt. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>Interrupt source</td></tr>
    <tr><td class="paramname">userIsr</td><td>Address of the ISR to set in the interrupt vector table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previous address of the ISR in the interrupt vector table</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For CM0+, this function sets the interrupt vector for the interrupt channel on the NVIC.</dd>
<dd>
In case of CM33 with Security Extension enabled, if this function is called from secure world then, it sets the interrupt vector for the secure world. If it is called form non-secure world then it sets the interrupt vector for the non-secure world.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is relocated to RAM in __ramVectors[]. The interrupt</span></div><div class="line"><span class="comment">                 was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Prototype of ISR function for port interrupt 0 */</span></div><div class="line">    <span class="keywordtype">void</span> Interrupt_Handler_Port0 (<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(&amp;Interrupt_Handler_Port0 != <a class="code" href="group__group__sysint__functions.html#gac3feeb7969667eebe109ecab98dbfbb2">Cy_SysInt_GetVector</a>(intrCfg.intrSrc))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the port0 interrupt vector to be at Interrupt_Handler_Port0() */</span></div><div class="line">        (void)<a class="code" href="group__group__sysint__functions.html#ga6628d90db5d0e0e8801535e2f1519266">Cy_SysInt_SetVector</a>(intrCfg.intrSrc, &amp;Interrupt_Handler_Port0);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gac3feeb7969667eebe109ecab98dbfbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3feeb7969667eebe109ecab98dbfbb2">&#9670;&nbsp;</a></span>Cy_SysInt_GetVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> Cy_SysInt_GetVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the address of the current ISR vector for the interrupt. </p>
<p>CM0+/CM4:<br />
 This function relies on the assumption that the vector table is relocated to __ramVectors[RAM_VECTORS_SIZE] in SRAM. Otherwise it will return the address of the default ISR location in the flash vector table.</p>
<p>CM0+/CM7:<br />
 This function relies on the assumption that the vector table is relocated to __ramVectors[RAM_VECTORS_SIZE] in SRAM. Otherwise it will return the address of the default ISR location in the flash vector table. This function is applicable only to User Interrupts (NvicMux0_IRQn - NvicMux7_IRQn) and System Interrupts (Internal0_IRQn - Internal0_IRQn).</p>
<p>CM33:<br />
 When called from the secure world, this function relies on the assumption that the vector table is relocated to __ns_vector_table_rw[] in non-secure SRAM. Otherwise it will return the address of the default ISR location in the flash/ROM vector table.</p>
<p>CM55:<br />
 This function relies on the assumption that the vector table is relocated to __ns_vector_table_rw[] in non-secure SRAM. Otherwise it will return the address of the default ISR location in the flash/ROM vector table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>Interrupt source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the ISR in the interrupt vector table</dd></dl>
<dl class="section note"><dt>Note</dt><dd>CM0+:<br />
 This function returns the interrupt vector for the interrupt channel on the NVIC.</dd>
<dd>
CM33:<br />
In case of CM33 with Security Extension enabled, if this function is called from secure world then, it returns the interrupt vector for the secure world. If it is called form non-secure world then it returns the interrupt vector for the non-secure world.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is relocated to RAM in __ramVectors[]. The interrupt</span></div><div class="line"><span class="comment">                 was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Prototype of ISR function for port interrupt 0 */</span></div><div class="line">    <span class="keywordtype">void</span> Interrupt_Handler_Port0 (<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(&amp;Interrupt_Handler_Port0 != <a class="code" href="group__group__sysint__functions.html#gac3feeb7969667eebe109ecab98dbfbb2">Cy_SysInt_GetVector</a>(intrCfg.intrSrc))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the port0 interrupt vector to be at Interrupt_Handler_Port0() */</span></div><div class="line">        (void)<a class="code" href="group__group__sysint__functions.html#ga6628d90db5d0e0e8801535e2f1519266">Cy_SysInt_SetVector</a>(intrCfg.intrSrc, &amp;Interrupt_Handler_Port0);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga59e3d1e09d83aa163865bcf5f363d7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e3d1e09d83aa163865bcf5f363d7c3">&#9670;&nbsp;</a></span>Cy_SysInt_SetInterruptSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysInt_SetInterruptSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>devIntrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the interrupt selection for the specified NVIC channel. </p>
<p>To disconnect the interrupt source from the NVIC channel use the <a class="el" href="group__group__sysint__functions.html#ga7be24fe4952cebbba78e612463981287">Cy_SysInt_DisconnectInterruptSource</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>NVIC channel number connected to the CPU core.</td></tr>
    <tr><td class="paramname">devIntrSrc</td><td>Device interrupt to be routed to the NVIC channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CM0+/CM7 core only.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reconfigure the interrupt source of the NVIC input on the CM0+</span></div><div class="line"><span class="comment">                 core at run-time. The interrupt was initialized with the</span></div><div class="line"><span class="comment">                 &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"><span class="preprocessor">#if (CY_IP_M4CPUSS_VERSION == 1)</span></div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#gacc962aa9f81be5df394ccf2ff746270b">Cy_SysInt_GetInterruptSource</a>(intrCfg.intrSrc))</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CY_IP_M4CPUSS_VERSION == 2 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #if defined (CY_IP_M7CPUSS)</span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a>((<a class="code" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>)((uint32_t)intrCfg.intrSrc &amp; <a class="code" href="group__group__sysint.html#ga06c8142ccb50c175443ac78951ea4d21">CY_SYSINT_INTRSRC_MASK</a>)))</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a>(intrCfg.cm0pSrc))</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_IP_M4CPUSS_VERSION */</span><span class="preprocessor"></span></div><div class="line">    {</div><div class="line"><span class="preprocessor">        #if defined (CY_IP_M7CPUSS)</span></div><div class="line">        <a class="code" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> irqn = (<a class="code" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>)((uint32_t)intrCfg.intrSrc &gt;&gt; <a class="code" href="group__group__sysint.html#ga3b9f1b9de4f122495a8b6580ce500d9a">CY_SYSINT_INTRSRC_MUXIRQ_SHIFT</a>);</div><div class="line">        <a class="code" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> intr_src = (<a class="code" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>)((uint32_t)intrCfg.intrSrc &amp; <a class="code" href="group__group__sysint.html#ga06c8142ccb50c175443ac78951ea4d21">CY_SYSINT_INTRSRC_MASK</a>);</div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a>(irqn, intr_src);</div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">        <span class="comment">/* Set the interrupt source for intrCfg.intrSrc on CM0+ */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a>(intrCfg.intrSrc, intrCfg.cm0pSrc);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gacc962aa9f81be5df394ccf2ff746270b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc962aa9f81be5df394ccf2ff746270b">&#9670;&nbsp;</a></span>Cy_SysInt_GetInterruptSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> Cy_SysInt_GetInterruptSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the interrupt source of the NVIC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>NVIC channel number connected to the CPU core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device interrupt connected to the NVIC channel. A returned value of "disconnected_IRQn" indicates that the interrupt source is disconnected.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CM0+ core only.</dd>
<dd>
This function supports only devices using CPUSS_ver1. For all other devices, use the <a class="el" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932" title="Gets the NVIC channel to which the interrupt source is connected. ">Cy_SysInt_GetNvicConnection()</a> function.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reconfigure the interrupt source of the NVIC input on the CM0+</span></div><div class="line"><span class="comment">                 core at run-time. The interrupt was initialized with the</span></div><div class="line"><span class="comment">                 &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"><span class="preprocessor">#if (CY_IP_M4CPUSS_VERSION == 1)</span></div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#gacc962aa9f81be5df394ccf2ff746270b">Cy_SysInt_GetInterruptSource</a>(intrCfg.intrSrc))</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CY_IP_M4CPUSS_VERSION == 2 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #if defined (CY_IP_M7CPUSS)</span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a>((<a class="code" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>)((uint32_t)intrCfg.intrSrc &amp; CY_SYSINT_INTRSRC_MASK)))</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a>(intrCfg.cm0pSrc))</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_IP_M4CPUSS_VERSION */</span><span class="preprocessor"></span></div><div class="line">    {</div><div class="line"><span class="preprocessor">        #if defined (CY_IP_M7CPUSS)</span></div><div class="line">        <a class="code" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> irqn = (<a class="code" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>)((uint32_t)intrCfg.intrSrc &gt;&gt; <a class="code" href="group__group__sysint.html#ga3b9f1b9de4f122495a8b6580ce500d9a">CY_SYSINT_INTRSRC_MUXIRQ_SHIFT</a>);</div><div class="line">        <a class="code" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> intr_src = (<a class="code" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>)((uint32_t)intrCfg.intrSrc &amp; <a class="code" href="group__group__sysint.html#ga06c8142ccb50c175443ac78951ea4d21">CY_SYSINT_INTRSRC_MASK</a>);</div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a>(irqn, intr_src);</div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">        <span class="comment">/* Set the interrupt source for intrCfg.intrSrc on CM0+ */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a>(intrCfg.intrSrc, intrCfg.cm0pSrc);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7caa3ebc40ed414983d1330e01dbb932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7caa3ebc40ed414983d1330e01dbb932">&#9670;&nbsp;</a></span>Cy_SysInt_GetNvicConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> Cy_SysInt_GetNvicConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>devIntrSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the NVIC channel to which the interrupt source is connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devIntrSrc</td><td>Device interrupt that is potentially connected to the NVIC channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NVIC channel number connected to the CPU core. A returned value of "unconnected_IRQn" indicates that the interrupt source is disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CM0+/CM7 core only.</dd>
<dd>
This function supports only devices using CPUSS_ver2 or higher.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reconfigure the interrupt source of the NVIC input on the CM0+</span></div><div class="line"><span class="comment">                 core at run-time. The interrupt was initialized with the</span></div><div class="line"><span class="comment">                 &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"><span class="preprocessor">#if (CY_IP_M4CPUSS_VERSION == 1)</span></div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#gacc962aa9f81be5df394ccf2ff746270b">Cy_SysInt_GetInterruptSource</a>(intrCfg.intrSrc))</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CY_IP_M4CPUSS_VERSION == 2 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #if defined (CY_IP_M7CPUSS)</span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a>((<a class="code" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>)((uint32_t)intrCfg.intrSrc &amp; CY_SYSINT_INTRSRC_MASK)))</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a>(intrCfg.cm0pSrc))</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_IP_M4CPUSS_VERSION */</span><span class="preprocessor"></span></div><div class="line">    {</div><div class="line"><span class="preprocessor">        #if defined (CY_IP_M7CPUSS)</span></div><div class="line">        <a class="code" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> irqn = (<a class="code" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>)((uint32_t)intrCfg.intrSrc &gt;&gt; <a class="code" href="group__group__sysint.html#ga3b9f1b9de4f122495a8b6580ce500d9a">CY_SYSINT_INTRSRC_MUXIRQ_SHIFT</a>);</div><div class="line">        <a class="code" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> intr_src = (<a class="code" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>)((uint32_t)intrCfg.intrSrc &amp; <a class="code" href="group__group__sysint.html#ga06c8142ccb50c175443ac78951ea4d21">CY_SYSINT_INTRSRC_MASK</a>);</div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a>(irqn, intr_src);</div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">        <span class="comment">/* Set the interrupt source for intrCfg.intrSrc on CM0+ */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a>(intrCfg.intrSrc, intrCfg.cm0pSrc);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga9e42b44b1946290e12f25ff5042f1fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e42b44b1946290e12f25ff5042f1fc0">&#9670;&nbsp;</a></span>Cy_SysInt_GetInterruptActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> Cy_SysInt_GetInterruptActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the highest priority active interrupt for the selected NVIC channel. </p>
<p>The priority of the interrupt in a given channel is determined by the index value of the interrupt in the cy_en_intr_t enum. The lower the index, the higher the priority. E.g. Consider a case where an interrupt source with value 29 and an interrupt source with value 46 both source the same NVIC channel. If both are active (triggered) at the same time, calling <a class="el" href="group__group__sysint__functions.html#ga9e42b44b1946290e12f25ff5042f1fc0" title="Gets the highest priority active interrupt for the selected NVIC channel. ">Cy_SysInt_GetInterruptActive()</a> will return 29 as the active interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>NVIC channel number connected to the CPU core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device interrupt connected to the NVIC channel. A returned value of "disconnected_IRQn" indicates that there are no active (pending) interrupts on this NVIC channel.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CM0+/CM7 core only.</dd>
<dd>
This function supports only devices using CPUSS_ver2 or higher.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Inside the interrupt service routine for NvicMux7_IRQn: */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (intrCfg.cm0pSrc == <a class="code" href="group__group__sysint__functions.html#ga9e42b44b1946290e12f25ff5042f1fc0">Cy_SysInt_GetInterruptActive</a>(intrCfg.intrSrc))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle the ioss_interrupts_gpio_0_IRQn interrupt */</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7be24fe4952cebbba78e612463981287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7be24fe4952cebbba78e612463981287">&#9670;&nbsp;</a></span>Cy_SysInt_DisconnectInterruptSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysInt_DisconnectInterruptSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>devIntrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect the interrupt source from the specified NVIC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>NVIC channel number connected to the CPU core. This parameter is ignored for devices using CPUSS_ver2.</td></tr>
    <tr><td class="paramname">devIntrSrc</td><td>Device interrupt routed to the NVIC channel. This parameter is ignored for devices using CPUSS_ver1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CM0+ core only.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Disconnect the previously connected interrupt source */</span></div><div class="line"></div><div class="line">    <a class="code" href="group__group__sysint__functions.html#ga7be24fe4952cebbba78e612463981287">Cy_SysInt_DisconnectInterruptSource</a>(intrCfg.intrSrc, intrCfg.cm0pSrc);</div><div class="line">    </div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga28cee26f53a27552e4cb434f5b16bde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28cee26f53a27552e4cb434f5b16bde3">&#9670;&nbsp;</a></span>Cy_SysInt_InitExtIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a> Cy_SysInt_InitExtIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td>
          <td class="paramname"><em>userIsr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the referenced external interrupt by setting the CPU IRQ priority and the interrupt vector. </p>
<p>Use the CMSIS core function NVIC_EnableIRQ(config.intrSrc) to enable the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Interrupt configuration structure</td></tr>
    <tr><td class="paramname">userIsr</td><td>Address of the ISR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CAT1C CM0/CM7 cores, and CAT1A TVIIBE CM0/CM4 cores.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Initialization status</dd></dl>
<dl class="section note"><dt>Note</dt><dd>CM0+/CM7 <br />
 The interrupt vector will be relocated only if the vector table was moved to __ramVectors in SRAM. Otherwise it is ignored. </dd></dl>

</div>
</div>
<a id="ga7dc474639ecee7d1014e94464ca72520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dc474639ecee7d1014e94464ca72520">&#9670;&nbsp;</a></span>Cy_SysInt_InitIntIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a> Cy_SysInt_InitIntIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td>
          <td class="paramname"><em>userIsr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the referenced internal interrupt by setting the priority and the interrupt vector. </p>
<p>Use the CMSIS core function NVIC_EnableIRQ(config.intrSrc) to enable the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Interrupt configuration structure</td></tr>
    <tr><td class="paramname">userIsr</td><td>Address of the ISR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CAT1C CM0/CM7 cores, and CAT1A TVIIBE CM0/CM4 cores.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Initialization status</dd></dl>
<dl class="section note"><dt>Note</dt><dd>CM0+/CM7 <br />
 The interrupt vector will be relocated only if the vector table was moved to __ramVectors in SRAM. Otherwise it is ignored. </dd></dl>

</div>
</div>
<a id="gac9dbdadbfad60830b215cc9ca4a14cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9dbdadbfad60830b215cc9ca4a14cdc">&#9670;&nbsp;</a></span>Cy_SysInt_SetSystemIrqVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysInt_SetSystemIrqVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>sysIntSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td>
          <td class="paramname"><em>userIsr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the User ISR vector for the System Interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sysIntSrc</td><td>Interrupt source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CAT1C CM0/CM7 cores.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userIsr</td><td>Address of the ISR to set in the interrupt vector table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga65e7577e0339a89a74bf09596a2c874b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65e7577e0339a89a74bf09596a2c874b">&#9670;&nbsp;</a></span>Cy_SysInt_GetSystemIrqVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> Cy_SysInt_GetSystemIrqVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>sysIntSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the address of the current user ISR vector for the System Interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sysIntSrc</td><td>Interrupt source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CAT1C CM0/CM7 cores.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the ISR in the interrupt vector table </dd></dl>

</div>
</div>
<a id="ga3b4be2b36944476c434f4bd20545d8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b4be2b36944476c434f4bd20545d8a3">&#9670;&nbsp;</a></span>Cy_SysInt_EnableSystemInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysInt_EnableSystemInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>sysIntSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable system interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sysIntSrc</td><td>System interrupt source to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CAT1C CM0/CM7 cores, and CAT1A TVIIBE CM0/CM4 cores.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga4a85186c69bb5375f1009fba7ea4ca0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a85186c69bb5375f1009fba7ea4ca0f">&#9670;&nbsp;</a></span>Cy_SysInt_DisableSystemInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysInt_DisableSystemInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>sysIntSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable system interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sysIntSrc</td><td>System interrupt source to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CAT1C CM0/CM7 cores, and CAT1A TVIIBE CM0/CM4 cores.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga3163ed7de473929acded134fc67ab997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3163ed7de473929acded134fc67ab997">&#9670;&nbsp;</a></span>Cy_SysInt_SetNmiSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysInt_SetNmiSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga07f7e918a4abcd8e1da910e9642e6ccb">cy_en_sysint_nmi_t</a>&#160;</td>
          <td class="paramname"><em>nmiNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>devIntrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interrupt source of the CPU core NMI. </p>
<p>The interrupt source must be a positive number. Setting the value to "unconnected_IRQn" or "disconnected_IRQn" disconnects the interrupt source from the NMI. Depending on the device, the number of interrupt sources that can provide the NMI trigger signal to the core can vary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmiNum</td><td>NMI source number. CPUSS_ver2 allows up to 4 sources to trigger the core NMI. CPUSS_ver1 allows only one source to trigger the core NMI and the specified NMI number is ignored.</td></tr>
    <tr><td class="paramname">devIntrSrc</td><td>Interrupt source. This parameter can either be of type cy_en_intr_t or IRQn_Type for CM0+/CM7 and CM4/CM33/CM55 respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>CM0+ may call this function only at PC=0, CM4 may set its NMI handler at any PC. </dd>
<dd>
The CM0+ NMI is used for performing system calls that execute out of ROM.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Set the NMI trigger source for the processor of interest. The</span></div><div class="line"><span class="comment">                 interrupt was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"><span class="preprocessor">#if (CY_CPU_CORTEX_M0P) || (CY_CPU_CORTEX_M7)</span></div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga460d1703cced3ba31091a77355434649">Cy_SysInt_GetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>))</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CM4 */</span><span class="preprocessor"></span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga460d1703cced3ba31091a77355434649">Cy_SysInt_GetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>))</div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_CPU_CORTEX_M0P */</span><span class="preprocessor"></span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the NMI source to GPIO port 0 interrupt */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga3163ed7de473929acded134fc67ab997">Cy_SysInt_SetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>, ioss_interrupts_gpio_0_IRQn);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga460d1703cced3ba31091a77355434649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga460d1703cced3ba31091a77355434649">&#9670;&nbsp;</a></span>Cy_SysInt_GetNmiSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> Cy_SysInt_GetNmiSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga07f7e918a4abcd8e1da910e9642e6ccb">cy_en_sysint_nmi_t</a>&#160;</td>
          <td class="paramname"><em>nmiNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the interrupt source of the CPU core NMI for the given NMI source number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmiNum</td><td>NMI source number. CPUSS_ver2 allows up to 4 sources to trigger the core NMI (i.e. #1, 2, 3, 4). CPUSS_ver1 allows only 1 source to trigger the core NMI (i.e #1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt Source. This parameter can either be of type cy_en_intr_t or IRQn_Type for CM0+/CM7 and CM4/CM33/CM55 respectively.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Set the NMI trigger source for the processor of interest. The</span></div><div class="line"><span class="comment">                 interrupt was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"><span class="preprocessor">#if (CY_CPU_CORTEX_M0P) || (CY_CPU_CORTEX_M7)</span></div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga460d1703cced3ba31091a77355434649">Cy_SysInt_GetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>))</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CM4 */</span><span class="preprocessor"></span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga460d1703cced3ba31091a77355434649">Cy_SysInt_GetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>))</div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_CPU_CORTEX_M0P */</span><span class="preprocessor"></span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the NMI source to GPIO port 0 interrupt */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga3163ed7de473929acded134fc67ab997">Cy_SysInt_SetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>, ioss_interrupts_gpio_0_IRQn);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT1 Peripheral driver library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
